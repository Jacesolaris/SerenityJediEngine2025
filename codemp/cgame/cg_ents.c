/*
===========================================================================
Copyright (C) 1999 - 2005, Id Software, Inc.
Copyright (C) 2000 - 2013, Raven Software, Inc.
Copyright (C) 2001 - 2013, Activision, Inc.
Copyright (C) 2005 - 2015, ioquake3 contributors
Copyright (C) 2013 - 2015, SerenityJediEngine2025 contributors

This file is part of the SerenityJediEngine2025 source code.

SerenityJediEngine2025 is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <http://www.gnu.org/licenses/>.
===========================================================================
*/

// cg_ents.c -- present snapshot entities, happens every single frame

#include "cg_local.h"
/*
Ghoul2 Insert Start
*/
#include "qcommon/q_shared.h"
#include "ghoul2/G2.h"
/*
Ghoul2 Insert end
*/

extern qboolean CG_InFighter(void);
static void CG_Missile(centity_t* cent);

#define	FX_ALPHA_LINEAR		0x00000001
#define	FX_SIZE_LINEAR		0x00000100
static vec3_t BLUER = { 0.0f, 0.0f, 1.0f };

/*
======================
CG_PositionEntityOnTag

Modifies the entities position and axis by the given
tag location
======================
*/
void CG_PositionEntityOnTag(refEntity_t* entity, const refEntity_t* parent,
	const qhandle_t parent_model, const char* tag_name)
{
	orientation_t lerped;

	// lerp the tag
	trap->R_LerpTag(&lerped, parent_model, parent->oldframe, parent->frame,
		1.0 - parent->backlerp, tag_name);

	// FIXME: allow origin offsets along tag?
	VectorCopy(parent->origin, entity->origin);
	for (int i = 0; i < 3; i++)
	{
		VectorMA(entity->origin, lerped.origin[i], parent->axis[i], entity->origin);
	}

	// had to cast away the const to avoid compiler problems...
	MatrixMultiply(lerped.axis, ((refEntity_t*)parent)->axis, entity->axis);
	entity->backlerp = parent->backlerp;
}

/*
======================
CG_PositionRotatedEntityOnTag

Modifies the entities position and axis by the given
tag location
======================
*/
void CG_PositionRotatedEntityOnTag(refEntity_t* entity, const refEntity_t* parent,
	const qhandle_t parent_model, const char* tag_name)
{
	orientation_t lerped;
	matrix3_t tempAxis;

	//AxisClear( entity->axis );
	// lerp the tag
	trap->R_LerpTag(&lerped, parent_model, parent->oldframe, parent->frame,
		1.0 - parent->backlerp, tag_name);

	// FIXME: allow origin offsets along tag?
	VectorCopy(parent->origin, entity->origin);
	for (int i = 0; i < 3; i++)
	{
		VectorMA(entity->origin, lerped.origin[i], parent->axis[i], entity->origin);
	}

	// had to cast away the const to avoid compiler problems...
	MatrixMultiply(entity->axis, lerped.axis, tempAxis);
	MatrixMultiply(tempAxis, ((refEntity_t*)parent)->axis, entity->axis);
}

/*
==========================================================================

FUNCTIONS CALLED EACH FRAME

==========================================================================
*/

//only need to use the CG_S_ system when you want a looping sound that isn't going to add itself
//via trap each frame. Such as ones generated by events.
/*
======================
CG_SetEntitySoundPosition

Also called by event processing code
======================
*/
void CG_SetEntitySoundPosition(const centity_t* cent)
{
	if (cent->currentState.solid == SOLID_BMODEL)
	{
		vec3_t origin;

		const float* v = cgs.inlineModelMidpoints[cent->currentState.modelIndex];
		VectorAdd(cent->lerpOrigin, v, origin);
		trap->S_UpdateEntityPosition(cent->currentState.number, origin);
	}
	else
	{
		trap->S_UpdateEntityPosition(cent->currentState.number, cent->lerpOrigin);
	}
}

/*
==================
CG_S_AddLoopingSound

Set the current looping sounds on the entity.
==================
*/
void CG_S_AddLoopingSound(const int entityNum, const vec3_t origin, const vec3_t velocity, const sfxHandle_t sfx)
{
	centity_t* cent = &cg_entities[entityNum];
	cgLoopSound_t* cSound = NULL;
	int i = 0;
	qboolean alreadyPlaying = qfalse;

	//first see if we're already looping this sound handle.
	while (i < cent->numLoopingSounds)
	{
		cSound = &cent->loopingSound[i];

		if (cSound->sfx == sfx)
		{
			alreadyPlaying = qtrue;
			break;
		}

		i++;
	}

	if (alreadyPlaying && cSound)
	{
		//if this is the case, just update the properties of the looping sound and return.
		VectorCopy(origin, cSound->origin);
		VectorCopy(velocity, cSound->velocity);
	}
	else if (cent->numLoopingSounds >= MAX_CG_LOOPSOUNDS)
	{
		//Just don't add it then I suppose.
		return;
	}

	//Add a new looping sound.
	cSound = &cent->loopingSound[cent->numLoopingSounds];

	cSound->entityNum = entityNum;
	VectorCopy(origin, cSound->origin);
	VectorCopy(velocity, cSound->velocity);
	cSound->sfx = sfx;

	cent->numLoopingSounds++;
}

/*
==================
CG_S_AddLoopingSound

For now just redirect, might eventually do something different.
==================
*/
void CG_S_AddRealLoopingSound(const int entityNum, const vec3_t origin, const vec3_t velocity, const sfxHandle_t sfx)
{
	CG_S_AddLoopingSound(entityNum, origin, velocity, sfx);
}

/*
==================
CG_S_AddLoopingSound

Clear looping sounds.
==================
*/
void CG_S_StopLoopingSound(const int entityNum, const sfxHandle_t sfx)
{
	centity_t* cent = &cg_entities[entityNum];

	if (sfx == -1)
	{
		//clear all the looping sounds on the entity
		cent->numLoopingSounds = 0;
	}
	else
	{
		//otherwise, clear only the specified looping sound
		int i = 0;

		while (i < cent->numLoopingSounds)
		{
			const cgLoopSound_t* c_sound = &cent->loopingSound[i];

			if (c_sound->sfx == sfx)
			{
				//remove it then
				int x = i + 1;

				while (x < cent->numLoopingSounds)
				{
					memcpy(&cent->loopingSound[x - 1], &cent->loopingSound[x], sizeof cent->loopingSound[x]);
					x++;
				}
				cent->numLoopingSounds--;
			}

			i++;
		}
	}
	//trap->S_StopLoopingSound(entityNum);
}

/*
==================
CG_S_UpdateLoopingSounds

Update any existing looping sounds on the entity.
==================
*/
void CG_S_UpdateLoopingSounds(const int entityNum)
{
	const centity_t* cent = &cg_entities[entityNum];
	vec3_t lerp_org;
	int i = 0;

	if (!cent->numLoopingSounds)
	{
		return;
	}

	if (cent->currentState.eType == ET_MOVER)
	{
		const float* v = cgs.inlineModelMidpoints[cent->currentState.modelIndex];
		VectorAdd(cent->lerpOrigin, v, lerp_org);
	}
	else
	{
		VectorCopy(cent->lerpOrigin, lerp_org);
	}

	if (cent->currentState.eFlags & EF_SOUNDTRACKER
		&& (!cg.snap || cent->currentState.trickedentindex != cg.snap->ps.clientNum))
	{
		//keep sound for this entity updated in accordance with its attached entity at all times
		//entity out of range
		if (!cg_entities[cent->currentState.trickedentindex].currentValid)
			return;

		VectorCopy(cg_entities[cent->currentState.trickedentindex].lerpOrigin, lerp_org);
	}

	while (i < cent->numLoopingSounds)
	{
		const cgLoopSound_t* cSound = &cent->loopingSound[i];

		//trap->S_AddLoopingSound(entityNum, cSound->origin, cSound->velocity, cSound->sfx);
		//I guess just keep using lerpOrigin for now,
		trap->S_AddLoopingSound(entityNum, lerp_org, cSound->velocity, cSound->sfx);
		i++;
	}
}

/*
==================
CG_EntityEffects

Add continuous entity effects, like local entity emission and lighting
==================
*/
extern qboolean InBriefing;
extern qboolean InCinematic;

static void CG_EntityEffects(const centity_t* cent)
{
	if (!cent) return;

	// update sound origins
	CG_SetEntitySoundPosition(cent);

	// add loop sound
	if (cent->currentState.loopSound || cent->currentState.loopIsSoundset && cent->currentState.number >= MAX_CLIENTS
		&& cent->currentState.loopSound < MAX_SOUNDS && !InCinematic && !InBriefing)
	{
		sfxHandle_t realSoundIndex = -1;

		if (cent->currentState.loopIsSoundset && cent->currentState.number >= MAX_CLIENTS)
		{
			//If this is so, then first get our soundset from the index, and loopSound actually contains which part of the set to

			const char* sound_set = CG_ConfigString(CS_AMBIENT_SET + cent->currentState.soundSetIndex);

			if (sound_set && sound_set[0])
			{
				realSoundIndex = trap->AS_GetBModelSound(sound_set, cent->currentState.loopSound);
			}
		}
		else
		{
			realSoundIndex = cgs.gameSounds[cent->currentState.loopSound];
		}

		//rww - doors and things with looping sounds have a crazy origin (being brush models and all)
		if (realSoundIndex != -1)
		{
			if (cent->currentState.solid == SOLID_BMODEL)
			{
				vec3_t origin;

				const float* v = cgs.inlineModelMidpoints[cent->currentState.modelIndex];
				VectorAdd(cent->lerpOrigin, v, origin);
				trap->S_AddLoopingSound(cent->currentState.number, origin, vec3_origin,
					realSoundIndex);
			}
			else if (cent->currentState.eType != ET_SPEAKER)
			{
				trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, vec3_origin, realSoundIndex);
			}
			else
			{
				trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, vec3_origin, realSoundIndex);
			}
		}
	}

	// constant light glow
	if (cent->currentState.constantLight
		&& cent->currentState.eType != ET_PLAYER
		&& cent->currentState.eType != ET_BODY
		&& cent->currentState.eType != ET_NPC
		&& cent->currentState.eType != ET_INVISIBLE
		/*&& cent->currentState.eType != ET_GENERAL
		&& cent->currentState.eType != ET_ITEM
		&& cent->currentState.eType != ET_MISSILE
		&& cent->currentState.eType != ET_SPECIAL
		&& cent->currentState.eType != ET_HOLOCRON
		&& cent->currentState.eType != ET_MOVER
		&& cent->currentState.eType != ET_BEAM
		&& cent->currentState.eType != ET_TEAM
		&& cent->currentState.eType != ET_TERRAIN
		&& cent->currentState.eType != ET_FX*/
		)
	{
		const int cl = cent->currentState.constantLight;
		const float r = (float)(cl & 0xFF) / 255.0;
		const float g = (float)(cl >> 8 & 0xFF) / 255.0;
		const float b = (float)(cl >> 16 & 0xFF) / 255.0;
		const float i = (float)(cl >> 24 & 0xFF) * 4.0;
		trap->R_AddLightToScene(cent->lerpOrigin, i, r, g, b);
	}
}

static localEntity_t* FX_AddOrientedLine(vec3_t start, vec3_t end, vec3_t normal, const float st_scale, const float scale,
	const float dscale, const float startalpha, const float endalpha,
	const float kill_time,
	const qhandle_t shader)
{
	localEntity_t* le;

#ifdef _DEBUG
	if (!shader)
	{
		Com_Printf("FX_AddLine: NULL shader\n");
	}
#endif

	le = CG_AllocLocalEntity();
	le->leType = LE_OLINE;

	le->startTime = cg.time;
	le->endTime = le->startTime + kill_time;
	le->data.line.width = scale;
	le->data.line.dwidth = dscale;

	le->alpha = startalpha;
	le->dalpha = endalpha - startalpha;

	le->refEntity.data.line.stscale = st_scale;
	le->refEntity.data.line.width = scale;

	le->refEntity.customShader = shader;

	// set origin
	VectorCopy(start, le->refEntity.origin);
	VectorCopy(end, le->refEntity.oldorigin);

	AxisClear(le->refEntity.axis);
	VectorCopy(normal, le->refEntity.axis[0]);
	RotateAroundDirection(le->refEntity.axis, 0); // le->refEntity.data.sprite.rotation );	This is roll in quad land

	le->refEntity.shaderRGBA[0] = 0xff;
	le->refEntity.shaderRGBA[1] = 0xff;
	le->refEntity.shaderRGBA[2] = 0xff;
	le->refEntity.shaderRGBA[3] = 0xff;

	le->color[0] = 1.0;
	le->color[1] = 1.0;
	le->color[2] = 1.0;
	le->color[3] = 1.0;
	le->lifeRate = 1.0 / (le->endTime - le->startTime);

	return le;
}

static void FX_DrawPortableShield(const centity_t* cent)
{
	//rww - this code differs a bit from the draw code in EF, I don't know why I had to do
	//it this way yet it worked in EF the other way.

	vec3_t start, end, normal;
	qhandle_t shader;

	if (cl_paused.integer)
	{
		//rww - fix to keep from rendering repeatedly while HUD menu is up
		return;
	}

	if (cent->currentState.eFlags & EF_NODRAW)
	{
		return;
	}

	// decode the data stored in time2
	const int xaxis = cent->currentState.time2 >> 24 & 1;
	const int height = cent->currentState.time2 >> 16 & 255;
	const int pos_width = cent->currentState.time2 >> 8 & 255;
	const int neg_width = cent->currentState.time2 & 255;

	const int team = cent->currentState.otherentity_num2;

	VectorClear(normal);

	VectorCopy(cent->lerpOrigin, start);
	VectorCopy(cent->lerpOrigin, end);

	if (xaxis) // drawing along x-axis
	{
		start[0] -= neg_width;
		end[0] += pos_width;
	}
	else
	{
		start[1] -= neg_width;
		end[1] += pos_width;
	}

	normal[0] = 1;
	normal[1] = 1;

	start[2] += height / 2;
	end[2] += height / 2;

	if (team == TEAM_RED)
	{
		if (cent->currentState.trickedentindex)
		{
			shader = trap->R_RegisterShader("gfx/misc/red_dmgshield");
		}
		else
		{
			shader = trap->R_RegisterShader("gfx/misc/red_portashield");
		}
	}
	else
	{
		if (cent->currentState.trickedentindex)
		{
			shader = trap->R_RegisterShader("gfx/misc/blue_dmgshield");
		}
		else
		{
			shader = trap->R_RegisterShader("gfx/misc/blue_portashield");
		}
	}

	FX_AddOrientedLine(start, end, normal, 1.0f, height, 0.0f, 1.0f, 1.0f, 50.0, shader);
}

/*
==================
CG_Special
==================
*/
static void CG_Special(const centity_t* cent)
{
	const entityState_t* s1 = &cent->currentState;

	if (!s1)
	{
		return;
	}

	// if set to invisible, skip
	if (!s1->modelIndex)
	{
		return;
	}

	if (s1->modelIndex == HI_SHIELD)
	{
		// The portable shield should go through a different rendering function.
		if (!cg.snap->ps.duelInProgress ||
			s1->otherentity_num == cg.snap->ps.clientNum ||
			s1->otherentity_num == cg.snap->ps.duelIndex)
		{
			FX_DrawPortableShield(cent);
		}
	}
}

/*
Ghoul2 Insert Start
*/

// Copy the ghoul2 data into the ref ent correctly
void CG_SetGhoul2Info(refEntity_t* ent, const centity_t* cent)
{
	ent->ghoul2 = cent->ghoul2;
	VectorCopy(cent->modelScale, ent->modelScale);
	ent->radius = cent->radius;
	VectorCopy(cent->lerpAngles, ent->angles);
}

// create 8 new points on screen around a model so we can see it's bounding box
void CG_CreateBBRefEnts(entityState_t* s1, vec3_t origin)
{
	//wtf
}

// write in the axis and stuff
static void G2_BoltToGhoul2Model(centity_t* cent, refEntity_t* ent)
{
	// extract the wraith ID from the bolt info
	int model_num = cent->boltInfo >> MODEL_SHIFT;
	int bolt_num = cent->boltInfo >> BOLT_SHIFT;
	int entNum = cent->boltInfo >> ENTITY_SHIFT;
	mdxaBone_t boltMatrix;

	model_num &= MODEL_AND;
	bolt_num &= BOLT_AND;
	entNum &= ENTITY_AND;

	//NOTENOTE I put this here because the cgs.game_models array no longer gets initialized.
	assert(0);

	// go away and get me the bolt position for this frame please
	trap->G2API_GetBoltMatrix(cent->ghoul2, model_num, bolt_num, &boltMatrix, cg_entities[entNum].currentState.angles,
		cg_entities[entNum].currentState.origin, cg.time, cgs.game_models, cent->modelScale);

	// set up the axis and origin we need for the actual effect spawning
	ent->origin[0] = boltMatrix.matrix[0][3];
	ent->origin[1] = boltMatrix.matrix[1][3];
	ent->origin[2] = boltMatrix.matrix[2][3];

	ent->axis[0][0] = boltMatrix.matrix[0][0];
	ent->axis[0][1] = boltMatrix.matrix[1][0];
	ent->axis[0][2] = boltMatrix.matrix[2][0];

	ent->axis[1][0] = boltMatrix.matrix[0][1];
	ent->axis[1][1] = boltMatrix.matrix[1][1];
	ent->axis[1][2] = boltMatrix.matrix[2][1];

	ent->axis[2][0] = boltMatrix.matrix[0][2];
	ent->axis[2][1] = boltMatrix.matrix[1][2];
	ent->axis[2][2] = boltMatrix.matrix[2][2];
}

void ScaleModelAxis(refEntity_t* ent)

{
	// scale the model should we need to
	if (ent->modelScale[0] && ent->modelScale[0] != 1.0f)
	{
		VectorScale(ent->axis[0], ent->modelScale[0], ent->axis[0]);
		ent->nonNormalizedAxes = qtrue;
	}
	if (ent->modelScale[1] && ent->modelScale[1] != 1.0f)
	{
		VectorScale(ent->axis[1], ent->modelScale[1], ent->axis[1]);
		ent->nonNormalizedAxes = qtrue;
	}
	if (ent->modelScale[2] && ent->modelScale[2] != 1.0f)
	{
		VectorScale(ent->axis[2], ent->modelScale[2], ent->axis[2]);
		ent->nonNormalizedAxes = qtrue;
	}
}

/*
Ghoul2 Insert End
*/

char* forceHolocronModels[] = {
	"models/map_objects/mp/lt_heal.md3", //FP_HEAL,
	"models/map_objects/mp/force_jump.md3", //FP_LEVITATION,
	"models/map_objects/mp/force_speed.md3", //FP_SPEED,
	"models/map_objects/mp/force_push.md3", //FP_PUSH,
	"models/map_objects/mp/force_pull.md3", //FP_PULL,
	"models/map_objects/mp/lt_telepathy.md3", //FP_TELEPATHY,
	"models/map_objects/mp/dk_grip.md3", //FP_GRIP,
	"models/map_objects/mp/dk_lightning.md3", //FP_LIGHTNING,
	"models/map_objects/mp/dk_rage.md3", //FP_RAGE,
	"models/map_objects/mp/lt_protect.md3", //FP_PROTECT,
	"models/map_objects/mp/lt_absorb.md3", //FP_ABSORB,
	"models/map_objects/mp/lt_healother.md3", //FP_TEAM_HEAL,
	"models/map_objects/mp/dk_powerother.md3", //FP_TEAM_FORCE,
	"models/map_objects/mp/dk_drain.md3", //FP_DRAIN,
	"models/map_objects/mp/force_sight.md3", //FP_SEE,
	"models/map_objects/mp/saber_attack.md3", //FP_SABER_OFFENSE,
	"models/map_objects/mp/saber_defend.md3", //FP_SABER_DEFENSE,
	"models/map_objects/mp/saber_throw.md3" //FP_SABERTHROW
};

void CG_Disintegration(centity_t* cent, refEntity_t* ent)
{
	vec3_t temp_ang, hit_loc;

	VectorCopy(cent->currentState.origin2, hit_loc);

	VectorSubtract(hit_loc, ent->origin, ent->oldorigin);

	const float temp_length = VectorNormalize(ent->oldorigin);
	vectoangles(ent->oldorigin, temp_ang);
	temp_ang[YAW] -= cent->lerpAngles[YAW];
	AngleVectors(temp_ang, ent->oldorigin, NULL, NULL);
	VectorScale(ent->oldorigin, temp_length, ent->oldorigin);

	ent->endTime = cent->dustTrailTime;

	ent->renderfx |= RF_DISINTEGRATE2;
	ent->customShader = cgs.media.disruptorShader;
	trap->R_AddRefEntityToScene(ent);

	ent->renderfx &= ~RF_DISINTEGRATE2;
	ent->renderfx |= RF_DISINTEGRATE1;
	ent->customShader = 0;
	trap->R_AddRefEntityToScene(ent);

	if (cg.time - ent->endTime < 1000 && timescale.value * timescale.value * Q_flrand(0.0f, 1.0f) > 0.05f)
	{
		vec3_t fx_org, fx_dir;
		mdxaBone_t boltMatrix;
		const int torso_bolt = trap->G2API_AddBolt(cent->ghoul2, 0, "lower_lumbar");

		VectorSet(fx_dir, 0, 1, 0);

		trap->G2API_GetBoltMatrix(cent->ghoul2, 0, torso_bolt, &boltMatrix, cent->lerpAngles, cent->lerpOrigin, cg.time,
			cgs.game_models, cent->modelScale);
		BG_GiveMeVectorFromMatrix(&boltMatrix, ORIGIN, fx_org);

		VectorMA(fx_org, -18, cg.refdef.viewaxis[0], fx_org);
		fx_org[2] += Q_flrand(-1.0f, 1.0f) * 20;
		trap->FX_PlayEffectID(cgs.effects.mDisruptorDeathSmoke, fx_org, fx_dir, -1, -1, qfalse);

		if (Q_flrand(0.0f, 1.0f) > 0.5f)
		{
			trap->FX_PlayEffectID(cgs.effects.mDisruptorDeathSmoke, fx_org, fx_dir, -1, -1, qfalse);
		}
	}
}

extern int cgSiegeEntityRender;

static qboolean CG_RenderTimeEntBolt(centity_t* cent)
{
	const int clientNum = cent->currentState.boltToPlayer - 1;
	mdxaBone_t matrix;
	vec3_t bolt_org, bolt_ang;

	if (clientNum >= MAX_CLIENTS || clientNum < 0)
	{
		assert(0);
		return qfalse;
	}

	centity_t* cl = &cg_entities[clientNum];

	if (!cl->ghoul2)
	{
		assert(0);
		return qfalse;
	}

	if (clientNum == cg.predictedPlayerState.clientNum &&
		!cg.renderingThirdPerson)
	{
		//If in first person and you have it then render the thing spinning around on your hud.
		cgSiegeEntityRender = cent->currentState.number; //set it to render at the end of the frame.
		return qfalse;
	}

	const int get_bolt = trap->G2API_AddBolt(cl->ghoul2, 0, "lhand");

	trap->G2API_GetBoltMatrix(cl->ghoul2, 0, get_bolt, &matrix, cl->turAngles, cl->lerpOrigin, cg.time, cgs.game_models,
		cl->modelScale);

	BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, bolt_org);
	BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, bolt_ang);
	vectoangles(bolt_ang, bolt_ang);
	bolt_ang[PITCH] = bolt_ang[ROLL] = 0;

	VectorCopy(bolt_org, cent->lerpOrigin);
	VectorCopy(bolt_ang, cent->lerpAngles);

	return qtrue;
}

/*
static void CG_SiegeEntRenderAboveHead(centity_t *cent)
{
	int clientNum = cent->currentState.boltToPlayer-1;
	centity_t *cl;
	refEntity_t ent;
	vec3_t renderAngles;

	if (clientNum >= MAX_CLIENTS || clientNum < 0)
	{
		assert(0);
		return;
	}

	cl = &cg_entities[clientNum];

	memset(&ent, 0, sizeof(ent));

	//Set the angles to the global auto rotating ones, and the origin to slightly above the client
	VectorCopy(cg.autoAngles, renderAngles);
	AnglesToAxis( renderAngles, ent.axis );
	VectorCopy(cl->lerpOrigin, ent.origin);
	ent.origin[2] += 50;

	//Set the model (ghoul2 or md3/other)
	if (cent->ghoul2)
	{
		ent.ghoul2 = cent->ghoul2;
		ent.hModel = 0;
	}
	else
	{
		ent.ghoul2 = NULL;
		ent.hModel = cgs.game_models[cent->currentState.modelIndex];
	}

	//Scale it up
	ent.modelScale[0] = 1.5f;
	ent.modelScale[1] = 1.5f;
	ent.modelScale[2] = 1.5f;
	ScaleModelAxis(&ent);

	//Make it transparent
	ent.renderfx = RF_FORCE_ENT_ALPHA;
	ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = 255;
	ent.shaderRGBA[3] = 100;

	//And finally add it
	trap->R_AddRefEntityToScene(&ent);
}
*/

void CG_AddRadarEnt(const centity_t* cent)
{
	static const size_t num_radar_ents = ARRAY_LEN(cg.radarEntities);
	if (cg.radarEntityCount >= num_radar_ents)
	{
#ifdef _DEBUG
		Com_Printf("^3Warning: CG_AddRadarEnt full. (%d max)\n", num_radar_ents);
#endif
		return;
	}
	cg.radarEntities[cg.radarEntityCount++] = cent->currentState.number;
}

void CG_AddBracketedEnt(const centity_t* cent)
{
	static const size_t num_bracket_ents = ARRAY_LEN(cg.bracketedEntities);
	if (cg.bracketedEntityCount >= num_bracket_ents)
	{
#ifdef _DEBUG
		Com_Printf("^3Warning: CG_AddBracketedEnt full. (%d max)\n", num_bracket_ents);
#endif
		return;
	}
	cg.bracketedEntities[cg.bracketedEntityCount++] = cent->currentState.number;
}

/*
==================
CG_General
==================
*/
void CG_G2ServerBoneAngles(const centity_t* cent);
extern void CG_BodyQueueCopy(centity_t* cent, int clientNum, int knownWeapon);
extern qboolean BG_GetRootSurfNameWithVariant(void* ghoul2, const char* rootSurfName, char* returnSurfName,
	int returnSize);

static void CG_General(centity_t* cent)
{
	refEntity_t ent;
	entityState_t* s1;
	mdxaBone_t matrix;
	qboolean do_not_set_model = qfalse;

	if (cent->currentState.modelGhoul2 == 127)
	{
		//not ready to be drawn or initialized..
		return;
	}

	if (cent->ghoul2 && !cent->currentState.modelGhoul2 && cent->currentState.eType != ET_BODY &&
		cent->currentState.number >= MAX_CLIENTS)
	{
		//this is a bad thing
		if (trap->G2_HaveWeGhoul2Models(cent->ghoul2))
		{
			trap->G2API_CleanGhoul2Models(&cent->ghoul2);
		}
	}

	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}
	if (cent->currentState.eFlags2 & EF2_BRACKET_ENTITY)
	{
		if (CG_InFighter())
		{
			//only bracken when in a fighter
			CG_AddBracketedEnt(cent);
		}
	}

	if (cent->currentState.weapon == WP_STUN_BATON)
	{
		int i;
		orientation_t lerped;

		vec3_t start;
		vec3_t end;
		vec3_t r_hand_pos;

		centity_t* parent;
		mdxaBone_t mat;
		int color;
		color = 0x000020;

		// lerp the tag
		trap->R_LerpTag(&lerped, cg_weapons[WP_STUN_BATON].missileModel, 0, 0, 1.0, "tag_extrem");

		VectorCopy(cent->lerpOrigin, end);
		for (i = 0; i < 3; i++)
		{
			VectorMA(end, lerped.origin[i], cent->currentState.angles, end);
		}

		parent = &cg_entities[cent->currentState.otherentity_num];
		trap->G2API_GetBoltMatrix(parent->ghoul2, 0, 0, &mat, parent->turAngles, parent->lerpOrigin, cg.time,
			cgs.game_models, parent->modelScale);

		r_hand_pos[0] = mat.matrix[0][3];
		r_hand_pos[1] = mat.matrix[1][3];
		r_hand_pos[2] = mat.matrix[2][3];

		BG_GiveMeVectorFromMatrix(&mat, ORIGIN, start);
		CG_StunStartpoint(end);
		//GOING OUT
	}

	if (cent->currentState.weapon == WP_MELEE)
	{
		int i;
		orientation_t lerped;

		vec3_t start;
		vec3_t end;

		centity_t* parent;
		mdxaBone_t mat;
		int color;
		color = 0x000020;

		// lerp the tag grapple
		trap->R_LerpTag(&lerped, cg_weapons[WP_MELEE].missileModel, 0, 0, 1.0, "tag_extrem");

		VectorCopy(cent->lerpOrigin, end);
		for (i = 0; i < 3; i++)
		{
			VectorMA(end, lerped.origin[i], cent->currentState.angles, end);
		}

		parent = &cg_entities[cent->currentState.otherentity_num];
		trap->G2API_GetBoltMatrix(parent->ghoul2, 0, 0, &mat, parent->turAngles, parent->lerpOrigin, cg.time,
			cgs.game_models, parent->modelScale);
		BG_GiveMeVectorFromMatrix(&mat, ORIGIN, start);

		vec3_t v4DKGREY2 = { 0.15f, 0.15f, 0.15f };

		trap->FX_AddLine(start, end, 0.1f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, v4DKGREY2, v4DKGREY2, 0.0f, 300, trap->R_RegisterShader("gfx/misc/nav_line"), FX_SIZE_LINEAR);

		CG_GrappleStartpoint(end);
		//GOING OUT
	}

	if (cg.snap->ps.duelInProgress &&
		((cent->currentState.weapon == WP_SABER &&
			cent->currentState.otherentity_num != cg.snap->ps.clientNum &&
			cent->currentState.otherentity_num != cg.snap->ps.duelIndex) ||
			cent->currentState.eType & ET_BODY ||
			cent->currentState.weapon == G2_MODEL_PART))
	{ // don't render flying sabers owned by others, bodies or body parts
		return;
	}

	if (cent->currentState.boltToPlayer)
	{
		//Shove it into the player's left hand then.
		centity_t* pl = &cg_entities[cent->currentState.boltToPlayer - 1];
		if (CG_IsMindTricked(pl->currentState.trickedentindex,
			pl->currentState.trickedentindex2,
			pl->currentState.trickedentindex3,
			pl->currentState.trickedentindex4,
			cg.predictedPlayerState.clientNum))
		{
			//don't show if this guy is mindtricking
			return;
		}
		if (!CG_RenderTimeEntBolt(cent))
		{
			//If this function returns qfalse we shouldn't render this ent at all.
			if (cent->currentState.boltToPlayer > 0 &&
				cent->currentState.boltToPlayer <= MAX_CLIENTS)
			{
				VectorCopy(pl->lerpOrigin, cent->lerpOrigin);

				if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
				{
					//if it's set to smooth keep the smoothed lerp origin updated, as we don't want to smooth while bolted.
					VectorCopy(cent->lerpOrigin, cent->turAngles);
				}
			}
			return;
		}

		if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
		{
			//if it's set to smooth keep the smoothed lerp origin updated, as we don't want to smooth while bolted.
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}
	}
	else if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
	{
		if (cent->currentState.groundEntityNum >= ENTITYNUM_WORLD)
		{
			float smooth_factor = 0.5f * timescale.value;
			int k = 0;
			vec3_t pos_dif;

			//Use origin smoothing since dismembered limbs use ExPhys
			if (DistanceSquared(cent->turAngles, cent->lerpOrigin) > 18000.0f)
			{
				VectorCopy(cent->lerpOrigin, cent->turAngles);
			}

			VectorSubtract(cent->lerpOrigin, cent->turAngles, pos_dif);

			for (k = 0; k < 3; k++)
			{
				cent->turAngles[k] = cent->turAngles[k] + pos_dif[k] * smooth_factor;
				cent->lerpOrigin[k] = cent->turAngles[k];
			}
		}
		else
		{
			//if we're sitting on an entity like a moving plat then we don't want to smooth either
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}
	}

	//rww - now do ragdoll stuff
	if (cent->ghoul2 &&
		(cent->currentState.eType == ET_BODY || cent->currentState.eFlags & EF_RAG))
	{
		if (!(cent->currentState.eFlags & EF_NODRAW) &&
			!(cent->currentState.eFlags & EF_DISINTEGRATION) &&
			cent->bodyFadeTime <= cg.time)
		{
			vec3_t forced_angles;

			VectorClear(forced_angles);
			forced_angles[YAW] = cent->lerpAngles[YAW];

			CG_RagDoll(cent, forced_angles);
		}
	}
	else if (cent->isRagging)
	{
		cent->isRagging = qfalse;

		if (cent->ghoul2 && trap->G2_HaveWeGhoul2Models(cent->ghoul2))
		{
			//May not be valid, in the case of a ragged entity being removed and a non-g2 ent filling its slot.
			trap->G2API_SetRagDoll(cent->ghoul2, NULL); //calling with null parms resets to no ragdoll.
		}
	}

	if (cent->currentState.boneOrient && cent->ghoul2)
	{
		//server sent us some bone angles to use
		CG_G2ServerBoneAngles(cent);
	}

	if (cent->currentState.eFlags & EF_G2ANIMATING && cent->ghoul2)
	{
		//mini-animation routine for general objects that want to play quick ghoul2 anims
		//obviously lacks much of the functionality contained in player/npc animation.
		//we actually use torsoAnim as the start frame and legsAnim as the end frame and
		//always play the anim on the root bone.
		if (cent->currentState.torsoAnim != cent->pe.torso.animationNumber ||
			cent->currentState.legsAnim != cent->pe.legs.animationNumber ||
			cent->currentState.torsoFlip != cent->pe.torso.lastFlip)
		{
			trap->G2API_SetBoneAnim(cent->ghoul2, 0, "model_root", cent->currentState.torsoAnim,
				cent->currentState.legsAnim, BONE_ANIM_OVERRIDE_FREEZE | BONE_ANIM_BLEND, 1.0f,
				cg.time, -1, 100);

			cent->pe.torso.animationNumber = cent->currentState.torsoAnim;
			cent->pe.legs.animationNumber = cent->currentState.legsAnim;
			cent->pe.torso.lastFlip = cent->currentState.torsoFlip;
		}
	}

	memset(&ent, 0, sizeof ent);

	ent.shaderRGBA[0] = cent->currentState.customRGBA[0];
	ent.shaderRGBA[1] = cent->currentState.customRGBA[1];
	ent.shaderRGBA[2] = cent->currentState.customRGBA[2];
	ent.shaderRGBA[3] = cent->currentState.customRGBA[3];

	if (cent->currentState.modelGhoul2 >= G2_MODELPART_HEAD &&
		cent->currentState.modelGhoul2 <= G2_MODELPART_RLEG &&
		/*cent->currentState.modelIndex < MAX_CLIENTS &&*/
		cent->currentState.weapon == G2_MODEL_PART)
	{
		//special case for client limbs
		centity_t* cl_ent;
		int dismember_settings = cg_dismember.integer;
		float smooth_factor = 0.5f * timescale.value;
		int k = 0;
		vec3_t pos_dif;

		do_not_set_model = qtrue;

		if (cent->currentState.modelIndex >= 0)
		{
			cl_ent = &cg_entities[cent->currentState.modelIndex];
		}
		else
		{
			cl_ent = &cg_entities[cent->currentState.otherentity_num2];
		}

		if (!dismember_settings)
		{
			//This client does not wish to see dismemberment.
			return;
		}

		if (dismember_settings < 2 && (cent->currentState.modelGhoul2 == G2_MODELPART_HEAD || cent->currentState.
			modelGhoul2 == G2_MODELPART_WAIST))
		{
			//dismember settings are not high enough to display decaps and torso slashes
			return;
		}

		if (!cent->ghoul2)
		{
			const char* rotate_bone;
			char limb_name[MAX_QPATH];
			char stub_name[MAX_QPATH];
			char limb_cap_name[MAX_QPATH];
			char stub_cap_name[MAX_QPATH];
			char* limb_tag_name;
			char* stub_tag_name;
			int new_bolt;
			int limb_bit = (1 << (cent->currentState.modelGhoul2 - 10));

			if (cl_ent && cl_ent->torsoBolt & limb_bit)
			{
				//already have this limb missing!
				return;
			}

			if (cl_ent && !(cl_ent->currentState.eFlags & EF_DEAD))
			{
				//death flag hasn't made it through yet for the limb owner, we cannot create the limb until he's flagged as dead
				return;
			}

			if (cl_ent && (!BG_InDeathAnim(cl_ent->currentState.torsoAnim) || !BG_InDeathAnim(
				cl_ent->pe.torso.animationNumber)))
			{
				//don't make it unless we're in an actual death anim already
				if (cl_ent->currentState.torsoAnim != BOTH_RIGHTHANDCHOPPEDOFF)
				{
					//exception
					return;
				}
			}

			cent->bolt4 = -1;
			cent->trailTime = 0;

			if (cent->currentState.modelGhoul2 == G2_MODELPART_HEAD)
			{
				rotate_bone = "cranium";
				Q_strncpyz(limb_name, "head", sizeof limb_name);
				Q_strncpyz(limb_cap_name, "head_cap_torso", sizeof limb_cap_name);
				Q_strncpyz(stub_cap_name, "torso_cap_head", sizeof stub_cap_name);
				limb_tag_name = "*head_cap_torso";
				stub_tag_name = "*torso_cap_head";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_WAIST)
			{
				if (cl_ent->localAnimIndex <= 1)
				{
					//humanoid/rtrooper
					rotate_bone = "thoracic";
				}
				else
				{
					rotate_bone = "pelvis";
				}
				Q_strncpyz(limb_name, "torso", sizeof limb_name);
				Q_strncpyz(limb_cap_name, "torso_cap_hips", sizeof limb_cap_name);
				Q_strncpyz(stub_cap_name, "hips_cap_torso", sizeof stub_cap_name);
				limb_tag_name = "*torso_cap_hips";
				stub_tag_name = "*hips_cap_torso";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_LARM)
			{
				rotate_bone = "lradius";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "l_arm", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "torso", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_torso", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_l_arm", stub_name);
				limb_tag_name = "*l_arm_cap_torso";
				stub_tag_name = "*torso_cap_l_arm";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RARM)
			{
				rotate_bone = "rradius";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "r_arm", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "torso", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_torso", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_r_arm", stub_name);
				limb_tag_name = "*r_arm_cap_torso";
				stub_tag_name = "*torso_cap_r_arm";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RHAND)
			{
				rotate_bone = "rhand";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "r_hand", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "r_arm", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_r_arm", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_r_hand", stub_name);
				limb_tag_name = "*r_hand_cap_r_arm";
				stub_tag_name = "*r_arm_cap_r_hand";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_LLEG)
			{
				rotate_bone = "ltibia";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "l_leg", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "hips", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_hips", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_l_leg", stub_name);
				limb_tag_name = "*l_leg_cap_hips";
				stub_tag_name = "*hips_cap_l_leg";
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RLEG)
			{
				rotate_bone = "rtibia";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "r_leg", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "hips", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_hips", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_r_leg", stub_name);
				limb_tag_name = "*r_leg_cap_hips";
				stub_tag_name = "*hips_cap_r_leg";
			}
			else
			{
				//umm... just default to the right leg, I guess (same as on server)
				rotate_bone = "rtibia";
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "r_leg", limb_name, sizeof limb_name);
				BG_GetRootSurfNameWithVariant(cl_ent->ghoul2, "hips", stub_name, sizeof stub_name);
				Com_sprintf(limb_cap_name, sizeof limb_cap_name, "%s_cap_hips", limb_name);
				Com_sprintf(stub_cap_name, sizeof stub_cap_name, "%s_cap_r_leg", stub_name);
				limb_tag_name = "*r_leg_cap_hips";
				stub_tag_name = "*hips_cap_r_leg";
			}

			if (cl_ent && cl_ent->ghoul2)
			{
				if (trap->G2API_HasGhoul2ModelOnIndex(&cl_ent->ghoul2, 2))
				{
					//don't want to bother dealing with a second saber on limbs and stuff, just remove the thing
					trap->G2API_RemoveGhoul2Model(&cl_ent->ghoul2, 2);
				}

				if (trap->G2API_HasGhoul2ModelOnIndex(&cl_ent->ghoul2, 3))
				{
					//turn off jetpack also I suppose
					trap->G2API_RemoveGhoul2Model(&cl_ent->ghoul2, 3);
				}

				if (cl_ent->localAnimIndex <= 0)
				{
					//humanoid
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "model_root", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
						NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 0, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 0, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "cranium", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_Z, NEGATIVE_Y, POSITIVE_X, cgs.game_models, 100, cg.time);
				}
				else
				{
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "model_root", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
						NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 0, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
					trap->G2API_SetBoneAngles(cl_ent->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT,
						POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
				}

				trap->G2API_DuplicateGhoul2Instance(cl_ent->ghoul2, &cent->ghoul2);
			}

			if (!cent->ghoul2)
			{
				return;
			}

			new_bolt = trap->G2API_AddBolt(cent->ghoul2, 0, limb_tag_name);
			if (new_bolt != -1)
			{
				vec3_t bolt_org, bolt_ang;

				trap->G2API_GetBoltMatrix(cent->ghoul2, 0, new_bolt, &matrix, cent->lerpAngles, cent->lerpOrigin,
					cg.time, cgs.game_models, cent->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, bolt_org);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, bolt_ang);

				trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, bolt_org, bolt_ang, -1, -1, qfalse);
			}

			cent->bolt4 = new_bolt;

			trap->G2API_SetRootSurface(cent->ghoul2, 0, limb_name);

			trap->G2API_SetNewOrigin(cent->ghoul2, trap->G2API_AddBolt(cent->ghoul2, 0, rotate_bone));

			trap->G2API_SetSurfaceOnOff(cent->ghoul2, limb_cap_name, 0);

			trap->G2API_SetSurfaceOnOff(cl_ent->ghoul2, limb_name, 0x00000100);
			trap->G2API_SetSurfaceOnOff(cl_ent->ghoul2, stub_cap_name, 0);

			new_bolt = trap->G2API_AddBolt(cl_ent->ghoul2, 0, stub_tag_name);
			if (new_bolt != -1)
			{
				vec3_t bolt_org, bolt_ang;

				trap->G2API_GetBoltMatrix(cl_ent->ghoul2, 0, new_bolt, &matrix, cl_ent->lerpAngles, cl_ent->lerpOrigin,
					cg.time, cgs.game_models, cl_ent->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, bolt_org);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, bolt_ang);

				trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, bolt_org, bolt_ang, -1, -1, qfalse);
			}

			if (cent->currentState.modelGhoul2 == G2_MODELPART_RARM || cent->currentState.modelGhoul2 ==
				G2_MODELPART_RHAND || cent->currentState.modelGhoul2 == G2_MODELPART_WAIST)
			{
				//Cut his weapon holding arm off, so remove the weapon
				if (trap->G2API_HasGhoul2ModelOnIndex(&cl_ent->ghoul2, 1))
				{
					trap->G2API_RemoveGhoul2Model(&cl_ent->ghoul2, 1);
				}
			}

			cl_ent->torsoBolt |= limb_bit;

			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}

		//Use origin smoothing since dismembered limbs use ExPhys
		if (DistanceSquared(cent->turAngles, cent->lerpOrigin) > 18000.0f)
		{
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}

		VectorSubtract(cent->lerpOrigin, cent->turAngles, pos_dif);

		for (k = 0; k < 3; k++)
		{
			cent->turAngles[k] = cent->turAngles[k] + pos_dif[k] * smooth_factor;
			cent->lerpOrigin[k] = cent->turAngles[k];
		}

		if (cent->ghoul2 && cent->bolt4 != -1 && cent->trailTime < cg.time)
		{
			if (cent->bolt4 != -1 &&
				(cent->currentState.pos.trDelta[0] || cent->currentState.pos.trDelta[1] || cent->currentState.pos.
					trDelta[2]))
			{
				vec3_t bolt_org, bolt_ang;

				trap->G2API_GetBoltMatrix(cent->ghoul2, 0, cent->bolt4, &matrix, cent->lerpAngles, cent->lerpOrigin,
					cg.time, cgs.game_models, cent->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, bolt_org);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, bolt_ang);

				if (!bolt_ang[0] && !bolt_ang[1] && !bolt_ang[2])
				{
					bolt_ang[1] = 1;
				}
				trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, bolt_org, bolt_ang, -1, -1, qfalse);

				cent->trailTime = cg.time + 400;
			}
		}

		ent.radius = cent->currentState.g2radius;
		ent.hModel = 0;
	}

	if (cent->currentState.number >= MAX_CLIENTS &&
		cent->currentState.activeForcePass == NUM_FORCE_POWERS + 1 &&
		cent->currentState.NPC_class != CLASS_VEHICLE)
	{
		vec3_t emp_angles;
		centity_t* emp_own;

		emp_own = &cg_entities[cent->currentState.emplacedOwner];

		if (cg.snap->ps.clientNum == emp_own->currentState.number &&
			!cg.renderingThirdPerson)
		{
			VectorCopy(cg.refdef.viewangles, emp_angles);
		}
		else
		{
			VectorCopy(emp_own->lerpAngles, emp_angles);
		}

		if (emp_angles[PITCH] > 40)
		{
			emp_angles[PITCH] = 40;
		}
		emp_angles[YAW] -= cent->currentState.angles[YAW];

		trap->G2API_SetBoneAngles(cent->ghoul2, 0, "Bone02", emp_angles, BONE_ANGLES_REPLACE, NEGATIVE_Y, NEGATIVE_X,
			POSITIVE_Z, NULL, 0, cg.time);
	}

	s1 = &cent->currentState;

	// if set to invisible, skip
	if (!s1->modelIndex && !trap->G2_HaveWeGhoul2Models(cent->ghoul2))
	{
		return;
	}

	if (s1->eFlags & EF_NODRAW)
	{
		return;
	}

	// set frame
	if (s1->eFlags & EF_SHADER_ANIM)
	{
		// Deliberately setting it up so that shader anim will completely override any kind of model animation frame setting.
		ent.renderfx |= RF_SETANIMINDEX;
		ent.skinNum = s1->frame;
	}
	else if (s1->eFlags & EF_ANIM_ONCE)
	{
		ent.frame = s1->frame;
		ent.renderfx |= RF_CAP_FRAMES;
	}
	else if (s1->eFlags & EF_ANIM_ALLFAST)
	{
		ent.frame = cg.time / 100;
		ent.renderfx |= RF_WRAP_FRAMES;
	}
	else
	{
		ent.frame = s1->frame;
	}
	ent.oldframe = ent.frame;
	ent.backlerp = 0;

	/*
	Ghoul2 Insert Start
	*/
	CG_SetGhoul2Info(&ent, cent);

	/*
	Ghoul2 Insert End
	*/
	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(cent->lerpOrigin, ent.oldorigin);

	if (cent->currentState.modelGhoul2)
	{
		//If the game says this guy uses a ghoul2 model and the g2 instance handle is null, then initialize it
		if (!cent->ghoul2 && !cent->currentState.bolt1)
		{
			const char* model_name = CG_ConfigString(CS_MODELS + cent->currentState.modelIndex);

			trap->G2API_InitGhoul2Model(&cent->ghoul2, model_name, 0, 0, 0, 0, 0);
			if (cent->ghoul2 && trap->G2API_SkinlessModel(cent->ghoul2, 0))
			{
				int skin = 0;
				int l;
				char skin_name[MAX_QPATH];
				//well, you'd never want a skinless model, so try to get his skin...
				Q_strncpyz(skin_name, model_name, MAX_QPATH);
				l = strlen(skin_name);
				while (l > 0 && skin_name[l] != '/')
				{
					//parse back to first /
					l--;
				}
				if (skin_name[l] == '/')
				{
					//got it
					l++;
					skin_name[l] = 0;
					Q_strcat(skin_name, MAX_QPATH, "model_default.skin");

					skin = trap->R_RegisterSkin(skin_name);
				}
				trap->G2API_SetSkin(cent->ghoul2, 0, skin, skin);
			}
		}
		else if (cent->currentState.bolt1)
		{
			TurretClientRun(cent);
		}

		if (cent->ghoul2)
		{
			//give us a proper radius
			ent.radius = cent->currentState.g2radius;
		}
	}

	if (s1->eType == ET_BODY)
	{
		//bodies should have a radius as well
		ent.radius = cent->currentState.g2radius;

		if (cent->ghoul2)
		{
			//all bodies should already have a ghoul2 instance. Use it to set the torso/head angles to 0.
			cent->lerpAngles[PITCH] = 0;
			cent->lerpAngles[ROLL] = 0;
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
				NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 0, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
				NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 0, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
				NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X,
				NEGATIVE_Y, NEGATIVE_Z, cgs.game_models, 100, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "cranium", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_Z,
				NEGATIVE_Y, POSITIVE_X, cgs.game_models, 100, cg.time);
		}
	}

	if (s1->eType == ET_HOLOCRON && s1->modelIndex < -100)
	{
		//special render, it's a holocron
		//Using actual models now:
		ent.hModel = trap->R_RegisterModel(forceHolocronModels[s1->modelIndex + 128]);

		//Rotate them
		VectorCopy(cg.autoAngles, cent->lerpAngles);
		AxisCopy(cg.autoAxis, ent.axis);
	}
	else if (!do_not_set_model)
	{
		ent.hModel = cgs.game_models[s1->modelIndex];
	}

	// player model
	if (s1->number == cg.snap->ps.clientNum)
	{
		ent.renderfx |= RF_THIRD_PERSON; // only draw from mirrors
	}

	// convert angles to axis
	AnglesToAxis(cent->lerpAngles, ent.axis);

	if (cent->currentState.iModelScale)
	{
		//if the server says we have a custom scale then set it now.
		cent->modelScale[0] = cent->modelScale[1] = cent->modelScale[2] = cent->currentState.iModelScale / 100.0f;
		VectorCopy(cent->modelScale, ent.modelScale);
		ScaleModelAxis(&ent);
	}
	else
	{
		VectorClear(cent->modelScale);
	}

	if (cent->currentState.time > cg.time && cent->currentState.weapon == WP_EMPLACED_GUN)
	{
		float val;
		// make the gun pulse red to warn about it exploding
		val = (1.0f - (float)(cent->currentState.time - cg.time) / 3200.0f) * 0.3f;

		ent.customShader = trap->R_RegisterShader("gfx/effects/turretflashdie");
		ent.shaderRGBA[0] = (sin(cg.time * 0.04f) * val * 0.4f + val) * 255;
		ent.shaderRGBA[1] = ent.shaderRGBA[2] = 0;

		ent.shaderRGBA[3] = 100;
		trap->R_AddRefEntityToScene(&ent);
		ent.customShader = 0;
	}
	else if (cent->currentState.time == -1 && cent->currentState.weapon == WP_EMPLACED_GUN)
	{
		ent.customShader = trap->R_RegisterShader("models/map_objects/imp_mine/turret_chair_dmg.tga");
		//trap->R_AddRefEntityToScene( &ent );
	}

	if (cent->currentState.eFlags & EF_DISINTEGRATION && cent->currentState.eType == ET_BODY)
	{
		if (!cent->dustTrailTime)
		{
			cent->dustTrailTime = cg.time;
		}

		CG_Disintegration(cent, &ent);
		return;
	}
	if (cent->currentState.eType == ET_BODY)
	{
		if (cent->bodyFadeTime > cg.time)
		{
			qboolean light_side = cent->teamPowerType != 0 ? qtrue : qfalse;
			vec3_t hit_loc, temp_ang;
			float temp_length;
			int cur_time_dif = cg.time + 60000 - cent->bodyFadeTime;
			int t_mult = cur_time_dif * 0.08;

			ent.renderfx |= RF_FORCE_ENT_ALPHA;

			if (cur_time_dif * 0.1 > 254)
			{
				ent.shaderRGBA[3] = 0;
			}
			else
			{
				ent.shaderRGBA[3] = 254 - t_mult;
			}

			if (ent.shaderRGBA[3] >= 1)
			{
				//add the transparent body section
				trap->R_AddRefEntityToScene(&ent);
			}

			ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
			ent.renderfx |= RF_RGB_TINT;

			if (t_mult > 200)
			{
				//begin the disintegration effect
				ent.shaderRGBA[3] = 200;
				if (!cent->dustTrailTime)
				{
					cent->dustTrailTime = cg.time;
					/*if (light_side)
					{
						trap->S_StartSound(NULL, cent->currentState.number, CHAN_AUTO,trap->S_RegisterSound("sound/weapons/force/see.wav"));
					}
					else
					{
						trap->S_StartSound(NULL, cent->currentState.number, CHAN_AUTO,trap->S_RegisterSound("sound/weapons/force/lightning.mp3"));
					}*/
				}
				ent.endTime = cent->dustTrailTime;
				ent.renderfx |= RF_DISINTEGRATE2;
			}
			else
			{
				//set the alpha on the to-be-disintegrated layer
				ent.shaderRGBA[3] = t_mult;
				if (ent.shaderRGBA[3] < 1)
				{
					ent.shaderRGBA[3] = 1;
				}
			}
			//Set everything up on the disint ref
			ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = ent.shaderRGBA[3];
			VectorCopy(cent->lerpOrigin, hit_loc);

			VectorSubtract(hit_loc, ent.origin, ent.oldorigin);

			temp_length = VectorNormalize(ent.oldorigin);
			vectoangles(ent.oldorigin, temp_ang);
			temp_ang[YAW] -= cent->lerpAngles[YAW];
			AngleVectors(temp_ang, ent.oldorigin, NULL, NULL);
			VectorScale(ent.oldorigin, temp_length, ent.oldorigin);

			if (light_side)
			{
				//might be temporary, dunno.
				ent.customShader = cgs.media.playerShieldDamage;
			}
			else
			{
				ent.customShader = cgs.media.redSaberGlowShader;
			}

			trap->R_AddRefEntityToScene(&ent);
			ent.renderfx &= ~RF_DISINTEGRATE2;
			ent.customShader = 0;

			if (cur_time_dif < 2400)
			{
				if (light_side)
				{
					if (cur_time_dif < 1200)
					{
						if (Q_flrand(0.0f, 1.0f) > 0.9f)
						{
							trap->S_StartSound(NULL, cent->currentState.number, CHAN_AUTO, cgs.media.crackleSound);
						}
					}
				}
				else
				{
					//probably temporary as well
					ent.renderfx |= RF_RGB_TINT;
					ent.shaderRGBA[0] = 255;
					ent.shaderRGBA[1] = ent.shaderRGBA[2] = 0;
					ent.shaderRGBA[3] = 255;
					if (rand() & 1)
					{
						ent.customShader = cgs.media.electricBodyShader;
					}
					else
					{
						ent.customShader = cgs.media.electricBody2Shader;
					}
					if (Q_flrand(0.0f, 1.0f) > 0.9f)
					{
						trap->S_StartSound(NULL, cent->currentState.number, CHAN_AUTO, cgs.media.crackleSound);
					}
					trap->R_AddRefEntityToScene(&ent);
				}
			}

			return;
		}
		if (cent->bodyFadeTime)
		{
			//ok, the body fade effect is over.remove the ghoul2 model to prevent the sanity check from grabbing it later.
			if (trap->G2_HaveWeGhoul2Models(cent->ghoul2))
			{
				trap->G2API_CleanGhoul2Models(&cent->ghoul2);
			}
		}
		else
		{
			cent->dustTrailTime = 0;
		}
	}

	if (cent->currentState.modelGhoul2 &&
		!ent.ghoul2 &&
		!ent.hModel)
	{
		return;
	}

	// add to refresh list

	// test for duel noX conditions
	if (cent->currentState.weapon == WP_TRIP_MINE ||
		cent->currentState.weapon == WP_DET_PACK ||
		cent->currentState.bolt1)  // lmo using same bolt1 hack to recognise sentry! (see above and SP_PAS in g_items.c)
	{ // if entity is a trip mine, detpack, sentry gun consider duel NoX
		if (!cg.snap->ps.duelInProgress ||
			cent->currentState.otherentity_num == cg.snap->ps.clientNum ||
			cent->currentState.otherentity_num == cg.snap->ps.duelIndex)
		{
			trap->R_AddRefEntityToScene(&ent);
		}
	}
	else
	{ // not special case
		trap->R_AddRefEntityToScene(&ent);
	}

	if (cent->bolt3 == 999)
	{
		//this is an in-flight saber being rendered manually
		float wv;
		addspriteArgStruct_t fx_s_args;

		ent.customShader = cgs.media.solidWhite;
		ent.renderfx = RF_RGB_TINT;
		wv = sin(cg.time * 0.003f) * 0.08f + 0.1f;
		ent.shaderRGBA[0] = wv * 255;
		ent.shaderRGBA[1] = wv * 255;
		ent.shaderRGBA[2] = wv * 0;
		trap->R_AddRefEntityToScene(&ent);

		for (int i = -4; i < 10; i += 1)
		{
			vec3_t org;
			VectorMA(ent.origin, -i, ent.axis[2], org);

			VectorCopy(org, fx_s_args.origin);
			VectorClear(fx_s_args.vel);
			VectorClear(fx_s_args.accel);
			fx_s_args.scale = 5.5f;
			fx_s_args.dscale = 5.5f;
			fx_s_args.sAlpha = wv;
			fx_s_args.eAlpha = wv;
			fx_s_args.rotation = 0.0f;
			fx_s_args.bounce = 0.0f;
			fx_s_args.life = 1.0f;
			fx_s_args.shader = cgs.media.yellowDroppedSaberShader;
			fx_s_args.flags = 0x08000000;

			trap->FX_AddSprite(&fx_s_args);
		}
	}
	else if (cent->currentState.trickedentindex3)
	{
		//holocron special effects
		vec3_t org;
		float wv;
		addspriteArgStruct_t fx_s_args;

		ent.customShader = cgs.media.solidWhite;
		ent.renderfx = RF_RGB_TINT;
		wv = sin(cg.time * 0.005f) * 0.08f + 0.1f; //* 0.08f + 0.1f;

		if (cent->currentState.trickedentindex3 == 1)
		{
			//dark
			ent.shaderRGBA[0] = wv * 255;
			ent.shaderRGBA[1] = 0;
			ent.shaderRGBA[2] = 0;
		}
		else if (cent->currentState.trickedentindex3 == 2)
		{
			//light
			ent.shaderRGBA[0] = wv * 255;
			ent.shaderRGBA[1] = wv * 255;
			ent.shaderRGBA[2] = wv * 255;
		}
		else
		{
			//neutral
			if (s1->modelIndex + 128 == FP_SABER_OFFENSE ||
				s1->modelIndex + 128 == FP_SABER_DEFENSE ||
				s1->modelIndex + 128 == FP_SABERTHROW)
			{
				//saber power
				ent.shaderRGBA[0] = 0;
				ent.shaderRGBA[1] = wv * 255;
				ent.shaderRGBA[2] = 0;
			}
			else
			{
				ent.shaderRGBA[0] = 0;
				ent.shaderRGBA[1] = wv * 255;
				ent.shaderRGBA[2] = wv * 255;
			}
		}

		ent.modelScale[0] = 1.1f;
		ent.modelScale[1] = 1.1f;
		ent.modelScale[2] = 1.1f;

		ent.origin[2] -= 2;
		ScaleModelAxis(&ent);

		trap->R_AddRefEntityToScene(&ent);

		VectorMA(ent.origin, 1, ent.axis[2], org);

		org[2] += 18;

		wv = sin(cg.time * 0.002f) * 0.08f + 0.1f; //* 0.08f + 0.1f;

		VectorCopy(org, fx_s_args.origin);
		VectorClear(fx_s_args.vel);
		VectorClear(fx_s_args.accel);
		fx_s_args.scale = wv * 120; //16.0f;
		fx_s_args.dscale = wv * 120; //16.0f;
		fx_s_args.sAlpha = wv * 12;
		fx_s_args.eAlpha = wv * 12;
		fx_s_args.rotation = 0.0f;
		fx_s_args.bounce = 0.0f;
		fx_s_args.life = 1.0f;

		fx_s_args.flags = 0x08000000 | 0x00000001;

		if (cent->currentState.trickedentindex3 == 1)
		{
			//dark
			fx_s_args.sAlpha *= 3;
			fx_s_args.eAlpha *= 3;
			fx_s_args.shader = cgs.media.redSaberGlowShader;
			trap->FX_AddSprite(&fx_s_args);
		}
		else if (cent->currentState.trickedentindex3 == 2)
		{
			//light
			fx_s_args.sAlpha *= 1.5;
			fx_s_args.eAlpha *= 1.5;
			fx_s_args.shader = cgs.media.redSaberGlowShader;
			trap->FX_AddSprite(&fx_s_args);
			fx_s_args.shader = cgs.media.greenSaberGlowShader;
			trap->FX_AddSprite(&fx_s_args);
			fx_s_args.shader = cgs.media.blueSaberGlowShader;
			trap->FX_AddSprite(&fx_s_args);
		}
		else
		{
			//neutral
			if (s1->modelIndex + 128 == FP_SABER_OFFENSE ||
				s1->modelIndex + 128 == FP_SABER_DEFENSE ||
				s1->modelIndex + 128 == FP_SABERTHROW)
			{
				//saber power
				fx_s_args.sAlpha *= 1.5;
				fx_s_args.eAlpha *= 1.5;
				fx_s_args.shader = cgs.media.greenSaberGlowShader;
				trap->FX_AddSprite(&fx_s_args);
			}
			else
			{
				fx_s_args.sAlpha *= 0.5;
				fx_s_args.eAlpha *= 0.5;
				fx_s_args.shader = cgs.media.greenSaberGlowShader;
				trap->FX_AddSprite(&fx_s_args);
				fx_s_args.shader = cgs.media.blueSaberGlowShader;
				trap->FX_AddSprite(&fx_s_args);
			}
		}
	}

	if (cent->currentState.time == -1 && cent->currentState.weapon == WP_TRIP_MINE && cent->currentState.eFlags & EF_FIRING)
	{
		vec3_t beam_org;
		int beam_id;
		//if force sight is active, render the laser multiple times up to the force sight level to increase visibility
		if (!cg.snap->ps.duelInProgress ||
			cent->currentState.otherentity_num == cg.snap->ps.clientNum ||
			cent->currentState.otherentity_num == cg.snap->ps.duelIndex)
		{ // dont render if neither you nor opponent are owner
			if (cent->currentState.bolt2 == 1)
			{
				VectorMA(ent.origin, 6.6f, ent.axis[0], beam_org); // forward
				beam_id = cgs.effects.tripmineGlowFX;
				trap->FX_PlayEffectID(beam_id, beam_org, cent->currentState.pos.trDelta, -1, -1, qfalse);
			}
			else
			{
				VectorMA(ent.origin, 6.6f, ent.axis[0], beam_org); // forward
				beam_id = cgs.effects.tripmineLaserFX;

				if (cg.snap->ps.fd.forcePowersActive & 1 << FP_SEE)
				{
					int i = 0;
					i = cg.snap->ps.fd.forcePowerLevel[FP_SEE];

					while (i > 0)
					{
						trap->FX_PlayEffectID(beam_id, beam_org, cent->currentState.pos.trDelta, -1, -1, qfalse);
						trap->FX_PlayEffectID(beam_id, beam_org, cent->currentState.pos.trDelta, -1, -1, qfalse);
						i--;
					}
				}

				trap->FX_PlayEffectID(beam_id, beam_org, cent->currentState.pos.trDelta, -1, -1, qfalse);
			}
		}
	}

	if (cent->currentState.eFlags & EF_FORCE_VISIBLE && cg.snap->ps.fd.forcePowersActive & 1 << FP_SEE)
	{
		if (cgs.gametype == GT_SIEGE)
		{
			// A team game
			if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_SPECTATOR || cg.predictedPlayerState.persistant[
				PERS_TEAM] == TEAM_FREE)
			{
				//yellow
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 255;
				ent.shaderRGBA[2] = 0;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
			else if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_RED)
			{
				//red
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 50;
				ent.shaderRGBA[2] = 50;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
			else
			{
				//green
				ent.shaderRGBA[0] = 50;
				ent.shaderRGBA[1] = 255;
				ent.shaderRGBA[2] = 50;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
		}
		else if (cgs.gametype >= GT_TEAM)
		{
			// A team game
			if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_RED)
			{
				//red
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 50;
				ent.shaderRGBA[2] = 50;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
			else
			{
				//blue
				ent.shaderRGBA[0] = 75;
				ent.shaderRGBA[1] = 75;
				ent.shaderRGBA[2] = 255;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
		}
		else if (cgs.gametype == GT_FFA)
		{
			// A team game
			if (cent->currentState.botclass == BCLASS_DESANN
				|| cent->currentState.botclass == BCLASS_UNSTABLESABER
				|| cent->currentState.botclass == BCLASS_SHADOWTROOPER
				|| cent->currentState.botclass == BCLASS_TAVION
				|| cent->currentState.botclass == BCLASS_ALORA
				|| cent->currentState.botclass == BCLASS_REBORN)
			{
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 120;
				ent.shaderRGBA[2] = 255;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
			else if (cent->currentState.botclass == BCLASS_SBD
				|| cent->currentState.botclass == BCLASS_ASSASSIN_DROID
				|| cent->currentState.botclass == BCLASS_BATTLEDROID
				|| cent->currentState.botclass == BCLASS_DROIDEKA
				|| cent->currentState.botclass == BCLASS_SABER_DROID)
			{
				ent.shaderRGBA[0] = 100;
				ent.shaderRGBA[1] = 90;
				ent.shaderRGBA[2] = 160;
			}
			else if (cent->currentState.botclass == BCLASS_JEDI
				|| cent->currentState.botclass == BCLASS_JEDITRAINER
				|| cent->currentState.botclass == BCLASS_JEDIMASTER
				|| cent->currentState.botclass == BCLASS_LUKE
				|| cent->currentState.botclass == BCLASS_KYLE)
			{
				ent.shaderRGBA[0] = 0;
				ent.shaderRGBA[1] = 120;
				ent.shaderRGBA[2] = 0;
			}
			else if (cent->currentState.botclass == BCLASS_R2D2
				|| cent->currentState.botclass == BCLASS_R5D2
				|| cent->currentState.botclass == BCLASS_PROTOCOL)
			{
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 255;
				ent.shaderRGBA[2] = 230;
			}
			else if (cent->currentState.botclass == BCLASS_JAN)
			{
				ent.shaderRGBA[0] = 125;
				ent.shaderRGBA[1] = 255;
				ent.shaderRGBA[2] = 230;
			}
			else if (cent->currentState.botclass == BCLASS_BOBAFETT
				|| cent->currentState.botclass == BCLASS_ROCKETTROOPER
				|| cent->currentState.botclass == BCLASS_MANDOLORIAN
				|| cent->currentState.botclass == BCLASS_MANDOLORIAN1
				|| cent->currentState.botclass == BCLASS_MANDOLORIAN2)
			{
				ent.shaderRGBA[0] = 85;
				ent.shaderRGBA[1] = 155;
				ent.shaderRGBA[2] = 210;
			}
			else
			{
				ent.shaderRGBA[0] = 80;
				ent.shaderRGBA[1] = 80;
				ent.shaderRGBA[2] = 200;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
		}
		else
		{
			// Not a team game
			if (cg.snap->ps.zoomMode == 2)
			{
				// binoculars see orange
				ent.shaderRGBA[0] = 255;
				ent.shaderRGBA[1] = 128;
				ent.shaderRGBA[2] = 0;
				ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
			}
			else
			{
				if (cent->currentState.botclass == BCLASS_DESANN
					|| cent->currentState.botclass == BCLASS_UNSTABLESABER
					|| cent->currentState.botclass == BCLASS_SHADOWTROOPER
					|| cent->currentState.botclass == BCLASS_TAVION
					|| cent->currentState.botclass == BCLASS_ALORA
					|| cent->currentState.botclass == BCLASS_REBORN)
				{
					ent.shaderRGBA[0] = 255;
					ent.shaderRGBA[1] = 120;
					ent.shaderRGBA[2] = 255;
					ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
				}
				else if (cent->currentState.botclass == BCLASS_SBD
					|| cent->currentState.botclass == BCLASS_ASSASSIN_DROID
					|| cent->currentState.botclass == BCLASS_BATTLEDROID
					|| cent->currentState.botclass == BCLASS_DROIDEKA
					|| cent->currentState.botclass == BCLASS_SABER_DROID)
				{
					ent.shaderRGBA[0] = 100;
					ent.shaderRGBA[1] = 90;
					ent.shaderRGBA[2] = 160;
				}
				else if (cent->currentState.botclass == BCLASS_JEDI
					|| cent->currentState.botclass == BCLASS_JEDITRAINER
					|| cent->currentState.botclass == BCLASS_JEDIMASTER
					|| cent->currentState.botclass == BCLASS_LUKE
					|| cent->currentState.botclass == BCLASS_KYLE)
				{
					ent.shaderRGBA[0] = 0;
					ent.shaderRGBA[1] = 120;
					ent.shaderRGBA[2] = 0;
				}
				else if (cent->currentState.botclass == BCLASS_R2D2
					|| cent->currentState.botclass == BCLASS_R5D2
					|| cent->currentState.botclass == BCLASS_PROTOCOL)
				{
					ent.shaderRGBA[0] = 255;
					ent.shaderRGBA[1] = 255;
					ent.shaderRGBA[2] = 230;
				}
				else if (cent->currentState.botclass == BCLASS_JAN)
				{
					ent.shaderRGBA[0] = 125;
					ent.shaderRGBA[1] = 255;
					ent.shaderRGBA[2] = 230;
				}
				else if (cent->currentState.botclass == BCLASS_BOBAFETT
					|| cent->currentState.botclass == BCLASS_ROCKETTROOPER
					|| cent->currentState.botclass == BCLASS_MANDOLORIAN
					|| cent->currentState.botclass == BCLASS_MANDOLORIAN1
					|| cent->currentState.botclass == BCLASS_MANDOLORIAN2)
				{
					ent.shaderRGBA[0] = 85;
					ent.shaderRGBA[1] = 155;
					ent.shaderRGBA[2] = 210;
				}
				else
				{
					ent.shaderRGBA[0] = 80;
					ent.shaderRGBA[1] = 80;
					ent.shaderRGBA[2] = 200;
					ent.renderfx |= RF_MINLIGHT | RF_NODEPTH;
				}
			}
		}

		//only level 2+ can see players through walls
		if (cg.snap->ps.fd.forcePowerLevel[FP_SEE] < FORCE_LEVEL_2)
		{
			ent.renderfx &= ~RF_NODEPTH;
		}
		ent.renderfx &= ~RF_RGB_TINT;
		ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
		ent.customShader = cgs.media.sightShell;

		trap->R_AddRefEntityToScene(&ent);
	}

	if (debugBB.integer)
	{
		CG_CreateBBRefEnts(s1, cent->lerpOrigin);
	}
}

/*
==================
CG_Speaker

Speaker entities can automatically play sounds
==================
*/
static void CG_Speaker(centity_t* cent)
{
	if (cent->currentState.trickedentindex)
	{
		CG_S_StopLoopingSound(cent->currentState.number, -1);
	}

	if (!cent->currentState.clientNum)
	{
		// FIXME: use something other than clientNum...
		return; // not auto triggering
	}

	if (cg.time < cent->miscTime)
	{
		return;
	}

	trap->S_StartSound(NULL, cent->currentState.number, CHAN_ITEM, cgs.gameSounds[cent->currentState.eventParm]);

	//	ent->s.frame = ent->wait * 10;
	//	ent->s.clientNum = ent->random * 10;
	cent->miscTime = cg.time + cent->currentState.frame * 100 + cent->currentState.clientNum * 100 *
		Q_flrand(-1.0f, 1.0f);
}

static qboolean CG_GreyItem(const int type, const int tag, const int pl_side)
{
	if (type == IT_POWERUP &&
		(tag == PW_FORCE_ENLIGHTENED_LIGHT || tag == PW_FORCE_ENLIGHTENED_DARK))
	{
		if (pl_side == FORCE_LIGHTSIDE)
		{
			if (tag == PW_FORCE_ENLIGHTENED_DARK)
			{
				return qtrue;
			}
		}
		else if (pl_side == FORCE_DARKSIDE)
		{
			if (tag == PW_FORCE_ENLIGHTENED_LIGHT)
			{
				return qtrue;
			}
		}
	}

	return qfalse;
}

/*
==================
CG_Item
==================
*/
static void CG_Item(centity_t* cent)
{
	refEntity_t ent;
	entityState_t* es;
	gitem_t* item;
	int msec;
	weaponInfo_t* wi;

	es = &cent->currentState;
	if (es->modelIndex >= bg_numItems)
	{
		trap->Error(ERR_DROP, "Bad item index %i on entity", es->modelIndex);
	}

	/*
	Ghoul2 Insert Start
	*/

	if (es->eFlags & EF_NODRAW && es->eFlags & EF_ITEMPLACEHOLDER)
	{
		es->eFlags &= ~EF_NODRAW;
	}

	if (!es->modelIndex)
	{
		return;
	}

	item = &bg_itemlist[es->modelIndex];

	if ((item->giType == IT_WEAPON || item->giType == IT_POWERUP) &&
		!(cent->currentState.eFlags & EF_DROPPEDWEAPON) &&
		!cg_simpleItems.integer)
	{
		vec3_t u_norm;
		qboolean do_grey;

		VectorClear(u_norm);

		u_norm[2] = 1;

		memset(&ent, 0, sizeof ent);

		ent.customShader = 0;
		VectorCopy(cent->lerpOrigin, ent.origin);
		VectorCopy(cent->currentState.angles, cent->lerpAngles);
		AnglesToAxis(cent->lerpAngles, ent.axis);
		ent.hModel = cgs.media.itemHoloModel;

		do_grey = CG_GreyItem(item->giType, item->giTag, cg.snap->ps.fd.forceSide);

		if (do_grey)
		{
			ent.renderfx |= RF_RGB_TINT;

			ent.shaderRGBA[0] = 150;
			ent.shaderRGBA[1] = 150;
			ent.shaderRGBA[2] = 150;
		}

		trap->R_AddRefEntityToScene(&ent);

		if (!do_grey)
		{
			trap->FX_PlayEffectID(cgs.effects.itemCone, ent.origin, u_norm, -1, -1, qfalse);
		}
	}

	// if set to invisible, skip
	if (es->eFlags & EF_NODRAW)
	{
		return;
	}
	/*
	Ghoul2 Insert End
	*/

	if (cg_simpleItems.integer && item->giType != IT_TEAM)
	{
		memset(&ent, 0, sizeof ent);
		ent.reType = RT_SPRITE;
		VectorCopy(cent->lerpOrigin, ent.origin);
		ent.radius = 14;
		ent.customShader = cg_items[es->modelIndex].icon;
		ent.shaderRGBA[0] = 255;
		ent.shaderRGBA[1] = 255;
		ent.shaderRGBA[2] = 255;

		ent.origin[2] += 16;

		if (item->giType != IT_POWERUP || item->giTag != PW_FORCE_BOON || item->giTag != PW_GALAK_SHIELD)
		{
			ent.renderfx |= RF_FORCE_ENT_ALPHA;
		}

		if (es->eFlags & EF_ITEMPLACEHOLDER)
		{
			if (item->giType == IT_POWERUP && item->giTag == PW_FORCE_BOON || item->giTag == PW_GALAK_SHIELD)
			{
				return;
			}
			ent.shaderRGBA[0] = 200;
			ent.shaderRGBA[1] = 200;
			ent.shaderRGBA[2] = 200;
			ent.shaderRGBA[3] = 150 + sin(cg.time * 0.01) * 30;
		}
		else
		{
			ent.shaderRGBA[3] = 255;
		}

		if (CG_GreyItem(item->giType, item->giTag, cg.snap->ps.fd.forceSide))
		{
			ent.shaderRGBA[0] = 100;
			ent.shaderRGBA[1] = 100;
			ent.shaderRGBA[2] = 100;

			ent.shaderRGBA[3] = 200;

			if (item->giTag == PW_FORCE_ENLIGHTENED_LIGHT)
			{
				ent.customShader = trap->R_RegisterShader("gfx/misc/mp_light_enlight_disable");
			}
			else
			{
				ent.customShader = trap->R_RegisterShader("gfx/misc/mp_dark_enlight_disable");
			}
		}
		trap->R_AddRefEntityToScene(&ent);
		return;
	}

	if ((item->giType == IT_WEAPON || item->giType == IT_POWERUP) &&
		!(cent->currentState.eFlags & EF_DROPPEDWEAPON))
	{
		cent->lerpOrigin[2] += 16;
	}

	if ((!(cent->currentState.eFlags & EF_DROPPEDWEAPON) || item->giType == IT_POWERUP) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP))
	{
		float scale;
		// items bob up and down continuously
		scale = 0.005 + cent->currentState.number * 0.00001;
		cent->lerpOrigin[2] += 4 + cos((cg.time + 1000) * scale) * 4;
	}
	else
	{
		if (item->giType == IT_HOLDABLE)
		{
			if (item->giTag == HI_SEEKER)
			{
				cent->lerpOrigin[2] += 5;
			}
			if (item->giTag == HI_SHIELD)
			{
				cent->lerpOrigin[2] += 2;
			}
			if (item->giTag == HI_BINOCULARS)
			{
				cent->lerpOrigin[2] += 2;
			}
		}
		if (item->giType == IT_HEALTH)
		{
			cent->lerpOrigin[2] += 2;
		}
		if (item->giType == IT_ARMOR)
		{
			if (item->quantity == 100)
			{
				cent->lerpOrigin[2] += 7;
			}
		}
	}

	memset(&ent, 0, sizeof ent);

	if ((!(cent->currentState.eFlags & EF_DROPPEDWEAPON) || item->giType == IT_POWERUP) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP))
	{
		//only weapons and powerups rotate now
		// autorotate at one of two speeds
		VectorCopy(cg.autoAngles, cent->lerpAngles);
		AxisCopy(cg.autoAxis, ent.axis);
	}
	else
	{
		VectorCopy(cent->currentState.angles, cent->lerpAngles);
		AnglesToAxis(cent->lerpAngles, ent.axis);
	}

	wi = NULL;
	// the weapons have their origin where they attatch to player
	// models, so we need to offset them or they will rotate
	// eccentricly
	if (!(cent->currentState.eFlags & EF_DROPPEDWEAPON))
	{
		if (item->giType == IT_WEAPON)
		{
			wi = &cg_weapons[item->giTag];
			cent->lerpOrigin[0] -=
				wi->weaponMidpoint[0] * ent.axis[0][0] +
				wi->weaponMidpoint[1] * ent.axis[1][0] +
				wi->weaponMidpoint[2] * ent.axis[2][0];
			cent->lerpOrigin[1] -=
				wi->weaponMidpoint[0] * ent.axis[0][1] +
				wi->weaponMidpoint[1] * ent.axis[1][1] +
				wi->weaponMidpoint[2] * ent.axis[2][1];
			cent->lerpOrigin[2] -=
				wi->weaponMidpoint[0] * ent.axis[0][2] +
				wi->weaponMidpoint[1] * ent.axis[1][2] +
				wi->weaponMidpoint[2] * ent.axis[2][2];

			cent->lerpOrigin[2] += 8; // an extra height boost
		}
	}
	else
	{
		wi = &cg_weapons[item->giTag];

		switch (item->giTag)
		{
		case WP_BLASTER:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_DISRUPTOR:
			cent->lerpOrigin[2] -= 13;
			break;
		case WP_BOWCASTER:
			cent->lerpOrigin[2] -= 16;
			break;
		case WP_REPEATER:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_DEMP2:
			cent->lerpOrigin[2] -= 10;
			break;
		case WP_FLECHETTE:
			cent->lerpOrigin[2] -= 6;
			break;
		case WP_ROCKET_LAUNCHER:
			cent->lerpOrigin[2] -= 11;
			break;
		case WP_THERMAL:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_TRIP_MINE:
			cent->lerpOrigin[2] -= 16;
			break;
		case WP_DET_PACK:
			cent->lerpOrigin[2] -= 16;
			break;
		default:
			cent->lerpOrigin[2] -= 8;
			break;
		}
	}

	ent.hModel = cg_items[es->modelIndex].models[0];
	/*
	Ghoul2 Insert Start
	*/
	ent.ghoul2 = cg_items[es->modelIndex].g2Models[0];
	ent.radius = cg_items[es->modelIndex].radius[0];
	VectorCopy(cent->lerpAngles, ent.angles);
	/*
	Ghoul2 Insert End
	*/
	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(cent->lerpOrigin, ent.oldorigin);

	ent.nonNormalizedAxes = qfalse;

	// if just respawned, slowly scale up

	msec = cg.time - cent->miscTime;

	if (CG_GreyItem(item->giType, item->giTag, cg.snap->ps.fd.forceSide))
	{
		ent.renderfx |= RF_RGB_TINT;

		ent.shaderRGBA[0] = 150;
		ent.shaderRGBA[1] = 150;
		ent.shaderRGBA[2] = 150;

		ent.renderfx |= RF_FORCE_ENT_ALPHA;

		ent.shaderRGBA[3] = 200;

		if (item->giTag == PW_FORCE_ENLIGHTENED_LIGHT)
		{
			ent.customShader = trap->R_RegisterShader("gfx/misc/mp_light_enlight_disable");
		}
		else
		{
			ent.customShader = trap->R_RegisterShader("gfx/misc/mp_dark_enlight_disable");
		}

		trap->R_AddRefEntityToScene(&ent);
		return;
	}

	if (es->eFlags & EF_ITEMPLACEHOLDER) // item has been picked up
	{
		if (es->eFlags & EF_DEAD) // if item had been droped, don't show at all
			return;

		ent.renderfx |= RF_RGB_TINT;
		ent.shaderRGBA[0] = 0;
		ent.shaderRGBA[1] = 200;
		ent.shaderRGBA[2] = 85;
		ent.customShader = cgs.media.itemRespawningPlaceholder;
	}

	// increase the size of the weapons when they are presented as items
	if (item->giType == IT_WEAPON)
	{
		VectorScale(ent.axis[0], 1.5, ent.axis[0]);
		VectorScale(ent.axis[1], 1.5, ent.axis[1]);
		VectorScale(ent.axis[2], 1.5, ent.axis[2]);
		ent.nonNormalizedAxes = qtrue;
		//trap->S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, cgs.media.weaponHoverSound );
	}

	if (!(cent->currentState.eFlags & EF_DROPPEDWEAPON) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP))
	{
		ent.renderfx |= RF_MINLIGHT;
	}

	if (item->giType != IT_TEAM && msec >= 0 && msec < ITEM_SCALEUP_TIME && !(es->eFlags & EF_ITEMPLACEHOLDER) && !(es->
		eFlags & EF_DROPPEDWEAPON))
	{
		// if just respawned, fade in, but don't do this for flags.
		float alpha;
		int a;

		alpha = (float)msec / ITEM_SCALEUP_TIME;
		a = alpha * 255.0;
		if (a <= 0)
			a = 1;

		ent.shaderRGBA[3] = a;
		if (item->giType != IT_POWERUP || item->giTag != PW_FORCE_BOON || item->giTag != PW_GALAK_SHIELD)
		{
			//boon model uses a different blending mode for the sprite inside and doesn't look proper with this method
			ent.renderfx |= RF_FORCE_ENT_ALPHA;
		}
		trap->R_AddRefEntityToScene(&ent);

		ent.renderfx &= ~RF_FORCE_ENT_ALPHA;

		// Now draw the static shader over it.
		// Alpha in over half the time, out over half.

		//alpha = sin(M_PI*alpha);
		a = alpha * 255.0;

		a = 255 - a;

		if (a <= 0)
			a = 1;
		if (a > 255)
			a = 255;

		ent.customShader = cgs.media.itemRespawningRezOut;

		/*
		ent.shaderRGBA[0] = 0;
		ent.shaderRGBA[1] = a;
		ent.shaderRGBA[2] = a-100;

		if (ent.shaderRGBA[2] < 0)
		{
			ent.shaderRGBA[2] = 0;
		}
		*/

		/*
		ent.shaderRGBA[0] =
		ent.shaderRGBA[1] =
		ent.shaderRGBA[2] = a;
		*/

		ent.renderfx |= RF_RGB_TINT;
		ent.shaderRGBA[0] = 0;
		ent.shaderRGBA[1] = 200;
		ent.shaderRGBA[2] = 85;

		trap->R_AddRefEntityToScene(&ent);
	}
	else
	{
		// add to refresh list  -- normal item
		if (item->giType == IT_TEAM &&
			(item->giTag == PW_REDFLAG || item->giTag == PW_BLUEFLAG))
		{
			ent.modelScale[0] = 0.7f;
			ent.modelScale[1] = 0.7f;
			ent.modelScale[2] = 0.7f;
			ScaleModelAxis(&ent);
		}
		trap->R_AddRefEntityToScene(&ent);
	}

	//rww - As far as I can see, this is useless.
	/*
	if ( item->giType == IT_WEAPON && wi->barrelModel ) {
		refEntity_t	barrel;

		memset( &barrel, 0, sizeof( barrel ) );

		barrel.hModel = wi->barrelModel;

		VectorCopy( ent.lightingOrigin, barrel.lightingOrigin );
		barrel.shadowPlane = ent.shadowPlane;
		barrel.renderfx = ent.renderfx;

		barrel.customShader = ent.customShader;

		CG_PositionRotatedEntityOnTag( &barrel, &ent, wi->weaponModel, "tag_barrel" );

		AxisCopy( ent.axis, barrel.axis );
		barrel.nonNormalizedAxes = ent.nonNormalizedAxes;

		trap->R_AddRefEntityToScene( &barrel );
	}
	*/

	// accompanying rings / spheres for powerups
	if (!cg_simpleItems.integer)
	{
		vec3_t spin_angles;

		VectorClear(spin_angles);

		if (item->giType == IT_HEALTH || item->giType == IT_POWERUP)
		{
			if ((ent.hModel = cg_items[es->modelIndex].models[1]) != 0)
			{
				if (item->giType == IT_POWERUP)
				{
					ent.origin[2] += 12;
					spin_angles[1] = (cg.time & 1023) * 360 / -1024.0f;
				}
				AnglesToAxis(spin_angles, ent.axis);

				trap->R_AddRefEntityToScene(&ent);
			}
		}

		if (item->giType == IT_POWERUP)
		{
			ent.origin[2] += 8;

			if (item->giTag == PW_FORCE_ENLIGHTENED_LIGHT || item->giTag == PW_FORCE_BOON || item->giTag ==
				PW_GALAK_SHIELD)
			{
				trap->R_AddLightToScene(ent.origin, 255.0, 1.0f, 1.0f, 1.0f); // Let there be volume light...
			}
			else if (item->giTag == PW_FORCE_ENLIGHTENED_DARK)
			{
				trap->R_AddLightToScene(ent.origin, 255.0, 1.0f, 0.2f, 0.2f); // Let there be volume light...
			}
		}
	}
}

//============================================================================

static void CG_CreateDistortionTrailPart(const centity_t* cent, const float scale, vec3_t pos)
{
	refEntity_t ent;
	vec3_t ang;

	if (!cg_renderToTextureFX.integer)
	{
		return;
	}
	memset(&ent, 0, sizeof ent);

	VectorCopy(pos, ent.origin);

	VectorSubtract(ent.origin, cg.refdef.vieworg, ent.axis[0]);
	const float v_len = VectorLength(ent.axis[0]);
	if (VectorNormalize(ent.axis[0]) <= 0.1f)
	{
		// Entity is right on vieworg.  quit.
		return;
	}

	VectorCopy(cent->lerpAngles, ang);
	ang[PITCH] += 90.0f;
	AnglesToAxis(ang, ent.axis);

	//radius must be a power of 2, and is the actual captured texture size
	if (v_len < 512)
	{
		ent.radius = 256;
	}
	else if (v_len < 1024)
	{
		ent.radius = 128;
	}
	else if (v_len < 2048)
	{
		ent.radius = 64;
	}
	else
	{
		ent.radius = 32;
	}

	ent.modelScale[0] = scale;
	ent.modelScale[1] = scale;
	ent.modelScale[2] = scale * 16.0f;
	ScaleModelAxis(&ent);

	ent.hModel = trap->R_RegisterModel("models/weapons2/merr_sonn/trailmodel.md3");
	ent.customShader = cgs.media.itemRespawningRezOut;

#if 1
	ent.renderfx = RF_DISTORTION | RF_FORCE_ENT_ALPHA;
	ent.shaderRGBA[0] = 255.0f;
	ent.shaderRGBA[1] = 255.0f;
	ent.shaderRGBA[2] = 255.0f;
	ent.shaderRGBA[3] = 100.0f;
#else //no alpha
	ent.renderfx = RF_DISTORTION;
#endif

	trap->R_AddRefEntityToScene(&ent);
}

/*
===============
CG_Missile
===============
*/
extern void CG_AddSaberBlade(centity_t* cent, centity_t* scent, int renderfx,
	int saberNum, int blade_num, vec3_t origin, vec3_t angles, qboolean from_saber,
	qboolean dont_draw);
extern void CG_DoSaberLight(const saberInfo_t* saber, int cnum, int bnum);

static void CG_Missile(centity_t* cent)
{
	refEntity_t ent;
	entityState_t* s1;
	const weaponInfo_t* weapon;

	if (cg.snap->ps.duelInProgress &&
		cent->currentState.eType == ET_MISSILE &&
		cent->currentState.otherentity_num != cg.snap->ps.clientNum &&
		cent->currentState.otherentity_num != cg.snap->ps.duelIndex)
	{ //dont render missiles (includes dead sabers) if duel nox
		return;
	}

	s1 = &cent->currentState;

	if (s1->weapon > WP_NUM_WEAPONS && s1->weapon != G2_MODEL_PART)
	{
		s1->weapon = 0;
	}

	if (cent->ghoul2 && s1->weapon == G2_MODEL_PART)
	{
		weapon = &cg_weapons[WP_SABER];
	}
	else
	{
		weapon = &cg_weapons[s1->weapon];
	}

	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}

	if (s1->weapon == WP_SABER)
	{
		if ((cent->currentState.modelIndex != cent->serverSaberHitIndex || !cent->ghoul2) && !(s1->eFlags & EF_NODRAW))
		{
			//no g2, or server changed the model we are using
			const char* saber_model = CG_ConfigString(CS_MODELS + cent->currentState.modelIndex);

			cent->serverSaberHitIndex = cent->currentState.modelIndex;

			if (cent->ghoul2)
			{
				//clean if we already have one (because server changed model string index)
				trap->G2API_CleanGhoul2Models(&cent->ghoul2);
				cent->ghoul2 = 0;
			}

			if (saber_model && saber_model[0])
			{
				trap->G2API_InitGhoul2Model(&cent->ghoul2, saber_model, 0, 0, 0, 0, 0);
			}
			else
			{
				trap->G2API_InitGhoul2Model(&cent->ghoul2, DEFAULT_SABER_MODEL, 0, 0, 0, 0, 0);
			}

			//add blade bolts to saber hilt model so we can draw the saber blade on dropped/ballistic sabers
			if (cent->ghoul2 && s1->owner != ENTITYNUM_NONE)
			{
				//get the our owner's information.
				clientInfo_t* saber_owner_info = &cgs.clientinfo[s1->owner];
				int m = 0;
				int tag_bolt;
				char* tag_name;

				while (m < saber_owner_info->saber[0].numBlades)
				{
					tag_name = va("*blade%i", m + 1);
					tag_bolt = trap->G2API_AddBolt(cent->ghoul2, 0, tag_name);

					if (tag_bolt == -1)
					{
						if (m == 0)
						{
							tag_bolt = trap->G2API_AddBolt(cent->ghoul2, 0, "*flash");

							if (tag_bolt == -1)
							{
								assert(0);
							}
							break;
						}

						if (tag_bolt == -1)
						{
							assert(0);
							break;
						}
					}
					m++;
				}
			}
			return;
		}
		if (s1->eFlags & EF_NODRAW)
		{
			return;
		}
	}

	if (cent->ghoul2)
	{
		//give us a proper radius
		ent.radius = cent->currentState.g2radius;
	}

	if (s1->weapon == WP_STUN_BATON)
	{
		int i;
		orientation_t lerped;

		vec3_t start;
		vec3_t end;
		vec3_t r_hand_pos;

		centity_t* parent;
		mdxaBone_t mat;
		int color;
		color = 0x000020;

		// lerp the tag
		trap->R_LerpTag(&lerped, weapon->missileModel, 0, 0, 1.0, "tag_extrem");

		VectorCopy(cent->lerpOrigin, end);
		for (i = 0; i < 3; i++)
		{
			VectorMA(end, lerped.origin[i], s1->angles, end);
		}

		parent = &cg_entities[s1->otherentity_num];
		trap->G2API_GetBoltMatrix(parent->ghoul2, 1, 0, &mat, parent->turAngles, parent->lerpOrigin, cg.time,
			cgs.game_models, parent->modelScale);

		r_hand_pos[0] = mat.matrix[0][3];
		r_hand_pos[1] = mat.matrix[1][3];
		r_hand_pos[2] = mat.matrix[2][3];

		BG_GiveMeVectorFromMatrix(&mat, ORIGIN, start);

		trap->FX_AddLine(start, end, 0.1f, 0.1f, 0.0f, 0.5f, 0.0f, 0.0f, BLUER, BLUER, 0.0f, 300,
			trap->R_RegisterShader("gfx/effects/blueLine"), 0);

		CG_StunStartpoint(end);
	}

	if (s1->weapon == WP_MELEE)
	{
		int i;
		orientation_t lerped;

		vec3_t start;
		vec3_t end;

		centity_t* parent;
		mdxaBone_t mat;
		int color;
		color = 0x000020;

		// lerp the tag grapple
		trap->R_LerpTag(&lerped, weapon->missileModel, 0, 0, 1.0, "tag_extrem");

		VectorCopy(cent->lerpOrigin, end);
		for (i = 0; i < 3; i++)
		{
			VectorMA(end, lerped.origin[i], s1->angles, end);
		}

		parent = &cg_entities[s1->otherentity_num];
		trap->G2API_GetBoltMatrix(parent->ghoul2, 1, 0, &mat, parent->turAngles, parent->lerpOrigin, cg.time,
			cgs.game_models, parent->modelScale);
		BG_GiveMeVectorFromMatrix(&mat, ORIGIN, start);

		vec3_t v4DKGREY2 = { 0.15f, 0.15f, 0.15f };

		trap->FX_AddLine(start, end, 0.1f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, v4DKGREY2, v4DKGREY2, 0.0f, 300,
			trap->R_RegisterShader("gfx/misc/nav_line"), FX_SIZE_LINEAR);

		CG_GrappleStartpoint(end);
	}

	// calculate the axis
	//VectorCopy(s1->angles, cent->lerpAngles);

	if (s1->otherentity_num2 && s1->weapon != WP_SABER)
	{
		//using an over-ridden trail effect!
		vec3_t forward;

		if (VectorNormalize2(cent->currentState.pos.trDelta, forward) == 0.0f)
		{
			forward[2] = 1.0f;
		}
		if (s1->eFlags & EF_JETPACK_ACTIVE //hack so we know we're a vehicle Weapon shot
			&& (g_vehWeaponInfo[s1->otherentity_num2].iShotFX
				|| g_vehWeaponInfo[s1->otherentity_num2].iModel != NULL_HANDLE))
		{
			//a vehicle with an override for the weapon trail fx or model
			trap->FX_PlayEffectID(g_vehWeaponInfo[s1->otherentity_num2].iShotFX, cent->lerpOrigin, forward, -1, -1,
				qfalse);
			if (g_vehWeaponInfo[s1->otherentity_num2].iLoopSound)
			{
				vec3_t velocity;
				BG_EvaluateTrajectoryDelta(&cent->currentState.pos, cg.time, velocity);
				trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, velocity,
					g_vehWeaponInfo[s1->otherentity_num2].iLoopSound);
			}
			//add custom model
			if (g_vehWeaponInfo[s1->otherentity_num2].iModel == NULL_HANDLE)
			{
				return;
			}
		}
		else
		{
			//a regular missile
			trap->FX_PlayEffectID(cgs.gameEffects[s1->otherentity_num2], cent->lerpOrigin, forward, -1, -1, qfalse);
			if (s1->loopSound)
			{
				vec3_t velocity;
				BG_EvaluateTrajectoryDelta(&cent->currentState.pos, cg.time, velocity);
				trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, velocity, s1->loopSound);
			}
			return;
		}
	}
	else if (cent->currentState.eFlags & EF_ALT_FIRING)
	{
		// add trails
		if (weapon->altMissileTrailFunc)
		{
			weapon->altMissileTrailFunc(cent, weapon);
		}

		// add dynamic light
		if (weapon->altMissileDlight)
		{
			trap->R_AddLightToScene(cent->lerpOrigin, weapon->altMissileDlight,
				weapon->altMissileDlightColor[0], weapon->altMissileDlightColor[1],
				weapon->altMissileDlightColor[2]);
		}

		// add missile sound
		if (weapon->altMissileSound)
		{
			vec3_t velocity;

			BG_EvaluateTrajectoryDelta(&cent->currentState.pos, cg.time, velocity);
			trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, velocity, weapon->altMissileSound);
		}

		//Don't draw something without a model
		if (weapon->altMissileModel == NULL_HANDLE)
		{
			return;
		}
	}
	else if (s1->powerups & 1 << PW_FORCE_PROJECTILE)
	{
		if (s1->weapon == WP_CONCUSSION)
		{
			FX_DestructionProjectileThink(cent);
			//cgi_S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, vec3_origin, cgs.media.destructionSound);
			return;
		}
		/*else if (s1->weapon == WP_ROCKET_LAUNCHER)
		{
			FX_BlastProjectileThink(cent, weapon);
			trap->R_AddLightToScene(cent->lerpOrigin, 125, 1.0f, 0.65f, 0.0f);
			cgi_S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, vec3_origin, cgs.media.blastSound);
			return;
		}
		else if (s1->weapon == WP_DISRUPTOR)
		{
			FX_StrikeProjectileThink(cent, weapon);
			trap->R_AddLightToScene(cent->lerpOrigin, 125, 1.0f, 0.65f, 0.0f);
			return;
		}*/
	}
	else
	{
		// add trails
		if (weapon->missileTrailFunc)
		{
			weapon->missileTrailFunc(cent, weapon);
		}

		// add dynamic light
		if (weapon->missileDlight)
		{
			trap->R_AddLightToScene(cent->lerpOrigin, weapon->missileDlight,
				weapon->missileDlightColor[0], weapon->missileDlightColor[1],
				weapon->missileDlightColor[2]);
		}

		// add missile sound
		if (weapon->missileSound)
		{
			vec3_t velocity;

			BG_EvaluateTrajectoryDelta(&cent->currentState.pos, cg.time, velocity);

			trap->S_AddLoopingSound(cent->currentState.number, cent->lerpOrigin, velocity, weapon->missileSound);
		}

		//Don't draw something without a model
		if (weapon->missileModel == NULL_HANDLE && s1->weapon != WP_SABER && s1->weapon != G2_MODEL_PART)
			//saber uses ghoul2 model, doesn't matter
		{
			return;
		}
	}

	// create the render entity
	memset(&ent, 0, sizeof ent);
	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(cent->lerpOrigin, ent.oldorigin);
	CG_SetGhoul2Info(&ent, cent);

	// flicker between two skins
	ent.skinNum = cg.clientFrame & 1;
	ent.renderfx = RF_NOSHADOW;

	if (!(s1->eFlags & EF_JETPACK_ACTIVE))
	{
		if (s1->weapon != WP_SABER && s1->weapon != G2_MODEL_PART)
		{
			if (cent->currentState.eFlags & EF_ALT_FIRING)
			{
				ent.hModel = weapon->altMissileModel;
			}
			else
			{
				ent.hModel = weapon->missileModel;
			}
		}
	}
	//add custom model
	else
	{
		if (g_vehWeaponInfo[s1->otherentity_num2].iModel != NULL_HANDLE)
		{
			ent.hModel = g_vehWeaponInfo[s1->otherentity_num2].iModel;
		}
		else
		{
			//wtf?  how did we get here?
			return;
		}
	}

	// spin as it moves
	if (s1->apos.trType != TR_INTERPOLATE && s1->weapon != WP_SABER)
	{
		// convert direction of travel into axis
		if (VectorNormalize2(s1->pos.trDelta, ent.axis[0]) == 0)
		{
			ent.axis[0][2] = 1;
		}

		// spin as it moves
		if (s1->pos.trType != TR_STATIONARY)
		{
			if (s1->eFlags & EF_MISSILE_STICK)
			{
				RotateAroundDirection(ent.axis, cg.time * 0.5f); //Did this so regular missiles don't get broken
			}
			else
			{
				RotateAroundDirection(ent.axis, cg.time * 0.25f); //JFM:FLOAT FIX
			}
		}
		else
		{
			if (s1->eFlags & EF_MISSILE_STICK)
			{
				RotateAroundDirection(ent.axis, (float)s1->pos.trTime * 0.5f);
			}
			else
			{
				RotateAroundDirection(ent.axis, (float)s1->time);
			}
		}
	}
	else
	{
		AnglesToAxis(cent->lerpAngles, ent.axis);
	}

	if (s1->weapon == WP_SABER)
	{
		//This code lets ballistic or dropped sabers render their saber blades.

		if (s1->owner != ENTITYNUM_NONE)
		{
			vec3_t blade_angles;
			//we have an owner associated with this player.
			//get the our owner's information.
			clientInfo_t* saber_own_info = &cgs.clientinfo[s1->owner];
			centity_t* saber_own = &cg_entities[s1->owner];

			VectorCopy(cent->lerpAngles, blade_angles);
			blade_angles[ROLL] = 0;

			//render the blade.  Note, we're only rendering the blades on the first saber since the first saber
			//is the only one that can be tossed...for now.
			if (saber_own_info->saber[0].model[0])
			{
				int k;
				k = 0;
				while (k < saber_own_info->saber[0].numBlades)
				{
					int l = 0;
					if (l == 0 //first saber
						&& saber_own->currentState.saberHolstered == 1 //extra blades should be off
						&& k > 0) //this is an extra blade
					{
						//extra blades off
						//don't draw them
						CG_AddSaberBlade(saber_own, cent, 0, 0, k, cent->lerpOrigin, blade_angles, qtrue, qtrue);
					}
					else
					{
						CG_AddSaberBlade(saber_own, cent, 0, 0, k, cent->lerpOrigin, blade_angles, qtrue, qfalse);
					}

					k++;
				}
				if (saber_own_info->saber[0].numBlades > 2)
				{
					//add a single glow for the saber based on all the blade colors combined
					CG_DoSaberLight(&saber_own_info->saber[0], saber_own->currentState.clientNum, 0);
				}
			}
		}

		ent.radius = s1->g2radius;
	}

	// add to refresh list, possibly with quad glow
	CG_AddRefEntityWithPowerups(&ent, s1);

	if (s1->weapon == WP_SABER
		&& (cgs.gametype == GT_JEDIMASTER || //playing JediMaster
			s1->owner == cg.snap->ps.clientNum)) //or it's our saber and we've dropped it.
	{
		// always make the saber glow when on the ground
		float wv;
		int i;
		addspriteArgStruct_t fx_s_args;

		ent.customShader = cgs.media.solidWhite;
		ent.renderfx = RF_RGB_TINT;
		wv = sin(cg.time * 0.003f) * 0.08f + 0.1f;
		ent.shaderRGBA[0] = wv * 255;
		ent.shaderRGBA[1] = wv * 255;
		ent.shaderRGBA[2] = wv * 0;
		trap->R_AddRefEntityToScene(&ent);

		for (i = -4; i < 10; i += 1)
		{
			vec3_t org;
			VectorMA(ent.origin, -i, ent.axis[2], org);

			VectorCopy(org, fx_s_args.origin);
			VectorClear(fx_s_args.vel);
			VectorClear(fx_s_args.accel);
			fx_s_args.scale = 5.5f;
			fx_s_args.dscale = 5.5f;
			fx_s_args.sAlpha = wv;
			fx_s_args.eAlpha = wv;
			fx_s_args.rotation = 0.0f;
			fx_s_args.bounce = 0.0f;
			fx_s_args.life = 1.0f;
			fx_s_args.shader = cgs.media.yellowDroppedSaberShader;
			fx_s_args.flags = 0x08000000;

			trap->FX_AddSprite(&fx_s_args);
		}

		if (cgs.gametype == GT_JEDIMASTER)
		{
			ent.shaderRGBA[0] = 255;
			ent.shaderRGBA[1] = 255;
			ent.shaderRGBA[2] = 0;

			ent.renderfx |= RF_DEPTHHACK;
			ent.customShader = cgs.media.forceSightBubble;

			trap->R_AddRefEntityToScene(&ent);
		}
	}

	if (s1->eFlags & EF_FIRING)
	{
		//special code for adding the beam to the attached tripwire mine
		vec3_t beam_org;

		VectorMA(ent.origin, 8, ent.axis[0], beam_org); // forward
		trap->FX_PlayEffectID(cgs.effects.mTripMineLaser, beam_org, ent.axis[0], -1, -1, qfalse);
	}
}

int CG_BMS_START = 0;
int CG_BMS_MID = 1;
int CG_BMS_END = 2;

/*
-------------------------
CG_PlayDoorLoopSound
-------------------------
*/

void CG_PlayDoorLoopSound(const centity_t* cent)
{
	vec3_t origin;

	if (!cent->currentState.soundSetIndex)
	{
		return;
	}

	const char* sound_set = CG_ConfigString(CS_AMBIENT_SET + cent->currentState.soundSetIndex);

	if (!sound_set || !sound_set[0])
	{
		return;
	}

	const sfxHandle_t sfx = trap->AS_GetBModelSound(sound_set, CG_BMS_MID);

	if (sfx == -1)
	{
		return;
	}

	if (cent->currentState.eType == ET_MOVER) //shouldn't be in here otherwise, but just in case.
	{
		const float* v = cgs.inlineModelMidpoints[cent->currentState.modelIndex];
		VectorAdd(cent->lerpOrigin, v, origin);
	}
	else
	{
		VectorCopy(cent->lerpOrigin, origin);
	}

	//ent->s.loopSound = sfx;
	CG_S_AddRealLoopingSound(cent->currentState.number, origin, vec3_origin, sfx);
}

/*
-------------------------
CG_PlayDoorSound
-------------------------
*/

void CG_PlayDoorSound(const centity_t* cent, const int type)
{
	if (!cent->currentState.soundSetIndex)
	{
		return;
	}

	const char* sound_set = CG_ConfigString(CS_AMBIENT_SET + cent->currentState.soundSetIndex);

	if (!sound_set || !sound_set[0])
	{
		return;
	}

	const sfxHandle_t sfx = trap->AS_GetBModelSound(sound_set, type);

	if (sfx == -1)
	{
		return;
	}

	trap->S_StartSound(NULL, cent->currentState.number, CHAN_AUTO, sfx);
}

/*
===============
CG_Mover
===============
*/
static void CG_Mover(centity_t* cent)
{
	refEntity_t ent;

	const entityState_t* s1 = &cent->currentState;

	// create the render entity
	memset(&ent, 0, sizeof ent);

	if (cent->currentState.eFlags2 & EF2_HYPERSPACE)
	{
		//I'm the hyperspace brush
		qboolean draw_me = qfalse;
		if (cg.predictedPlayerState.m_iVehicleNum
			&& cg.predictedVehicleState.hyperSpaceTime
			&& cg.time - cg.predictedVehicleState.hyperSpaceTime < HYPERSPACE_TIME
			&& cg.time - cg.predictedVehicleState.hyperSpaceTime > 1000)
		{
			if (cg.snap
				&& cg.snap->ps.pm_type == PM_INTERMISSION)
			{
				//in the intermission, stop drawing hyperspace ent
			}
			else if (cg.predictedVehicleState.eFlags2 & EF2_HYPERSPACE)
			{
				//actually hyperspacing now
				const float time_frac = (float)(cg.time - cg.predictedVehicleState.hyperSpaceTime - 1000) / (
					HYPERSPACE_TIME - 1000);
				if (time_frac < HYPERSPACE_TELEPORT_FRAC + 0.1f)
				{
					//still in hyperspace or just popped out
					const float alpha = time_frac < 0.5f ? time_frac / 0.5f : 1.0f;
					draw_me = qtrue;
					VectorMA(cg.refdef.vieworg, 1000.0f + (1.0f - time_frac) * 1000.0f, cg.refdef.viewaxis[0],
						cent->lerpOrigin);
					VectorSet(cent->lerpAngles, cg.refdef.viewangles[PITCH], cg.refdef.viewangles[YAW] - 90.0f, 0);
					//cos( ( cg.time + 1000 ) *  scale ) * 4 );
					ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = 255;
					ent.shaderRGBA[3] = alpha * 255;
				}
			}
		}
		if (!draw_me)
		{
			//else, never draw
			return;
		}
	}

	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}

	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(cent->lerpOrigin, ent.oldorigin);
	AnglesToAxis(cent->lerpAngles, ent.axis);

	ent.renderfx = RF_NOSHADOW;
	/*
	Ghoul2 Insert Start
	*/

	CG_SetGhoul2Info(&ent, cent);
	/*
	Ghoul2 Insert End
	*/
	// flicker between two skins (FIXME?)
	ent.skinNum = cg.time >> 6 & 1;

	// get the model, either as a bmodel or a modelIndex
	if (s1->solid == SOLID_BMODEL)
	{
		ent.hModel = cgs.inlineDrawModel[s1->modelIndex];
	}
	else
	{
		ent.hModel = cgs.game_models[s1->modelIndex];
	}

	// If there isn't an hModel for this mover, an RGB axis model will get drawn.
	if (!ent.hModel)
	{
		return;
	}

	if (s1->eFlags & EF_SHADER_ANIM)
	{
		ent.renderfx |= RF_SETANIMINDEX;
		ent.skinNum = s1->frame;
	}

	if (cent->currentState.eFlags & EF_DISABLE_SHADER_ANIM)
	{
		// by setting the shader time to the current time, we can force an animating shader to not animate
		ent.shaderTime = cg.time * 0.001f;
	}

	// add the secondary model
	if (s1->model_index2 && s1->model_index2 < MAX_MODELS)
	{
		ent.hModel = cgs.game_models[s1->model_index2];
		if (s1->iModelScale)
		{
			//custom model2 scale
			ent.modelScale[0] = ent.modelScale[1] = ent.modelScale[2] = s1->iModelScale / 100.0f;
			ScaleModelAxis(&ent);
		}
		trap->R_AddRefEntityToScene(&ent);
	}

	ent.skinNum = 0;
	if (s1->eFlags & EF_ANIM_ONCE)
	{
		//FIXME: needs to anim at once per 100 ms
		ent.frame = s1->frame;
		ent.renderfx |= RF_CAP_FRAMES;
	}
	else if (s1->eFlags & EF_ANIM_ALLFAST)
	{
		ent.frame = cg.time / 100;
		ent.renderfx |= RF_WRAP_FRAMES;
	}
	else
	{
		ent.frame = s1->frame;
	}

	if (s1->eFlags & EF_SHADER_ANIM)
	{
		ent.renderfx |= RF_SETANIMINDEX;
		ent.skinNum = s1->frame;
	}

	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);
}

/*
===============
CG_Beam

Also called as an event
===============
*/
void CG_Beam(const centity_t* cent)
{
	refEntity_t ent;

	const entityState_t* s1 = &cent->currentState;

	// create the render entity
	memset(&ent, 0, sizeof ent);
	VectorCopy(s1->pos.trBase, ent.origin);
	VectorCopy(s1->origin2, ent.oldorigin);
	AxisClear(ent.axis);
	ent.reType = RT_BEAM;

	ent.renderfx = RF_NOSHADOW;
	/*
	Ghoul2 Insert Start
	*/
	CG_SetGhoul2Info(&ent, cent);

	/*
	Ghoul2 Insert End
	*/
	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);
}

/*
===============
CG_Grapple

This is called when the grapple is sitting up against the wall
===============
*/
extern void CG_GrappleTrail(centity_t* ent, const weaponInfo_t* wi);

static void CG_Grapple(centity_t* cent)
{
	refEntity_t ent;

	const entityState_t* s1 = &cent->currentState;
	const weaponInfo_t* weapon = &cg_weapons[WP_MELEE];

	// calculate the axis
	VectorCopy(s1->angles, cent->lerpAngles);

	// Will draw cable if needed
	CG_GrappleTrail(cent, weapon);

	// create the render entity
	memset(&ent, 0, sizeof ent);
	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(cent->lerpOrigin, ent.oldorigin);

	// flicker between two skins
	ent.skinNum = cg.clientFrame & 1;
	ent.hModel = weapon->missileModel;
	ent.renderfx = weapon->missileRenderfx | RF_NOSHADOW;

	// convert direction of travel into axis
	if (VectorNormalize2(s1->pos.trDelta, ent.axis[0]) == 0)
	{
		ent.axis[0][2] = 1;
	}

	trap->R_AddRefEntityToScene(&ent);
}

/*
===============
CG_Portal
===============
*/
static void CG_Portal(const centity_t* cent)
{
	refEntity_t ent;

	const entityState_t* s1 = &cent->currentState;

	// create the render entity
	memset(&ent, 0, sizeof ent);
	VectorCopy(cent->lerpOrigin, ent.origin);
	VectorCopy(s1->origin2, ent.oldorigin);
	ByteToDir(s1->eventParm, ent.axis[0]);
	PerpendicularVector(ent.axis[1], ent.axis[0]);

	// negating this tends to get the directions like they want
	// we really should have a camera roll value
	VectorSubtract(vec3_origin, ent.axis[1], ent.axis[1]);

	CrossProduct(ent.axis[0], ent.axis[1], ent.axis[2]);
	ent.reType = RT_PORTALSURFACE;
	ent.oldframe = s1->powerups;
	ent.frame = s1->frame; // rotation speed
	ent.skinNum = s1->clientNum / 256.0 * 360; // roll offset
	/*
	Ghoul2 Insert Start
	*/
	CG_SetGhoul2Info(&ent, cent);
	/*
	Ghoul2 Insert End
	*/
	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);
}

/*
=========================
CG_AdjustPositionForMover

Also called by client movement prediction code
=========================
*/
void CG_AdjustPositionForMover(const vec3_t in, const int mover_num, const int from_time, const int to_time, vec3_t out)
{
	vec3_t old_origin, origin, delta_origin;
	vec3_t old_angles, angles, delta_angles;

	if (cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_SPECTATOR)
	{
		VectorCopy(in, out);
		return;
	}

	if (mover_num <= 0 || mover_num >= ENTITYNUM_MAX_NORMAL)
	{
		VectorCopy(in, out);
		return;
	}

	const centity_t* cent = &cg_entities[mover_num];
	if (cent->currentState.eType != ET_MOVER)
	{
		VectorCopy(in, out);
		return;
	}

	BG_EvaluateTrajectory(&cent->currentState.pos, from_time, old_origin);
	BG_EvaluateTrajectory(&cent->currentState.apos, from_time, old_angles);

	BG_EvaluateTrajectory(&cent->currentState.pos, to_time, origin);
	BG_EvaluateTrajectory(&cent->currentState.apos, to_time, angles);

	VectorSubtract(origin, old_origin, delta_origin);
	VectorSubtract(angles, old_angles, delta_angles);

	VectorAdd(in, delta_origin, out);

	// FIXME: origin change when on a rotating object
}

/*
=============================
CG_InterpolateEntityPosition
=============================
*/
static void CG_InterpolateEntityPosition(centity_t* cent)
{
	vec3_t current, next;

	// it would be an internal error to find an entity that interpolates without
	// a snapshot ahead of the current one
	if (cg.nextSnap == NULL)
	{
		trap->Error(ERR_DROP, "CG_InterpoateEntityPosition: cg.nextSnap == NULL");
		return;
	}

	const float f = cg.frameInterpolation;

	// this will linearize a sine or parabolic curve, but it is important
	// to not extrapolate player positions if more recent data is available
	BG_EvaluateTrajectory(&cent->currentState.pos, cg.snap->serverTime, current);
	BG_EvaluateTrajectory(&cent->nextState.pos, cg.nextSnap->serverTime, next);

	cent->lerpOrigin[0] = current[0] + f * (next[0] - current[0]);
	cent->lerpOrigin[1] = current[1] + f * (next[1] - current[1]);
	cent->lerpOrigin[2] = current[2] + f * (next[2] - current[2]);

	BG_EvaluateTrajectory(&cent->currentState.apos, cg.snap->serverTime, current);
	BG_EvaluateTrajectory(&cent->nextState.apos, cg.nextSnap->serverTime, next);

	cent->lerpAngles[0] = LerpAngle(current[0], next[0], f);
	cent->lerpAngles[1] = LerpAngle(current[1], next[1], f);
	cent->lerpAngles[2] = LerpAngle(current[2], next[2], f);
}

/*
===============
CG_CalcEntityLerpPositions

===============
*/
void CG_CalcEntityLerpPositions(centity_t* cent)
{
	qboolean go_away = qfalse;

	// if this player does not want to see extrapolated players
	if (!cg_smoothClients.integer)
	{
		// make sure the clients use TR_INTERPOLATE
		if (cent->currentState.number != cg.clientNum && cent->currentState.number < MAX_CLIENTS || cent->currentState.
			eType == ET_NPC)
		{
			cent->currentState.pos.trType = TR_INTERPOLATE;
			cent->nextState.pos.trType = TR_INTERPOLATE;
		}
	}

	if (cg.predictedPlayerState.m_iVehicleNum &&
		cg.predictedPlayerState.m_iVehicleNum == cent->currentState.number &&
		cent->currentState.eType == ET_NPC && cent->currentState.NPC_class == CLASS_VEHICLE)
	{
		//special case for vehicle we are riding
		const centity_t* veh = &cg_entities[cg.predictedPlayerState.m_iVehicleNum];

		if (veh->currentState.owner == cg.predictedPlayerState.clientNum)
		{
			//only do this if the vehicle is pilotted by this client and predicting properly
			BG_EvaluateTrajectory(&cent->currentState.pos, cg.time, cent->lerpOrigin);
			BG_EvaluateTrajectory(&cent->currentState.apos, cg.time, cent->lerpAngles);
			return;
		}
	}

	if (cent->interpolate && cent->currentState.pos.trType == TR_INTERPOLATE)
	{
		CG_InterpolateEntityPosition(cent);
		return;
	}

	// first see if we can interpolate between two snaps for
	// linear extrapolated clients
	if (cent->interpolate && cent->currentState.pos.trType == TR_LINEAR_STOP
		&& (cent->currentState.number != cg.clientNum && cent->currentState.number < MAX_CLIENTS || cent->currentState.
			eType == ET_NPC))
	{
		CG_InterpolateEntityPosition(cent);
		go_away = qtrue;
	}
	else if (cent->interpolate &&
		cent->currentState.eType == ET_NPC && cent->currentState.NPC_class == CLASS_VEHICLE)
	{
		CG_InterpolateEntityPosition(cent);
		go_away = qtrue;
	}
	else
	{
		// just use the current frame and evaluate as best we can
		BG_EvaluateTrajectory(&cent->currentState.pos, cg.time, cent->lerpOrigin);
		BG_EvaluateTrajectory(&cent->currentState.apos, cg.time, cent->lerpAngles);
	}

#if 0
	if (cent->hasRagOffset && cent->ragOffsetTime < cg.time)
	{ //take all of the offsets from last frame and normalize the total direction and add it in
		vec3_t slideDir;
		vec3_t preOffset;
		vec3_t addedOffset;
		vec3_t	player_mins = { -15, -15, DEFAULT_MINS_2 };
		vec3_t	player_maxs = { 15, 15, DEFAULT_MAXS_2 };
		trace_t tr;

		//VectorSubtract(cent->lerpOrigin, callData->bonePos, slideDir);
		VectorCopy(cent->ragOffsets, slideDir);
		VectorNormalize(slideDir);

		//Store it in case we want to go back
		VectorCopy(cent->lerpOriginOffset, preOffset);

		//just add a little at a time
		VectorMA(cent->lerpOriginOffset, 0.4f, slideDir, cent->lerpOriginOffset);

		if (VectorLength(cent->lerpOriginOffset) > 10.0f)
		{ //don't go too far away
			VectorCopy(preOffset, cent->lerpOriginOffset);
		}
		else
		{
			//Let's trace there to make sure we can make it
			VectorAdd(cent->lerpOrigin, cent->lerpOriginOffset, addedOffset);
			CG_Trace(&tr, cent->lerpOrigin, player_mins, player_maxs, addedOffset, cent->currentState.number, MASK_PLAYERSOLID);

			if (tr.startsolid || tr.allsolid || tr.fraction != 1.0f)
			{ //can't get there
				VectorCopy(preOffset, cent->lerpOriginOffset);
			}
			else
			{
				/*
				if (cent->lerpOriginOffset[2] > 4.0f)
				{ //don't go too far off the ground
					cent->lerpOriginOffset[2] = 4.0f;
				}
				*/
				//I guess I just don't want this happening.
				cent->lerpOriginOffset[2] = 0.0f;
			}
		}

		//done with this bit
		cent->hasRagOffset = qfalse;
		VectorClear(cent->ragOffsets);
		cent->ragOffsetTime = cg.time + 50;
	}

	//See if we should add in the offset for ragdoll
	if (cent->isRagging && ((cent->currentState.eFlags & EF_DEAD) || (cent->currentState.eFlags & EF_RAG)))
	{
		VectorAdd(cent->lerpOrigin, cent->lerpOriginOffset, cent->lerpOrigin);
	}
#endif

	if (go_away)
	{
		return;
	}

	// adjust for riding a mover if it wasn't rolled into the predicted
	// player state
	if (cent->currentState.number != cg.clientNum)
	{
		CG_AdjustPositionForMover(cent->lerpOrigin, cent->currentState.groundEntityNum,
			cg.snap->serverTime, cg.time, cent->lerpOrigin);
	}
	}

void CG_G2Animated(centity_t* cent);

static void CG_FX(centity_t* cent)
{
	vec3_t fx_dir;
	int efx_index = 0;

	if (cent->miscTime > cg.time)
	{
		return;
	}

	const entityState_t* s1 = &cent->currentState;

	if (!s1)
	{
		return;
	}

	if (s1->model_index2 == FX_STATE_OFF)
	{
		// fx not active
		return;
	}

	if (s1->model_index2 < FX_STATE_ONE_SHOT_LIMIT)
	{
		// fx is single shot
		if (cent->muzzleFlashTime == s1->model_index2)
		{
			return;
		}
		// fx is single shot
		if (cent->muzzleOverheatTime == s1->model_index2)
		{
			return;
		}

		cent->muzzleFlashTime = s1->model_index2;
		cent->muzzleOverheatTime = s1->model_index2;
	}

	cent->miscTime = cg.time + s1->speed + Q_flrand(0.0f, 1.0f) * s1->time;

	AngleVectors(s1->angles, fx_dir, 0, 0);

	if (!fx_dir[0] && !fx_dir[1] && !fx_dir[2])
	{
		fx_dir[1] = 1;
	}

	if (cgs.gameEffects[s1->modelIndex])
	{
		efx_index = cgs.gameEffects[s1->modelIndex];
	}
	else
	{
		const char* s = CG_ConfigString(CS_EFFECTS + s1->modelIndex);
		if (s && s[0])
		{
			efx_index = trap->FX_RegisterEffect(s);
			cgs.gameEffects[s1->modelIndex] = efx_index;
		}
	}

	if (efx_index)
	{
		if (s1->isPortalEnt)
		{
			trap->FX_PlayEffectID(efx_index, cent->lerpOrigin, fx_dir, -1, -1, qtrue);
		}
		else
		{
			trap->FX_PlayEffectID(efx_index, cent->lerpOrigin, fx_dir, -1, -1, qfalse);
		}
	}
}

/*
===============
CG_AddCEntity

===============
*/
static void CG_AddCEntity(centity_t* cent)
{
	// event-only entities will have been dealt with already
	if (cent->currentState.eType >= ET_EVENTS)
	{
		return;
	}

	if (cg.predictedPlayerState.pm_type == PM_INTERMISSION)
	{
		//don't render anything then
		if (cent->currentState.eType == ET_GENERAL ||
			cent->currentState.eType == ET_PLAYER ||
			cent->currentState.eType == ET_INVISIBLE)
		{
			return;
		}
		if (cent->currentState.eType == ET_NPC)
		{
			//NPC in intermission
			if (cent->currentState.NPC_class == CLASS_VEHICLE)
			{
				//don't render vehicles in intermissions, allow other NPCs for scripts
				return;
			}
		}
	}

	// don't render when we are in spec, happens occasionally on map_restart and such
	if (cg.predictedPlayerState.clientNum == cent->currentState.number && cg.predictedPlayerState.persistant[PERS_TEAM]
		== TEAM_SPECTATOR)
		return;

	// calculate the current origin
	CG_CalcEntityLerpPositions(cent);

	// add local sound set if any
	if (cent->currentState.soundSetIndex && cent->currentState.eType != ET_MOVER)
	{
		const char* sound_set = CG_ConfigString(CS_AMBIENT_SET + cent->currentState.soundSetIndex);

		if (sound_set && sound_set[0])
		{
			trap->S_AddLocalSet(sound_set, cg.refdef.vieworg, cent->lerpOrigin, cent->currentState.number, cg.time);
		}
	}

	// add automatic effects
	CG_EntityEffects(cent);

	switch (cent->currentState.eType)
	{
	default:
		trap->Error(ERR_DROP, "Bad entity type: %i\n", cent->currentState.eType);
		break;

	case ET_FX:
		CG_FX(cent);
		break;

	case ET_INVISIBLE:
	case ET_PUSH_TRIGGER:
	case ET_TELEPORT_TRIGGER:
	case ET_TERRAIN:
		break;
	case ET_GENERAL:
		CG_General(cent);
		break;
	case ET_PLAYER:
		CG_Player(cent);
		break;
	case ET_ITEM:
		CG_Item(cent);
		break;
	case ET_MISSILE:
		CG_Missile(cent);
		break;
	case ET_SPECIAL:
		CG_Special(cent);
		break;
	case ET_HOLOCRON:
		CG_General(cent);
		break;
	case ET_MOVER:
		CG_Mover(cent);
		break;
	case ET_BEAM:
		CG_Beam(cent);
		break;
	case ET_PORTAL:
		CG_Portal(cent);
		break;
	case ET_SPEAKER:
		CG_Speaker(cent);
		break;
	case ET_NPC: //An entity that wants to be able to use ghoul2 humanoid (and other) anims. Like a player, but not.
		CG_G2Animated(cent);
		break;
	case ET_TEAM:
		break;
	case ET_BODY:
		CG_General(cent);
		break;
	case ET_GRAPPLE:
		CG_Grapple(cent);
		break;
	}
}

void CG_ManualEntityRender(centity_t* cent)
{
	CG_AddCEntity(cent);
}

/*
===============
CG_AddPacketEntities

===============
*/
void CG_AddPacketEntities(const qboolean is_portal)
{
	int num;
	centity_t* cent;

	if (is_portal)
	{
		for (num = 0; num < cg.snap->numEntities; num++)
		{
			cent = &cg_entities[cg.snap->entities[num].number];

			if (cent->currentState.isPortalEnt)
			{
				CG_AddCEntity(cent);
			}
		}
		return;
	}

	// set cg.frameInterpolation
	if (cg.nextSnap)
	{
		const int delta = cg.nextSnap->serverTime - cg.snap->serverTime;
		if (delta == 0)
		{
			cg.frameInterpolation = 0;
		}
		else
		{
			cg.frameInterpolation = (float)(cg.time - cg.snap->serverTime) / delta;
		}
	}
	else
	{
		cg.frameInterpolation = 0; // actually, it should never be used, because
		// no entities should be marked as interpolating
	}

	// the auto-rotating items will all have the same axis
	cg.autoAngles[0] = 0;
	cg.autoAngles[1] = (cg.time & 2047) * 360 / 2048.0;
	cg.autoAngles[2] = 0;

	cg.autoAnglesFast[0] = 0;
	cg.autoAnglesFast[1] = (cg.time & 1023) * 360 / 1024.0f;
	cg.autoAnglesFast[2] = 0;

	AnglesToAxis(cg.autoAngles, cg.autoAxis);
	AnglesToAxis(cg.autoAnglesFast, cg.autoAxisFast);

	// Reset radar entities
	cg.radarEntityCount = 0;
	cg.bracketedEntityCount = 0;

	// generate and add the entity from the playerstate
	playerState_t* ps = &cg.predictedPlayerState;

	CG_CheckPlayerG2Weapons(ps, &cg_entities[cg.predictedPlayerState.clientNum]);
	BG_PlayerStateToEntityState(ps, &cg_entities[cg.predictedPlayerState.clientNum].currentState, qfalse);

	if (cg.predictedPlayerState.m_iVehicleNum)
	{
		//add the vehicle I'm riding first
		centity_t* veh = &cg_entities[cg.predictedPlayerState.m_iVehicleNum];

		if (veh->currentState.owner == cg.predictedPlayerState.clientNum)
		{
			BG_PlayerStateToEntityState(&cg.predictedVehicleState, &veh->currentState, qfalse);
			veh->currentState.eType = ET_NPC;

			veh->currentState.pos.trType = TR_INTERPOLATE;
		}
		CG_AddCEntity(veh);
		veh->bodyHeight = cg.time; //indicate we have already been added
	}

	CG_AddCEntity(&cg_entities[cg.predictedPlayerState.clientNum]);

	/*
	// lerp the non-predicted value for lightning gun origins
	CG_CalcEntityLerpPositions( &cg_entities[ cg.snap->ps.clientNum ] );
	*/
	//No longer have to do this.

	// add each entity sent over by the server
	for (num = 0; num < cg.snap->numEntities; num++)
	{
		// Don't re-add ents that have been predicted.
		if (cg.snap->entities[num].number != cg.snap->ps.clientNum)
		{
			cent = &cg_entities[cg.snap->entities[num].number];
			if (cent->currentState.eType == ET_PLAYER &&
				cent->currentState.m_iVehicleNum)
			{
				//add his veh first
				int j = 0;

				while (j < cg.snap->numEntities)
				{
					if (cg.snap->entities[j].number == cent->currentState.m_iVehicleNum)
					{
						centity_t* veh = &cg_entities[cg.snap->entities[j].number];

						CG_AddCEntity(veh);
						veh->bodyHeight = cg.time; //indicate we have already been added
						break;
					}

					j++;
				}
			}
			else if (cent->currentState.eType == ET_NPC &&
				cent->currentState.m_iVehicleNum &&
				cent->bodyHeight == cg.time)
			{
				//never add a vehicle with a pilot, his pilot entity will get him added first.
				//if we were to add the vehicle after the pilot, the pilot's bolt would lag a frame behind.
				continue;
			}
			CG_AddCEntity(cent);
		}
	}

	for (num = 0; num < cg_numpermanents; num++)
	{
		cent = cg_permanents[num];
		if (cent->currentValid)
		{
			CG_AddCEntity(cent);
		}
	}
}

void CG_ROFF_NotetrackCallback(const centity_t* cent, const char* notetrack)
{
	int i = 0, r = 0, object_id;
	char type[256];
	char argument[512];
	char addl_arg[512];
	char err_msg[256];
	int addl_args = 0;

	if (!cent || !notetrack)
	{
		return;
	}

	//notetrack = "effect effects/explosion1.efx 0+0+64 0-0-1";

	while (notetrack[i] && notetrack[i] != ' ')
	{
		type[i] = notetrack[i];
		i++;
	}

	type[i] = '\0';

	if (notetrack[i] != ' ')
	{
		//didn't pass in a valid notetrack type, or forgot the argument for it
		return;
	}

	i++;

	while (notetrack[i] && notetrack[i] != ' ')
	{
		argument[r] = notetrack[i];
		r++;
		i++;
	}
	argument[r] = '\0';

	if (!r)
	{
		return;
	}

	if (notetrack[i] == ' ')
	{
		//additional arguments...
		addl_args = 1;

		i++;
		r = 0;
		while (notetrack[i])
		{
			addl_arg[r] = notetrack[i];
			r++;
			i++;
		}
		addl_arg[r] = '\0';
	}

	if (strcmp(type, "effect") == 0)
	{
		char t[64];
		vec3_t parsed_offset;
		int posoffset_gathered = 0;
		if (!addl_args)
		{
			//sprintf(errMsg, "Offset position argument for 'effect' type is invalid.");
			//goto functionend;
			VectorClear(parsed_offset);
			goto defaultoffsetposition;
		}

		i = 0;

		while (posoffset_gathered < 3)
		{
			r = 0;
			while (addl_arg[i] && addl_arg[i] != '+' && addl_arg[i] != ' ')
			{
				t[r] = addl_arg[i];
				r++;
				i++;
			}
			t[r] = '\0';
			i++;
			if (!r)
			{
				//failure..
				//sprintf(errMsg, "Offset position argument for 'effect' type is invalid.");
				//goto functionend;
				VectorClear(parsed_offset);
				i = 0;
				goto defaultoffsetposition;
			}
			parsed_offset[posoffset_gathered] = atof(t);
			posoffset_gathered++;
		}

		if (posoffset_gathered < 3)
		{
			Com_sprintf(err_msg, sizeof err_msg, "Offset position argument for 'effect' type is invalid.");
			goto functionend;
		}

		i--;

		if (addl_arg[i] != ' ')
		{
			addl_args = 0;
		}

	defaultoffsetposition:

		object_id = trap->FX_RegisterEffect(argument);

		if (object_id)
		{
			vec3_t up;
			vec3_t right;
			vec3_t forward;
			vec3_t use_origin;
			vec3_t use_angles;
			if (addl_args)
			{
				vec3_t parsed_angles;
				int angles_gathered = 0;
				//if there is an additional argument for an effect it is expected to be XANGLE-YANGLE-ZANGLE
				i++;
				while (angles_gathered < 3)
				{
					r = 0;
					while (addl_arg[i] && addl_arg[i] != '-')
					{
						t[r] = addl_arg[i];
						r++;
						i++;
					}
					t[r] = '\0';
					i++;

					if (!r)
					{
						//failed to get a new part of the vector
						angles_gathered = 0;
						break;
					}

					parsed_angles[angles_gathered] = atof(t);
					angles_gathered++;
				}

				if (angles_gathered)
				{
					VectorCopy(parsed_angles, use_angles);
				}
				else
				{
					//failed to parse angles from the extra argument provided..
					VectorCopy(cent->lerpAngles, use_angles);
				}
			}
			else
			{
				//if no constant angles, play in direction entity is facing
				VectorCopy(cent->lerpAngles, use_angles);
			}

			AngleVectors(use_angles, forward, right, up);

			VectorCopy(cent->lerpOrigin, use_origin);

			//forward
			use_origin[0] += forward[0] * parsed_offset[0];
			use_origin[1] += forward[1] * parsed_offset[0];
			use_origin[2] += forward[2] * parsed_offset[0];

			//right
			use_origin[0] += right[0] * parsed_offset[1];
			use_origin[1] += right[1] * parsed_offset[1];
			use_origin[2] += right[2] * parsed_offset[1];

			//up
			use_origin[0] += up[0] * parsed_offset[2];
			use_origin[1] += up[1] * parsed_offset[2];
			use_origin[2] += up[2] * parsed_offset[2];

			trap->FX_PlayEffectID(object_id, use_origin, use_angles, -1, -1, qfalse);
		}
	}
	else if (strcmp(type, "sound") == 0)
	{
		object_id = trap->S_RegisterSound(argument);
		trap->S_StartSound(cent->lerpOrigin, cent->currentState.number, CHAN_BODY, object_id);
	}
	else if (strcmp(type, "loop") == 0)
	{
		//handled server-side
		return;
	}
	//else if ...
	else
	{
		if (type[0])
		{
			Com_Printf("^3Warning: \"%s\" is an invalid ROFF notetrack function\n", type);
		}
		else
		{
			Com_Printf("^3Warning: Notetrack is missing function and/or arguments\n");
		}
	}

	return;

functionend:
	Com_Printf("^3Type-specific notetrack error: %s\n", err_msg);
}

void CG_Cube(vec3_t mins, vec3_t maxs, vec3_t color, const float alpha)
{
	const vec3_t rot = { 0, 0, 0 };
	int vec[3];
	int axis;
	addpolyArgStruct_t apArgs = { 0 };

	for (axis = 0, vec[0] = 0, vec[1] = 1, vec[2] = 2; axis < 3; axis++, vec[0]++, vec[1]++, vec[2]++)
	{
		for (int i = 0; i < 3; i++)
		{
			if (vec[i] > 2)
			{
				vec[i] = 0;
			}
		}

		apArgs.p[0][vec[1]] = mins[vec[1]];
		apArgs.p[0][vec[2]] = mins[vec[2]];

		apArgs.p[1][vec[1]] = mins[vec[1]];
		apArgs.p[1][vec[2]] = maxs[vec[2]];

		apArgs.p[2][vec[1]] = maxs[vec[1]];
		apArgs.p[2][vec[2]] = maxs[vec[2]];

		apArgs.p[3][vec[1]] = maxs[vec[1]];
		apArgs.p[3][vec[2]] = mins[vec[2]];

		//- face
		apArgs.p[0][vec[0]] = apArgs.p[1][vec[0]] = apArgs.p[2][vec[0]] = apArgs.p[3][vec[0]] = mins[vec[0]];

		apArgs.numVerts = 4;
		apArgs.alpha1 = apArgs.alpha2 = alpha;
		VectorCopy(color, apArgs.rgb1);
		VectorCopy(color, apArgs.rgb2);
		VectorCopy(rot, apArgs.rotationDelta);
		apArgs.killTime = cg.frametime;
		apArgs.shader = cgs.media.solidWhite;

		trap->FX_AddPoly(&apArgs);

		//+ face
		apArgs.p[0][vec[0]] = apArgs.p[1][vec[0]] = apArgs.p[2][vec[0]] = apArgs.p[3][vec[0]] = maxs[vec[0]];

		trap->FX_AddPoly(&apArgs);
	}
}

void CG_CubeOutline(vec3_t mins, vec3_t maxs, const int time, const unsigned int color)
{
	vec3_t point1;
	vec3_t point2;
	vec3_t point3;
	vec3_t point4;
	int vec[3];
	int axis;

	for (axis = 0, vec[0] = 0, vec[1] = 1, vec[2] = 2; axis < 3; axis++, vec[0]++, vec[1]++, vec[2]++)
	{
		for (int i = 0; i < 3; i++)
		{
			if (vec[i] > 2)
			{
				vec[i] = 0;
			}
		}

		point1[vec[1]] = mins[vec[1]];
		point1[vec[2]] = mins[vec[2]];

		point2[vec[1]] = mins[vec[1]];
		point2[vec[2]] = maxs[vec[2]];

		point3[vec[1]] = maxs[vec[1]];
		point3[vec[2]] = maxs[vec[2]];

		point4[vec[1]] = maxs[vec[1]];
		point4[vec[2]] = mins[vec[2]];

		//- face
		point1[vec[0]] = point2[vec[0]] = point3[vec[0]] = point4[vec[0]] = mins[vec[0]];

		CG_TestLine(point1, point2, time, color, 1);
		CG_TestLine(point2, point3, time, color, 1);
		CG_TestLine(point1, point4, time, color, 1);
		CG_TestLine(point4, point3, time, color, 1);

		//+ face
		point1[vec[0]] = point2[vec[0]] = point3[vec[0]] = point4[vec[0]] = maxs[vec[0]];

		CG_TestLine(point1, point2, time, color, 1);
		CG_TestLine(point2, point3, time, color, 1);
		CG_TestLine(point1, point4, time, color, 1);
		CG_TestLine(point4, point1, time, color, 1);
	}
}