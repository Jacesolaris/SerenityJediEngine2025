/*
===========================================================================
Copyright (C) 2000 - 2013, Raven Software, Inc.
Copyright (C) 2001 - 2013, Activision, Inc.
Copyright (C) 2013 - 2015, SerenityJediEngine2025 contributors

This file is part of the SerenityJediEngine2025 source code.

SerenityJediEngine2025 is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <http://www.gnu.org/licenses/>.
===========================================================================
*/

//====================================================================================
//
//rww - ICARUS callback file, all that can be handled within vm's is handled in here.
//
//====================================================================================

#include "qcommon/q_shared.h"
#include "bg_public.h"
#include "b_local.h"
#include "icarus/Q3_Interface.h"
#include "g_nav.h"
#include "g_dynmusic.h"
#include "g_roff.h"
#include "g_camera.h"

qboolean BG_SabersOff(const playerState_t* ps);
extern stringID_table_t WPTable[];
extern stringID_table_t BSTable[];
extern stringID_table_t TeamTable[];
qboolean skippingCutscene = qfalse; //toggle for cutscene skipping
extern qboolean in_camera;
qboolean player_locked = qfalse;
extern qboolean WinterGear;
qboolean inGameCinematic = qfalse;

void ToggleNPCWinterGear(gentity_t* ent);
void GCam_Enable(void);
void GCam_Disable(void);
void GCam_Pan(vec3_t dest, vec3_t panDirection, float duration);
void GCam_Move(vec3_t dest, float duration);
#define MAX_CAMERA_GROUP_SUBJECTS	16
void GCam_Follow(int cameraGroup[MAX_CAMERA_GROUP_SUBJECTS], float speed, float initLerp);

extern void LogExit(const char* string);
int GetStringDeclaredVariable(const char* name, char** value);
int GetFloatDeclaredVariable(const char* name, float* value);
int GetVectorDeclaredVariable(const char* name, vec3_t value);
void SetVar(const char* type_name, const char* data);

#define MAX_DECLAREDVARIABLES	32 //I think the engine max is supposed to be 32

struct DeclaredVariable_s
{
	char name[2048]; //name of the varible
	qboolean inuse; //variable is currently being used or not
	char Data[2048]; //string data for this variable
};

typedef struct DeclaredVariable_s DeclaredVariable_t;

void ObjectivePrint_Line()
{
	if (level.is_t1_fatal_map == qtrue)
	{
		trap->SendServerCommand(-1, "cp \"^1Disarm the bombs the Imperials have placed.\n\"");
	}
	else if (level.is_t1_rail_map == qtrue)
	{
		trap->SendServerCommand(-1, "cp \"^1Make your way to the front of the tram.\n\"");
	}
	else if (level.is_t1_danger_map == qtrue)
	{
		trap->SendServerCommand(-1, "cp \"^1Find and bring back to your ships equipment.\n\"");
	}
	else if (level.is_t2_rouge_map == qtrue)
	{
		trap->SendServerCommand(-1, "cp \"^1Capture Lannik Racto.\n\"");
	}
	else if (level.is_t2_trip_map == qtrue)
	{
		trap->SendServerCommand(-1, "cp \"^1Escape from the mercenaries and make your way to the far city gate.\n\"");
	}
	else
	{
		trap->SendServerCommand(-1, "cp \"^1May the Force be with you.\n\"");
	}
}

DeclaredVariable_t DeclaredVariables[MAX_DECLAREDVARIABLES] = { {{0}} };
int numDeclaredVariables = 0;

enum
{
	TK_EOF = -1,
	TK_UNDEFINED,
	TK_COMMENT,
	TK_EOL,
	TK_CHAR,
	TK_STRING,
	TK_INT,
	TK_INTEGER = TK_INT,
	TK_FLOAT,
	TK_IDENTIFIER,
	TK_USERDEF,
};

#include "icarus/interpreter.h"

extern stringID_table_t animTable[MAX_ANIMATIONS + 1];

stringID_table_t setTable[] =
{
	ENUM2STRING(SET_SPAWNSCRIPT),
	ENUM2STRING(SET_USESCRIPT),
	ENUM2STRING(SET_AWAKESCRIPT),
	ENUM2STRING(SET_ANGERSCRIPT),
	ENUM2STRING(SET_ATTACKSCRIPT),
	ENUM2STRING(SET_VICTORYSCRIPT),
	ENUM2STRING(SET_PAINSCRIPT),
	ENUM2STRING(SET_FLEESCRIPT),
	ENUM2STRING(SET_DEATHSCRIPT),
	ENUM2STRING(SET_DELAYEDSCRIPT),
	ENUM2STRING(SET_BLOCKEDSCRIPT),
	ENUM2STRING(SET_FFIRESCRIPT),
	ENUM2STRING(SET_FFDEATHSCRIPT),
	ENUM2STRING(SET_MINDTRICKSCRIPT),
	ENUM2STRING(SET_NO_MINDTRICK),
	ENUM2STRING(SET_ORIGIN),
	ENUM2STRING(SET_TELEPORT_DEST),
	ENUM2STRING(SET_ANGLES),
	ENUM2STRING(SET_XVELOCITY),
	ENUM2STRING(SET_YVELOCITY),
	ENUM2STRING(SET_ZVELOCITY),
	ENUM2STRING(SET_Z_OFFSET),
	ENUM2STRING(SET_ENEMY),
	ENUM2STRING(SET_LEADER),
	ENUM2STRING(SET_NAVGOAL),
	ENUM2STRING(SET_ANIM_UPPER),
	ENUM2STRING(SET_ANIM_LOWER),
	ENUM2STRING(SET_ANIM_BOTH),
	ENUM2STRING(SET_ANIM_HOLDTIME_LOWER),
	ENUM2STRING(SET_ANIM_HOLDTIME_UPPER),
	ENUM2STRING(SET_ANIM_HOLDTIME_BOTH),
	ENUM2STRING(SET_PLAYER_TEAM),
	ENUM2STRING(SET_ENEMY_TEAM),
	ENUM2STRING(SET_BEHAVIOR_STATE),
	ENUM2STRING(SET_BEHAVIOR_STATE),
	ENUM2STRING(SET_HEALTH),
	ENUM2STRING(SET_ARMOR),
	ENUM2STRING(SET_DEFAULT_BSTATE),
	ENUM2STRING(SET_CAPTURE),
	ENUM2STRING(SET_DPITCH),
	ENUM2STRING(SET_DYAW),
	ENUM2STRING(SET_EVENT),
	ENUM2STRING(SET_TEMP_BSTATE),
	ENUM2STRING(SET_COPY_ORIGIN),
	ENUM2STRING(SET_VIEWTARGET),
	ENUM2STRING(SET_WEAPON),
	ENUM2STRING(SET_ITEM),
	ENUM2STRING(SET_WALKSPEED),
	ENUM2STRING(SET_RUNSPEED),
	ENUM2STRING(SET_YAWSPEED),
	ENUM2STRING(SET_AGGRESSION),
	ENUM2STRING(SET_AIM),
	ENUM2STRING(SET_FRICTION),
	ENUM2STRING(SET_GRAVITY),
	ENUM2STRING(SET_IGNOREPAIN),
	ENUM2STRING(SET_IGNOREENEMIES),
	ENUM2STRING(SET_IGNOREALERTS),
	ENUM2STRING(SET_DONTSHOOT),
	ENUM2STRING(SET_DONTFIRE),
	ENUM2STRING(SET_LOCKED_ENEMY),
	ENUM2STRING(SET_NOTARGET),
	ENUM2STRING(SET_LEAN),
	ENUM2STRING(SET_CROUCHED),
	ENUM2STRING(SET_WALKING),
	ENUM2STRING(SET_RUNNING),
	ENUM2STRING(SET_CHASE_ENEMIES),
	ENUM2STRING(SET_LOOK_FOR_ENEMIES),
	ENUM2STRING(SET_FACE_MOVE_DIR),
	ENUM2STRING(SET_altFire),
	ENUM2STRING(SET_DONT_FLEE),
	ENUM2STRING(SET_FORCED_MARCH),
	ENUM2STRING(SET_NO_RESPONSE),
	ENUM2STRING(SET_NO_COMBAT_TALK),
	ENUM2STRING(SET_NO_ALERT_TALK),
	ENUM2STRING(SET_UNDYING),
	ENUM2STRING(SET_TREASONED),
	ENUM2STRING(SET_DISABLE_SHADER_ANIM),
	ENUM2STRING(SET_SHADER_ANIM),
	ENUM2STRING(SET_INVINCIBLE),
	ENUM2STRING(SET_NOAVOID),
	ENUM2STRING(SET_SHOOTDIST),
	ENUM2STRING(SET_TARGETNAME),
	ENUM2STRING(SET_TARGET),
	ENUM2STRING(SET_TARGET2),
	ENUM2STRING(SET_LOCATION),
	ENUM2STRING(SET_PAINTARGET),
	ENUM2STRING(SET_TIMESCALE),
	ENUM2STRING(SET_VISRANGE),
	ENUM2STRING(SET_EARSHOT),
	ENUM2STRING(SET_VIGILANCE),
	ENUM2STRING(SET_HFOV),
	ENUM2STRING(SET_VFOV),
	ENUM2STRING(SET_DELAYSCRIPTTIME),
	ENUM2STRING(SET_FORWARDMOVE),
	ENUM2STRING(SET_RIGHTMOVE),
	ENUM2STRING(SET_LOCKYAW),
	ENUM2STRING(SET_SOLID),
	ENUM2STRING(SET_CAMERA_GROUP),
	ENUM2STRING(SET_CAMERA_GROUP_Z_OFS),
	ENUM2STRING(SET_CAMERA_GROUP_TAG),
	ENUM2STRING(SET_LOOK_TARGET),
	ENUM2STRING(SET_ADDRHANDBOLT_MODEL),
	ENUM2STRING(SET_REMOVERHANDBOLT_MODEL),
	ENUM2STRING(SET_ADDLHANDBOLT_MODEL),
	ENUM2STRING(SET_REMOVELHANDBOLT_MODEL),
	ENUM2STRING(SET_FACEAUX),
	ENUM2STRING(SET_FACEBLINK),
	ENUM2STRING(SET_FACEBLINKFROWN),
	ENUM2STRING(SET_FACEFROWN),
	ENUM2STRING(SET_FACENORMAL),
	ENUM2STRING(SET_FACEEYESCLOSED),
	ENUM2STRING(SET_FACEEYESOPENED),
	ENUM2STRING(SET_SCROLLTEXT),
	ENUM2STRING(SET_LCARSTEXT),
	ENUM2STRING(SET_SCROLLTEXTCOLOR),
	ENUM2STRING(SET_CAPTIONTEXTCOLOR),
	ENUM2STRING(SET_CENTERTEXTCOLOR),
	ENUM2STRING(SET_PLAYER_USABLE),
	ENUM2STRING(SET_STARTFRAME),
	ENUM2STRING(SET_ENDFRAME),
	ENUM2STRING(SET_ANIMFRAME),
	ENUM2STRING(SET_LOOP_ANIM),
	ENUM2STRING(SET_INTERFACE),
	ENUM2STRING(SET_SHIELDS),
	ENUM2STRING(SET_NO_KNOCKBACK),
	ENUM2STRING(SET_INVISIBLE),
	ENUM2STRING(SET_VAMPIRE),
	ENUM2STRING(SET_FORCE_INVINCIBLE),
	ENUM2STRING(SET_GREET_ALLIES),
	ENUM2STRING(SET_PLAYER_LOCKED),
	ENUM2STRING(SET_LOCK_PLAYER_WEAPONS),
	ENUM2STRING(SET_NO_IMPACT_DAMAGE),
	ENUM2STRING(SET_PARM1),
	ENUM2STRING(SET_PARM2),
	ENUM2STRING(SET_PARM3),
	ENUM2STRING(SET_PARM4),
	ENUM2STRING(SET_PARM5),
	ENUM2STRING(SET_PARM6),
	ENUM2STRING(SET_PARM7),
	ENUM2STRING(SET_PARM8),
	ENUM2STRING(SET_PARM9),
	ENUM2STRING(SET_PARM10),
	ENUM2STRING(SET_PARM11),
	ENUM2STRING(SET_PARM12),
	ENUM2STRING(SET_PARM13),
	ENUM2STRING(SET_PARM14),
	ENUM2STRING(SET_PARM15),
	ENUM2STRING(SET_PARM16),
	ENUM2STRING(SET_DEFEND_TARGET),
	ENUM2STRING(SET_WAIT),
	ENUM2STRING(SET_COUNT),
	ENUM2STRING(SET_SHOT_SPACING),
	ENUM2STRING(SET_VIDEO_PLAY),
	ENUM2STRING(SET_VIDEO_FADE_IN),
	ENUM2STRING(SET_VIDEO_FADE_OUT),
	ENUM2STRING(SET_REMOVE_TARGET),
	ENUM2STRING(SET_LOADGAME),
	ENUM2STRING(SET_MENU_SCREEN),
	ENUM2STRING(SET_OBJECTIVE_SHOW),
	ENUM2STRING(SET_OBJECTIVE_HIDE),
	ENUM2STRING(SET_OBJECTIVE_SUCCEEDED),
	ENUM2STRING(SET_OBJECTIVE_FAILED),
	ENUM2STRING(SET_OBJECTIVE_LIGHTSIDE),
	ENUM2STRING(SET_MISSIONFAILED),
	ENUM2STRING(SET_TACTICAL_SHOW),
	ENUM2STRING(SET_TACTICAL_HIDE),
	ENUM2STRING(SET_FOLLOWDIST),
	ENUM2STRING(SET_SCALE),
	ENUM2STRING(SET_OBJECTIVE_CLEARALL),
	ENUM2STRING(SET_MISSIONSTATUSTEXT),
	ENUM2STRING(SET_WIDTH),
	ENUM2STRING(SET_CLOSINGCREDITS),
	ENUM2STRING(SET_SKILL),
	ENUM2STRING(SET_MISSIONSTATUSTIME),
	ENUM2STRING(SET_FULLNAME),
	ENUM2STRING(SET_FORCE_HEAL_LEVEL),
	ENUM2STRING(SET_FORCE_JUMP_LEVEL),
	ENUM2STRING(SET_FORCE_SPEED_LEVEL),
	ENUM2STRING(SET_FORCE_PUSH_LEVEL),
	ENUM2STRING(SET_FORCE_PULL_LEVEL),
	ENUM2STRING(SET_FORCE_MINDTRICK_LEVEL),
	ENUM2STRING(SET_FORCE_GRIP_LEVEL),
	ENUM2STRING(SET_FORCE_LIGHTNING_LEVEL),
	ENUM2STRING(SET_FORCE_RAGE_LEVEL),
	ENUM2STRING(SET_FORCE_PROTECT_LEVEL),
	ENUM2STRING(SET_FORCE_ABSORB_LEVEL),
	ENUM2STRING(SET_FORCE_TEAM_HEAL), //not in SP, but needed to get the set_force code to work
	ENUM2STRING(SET_FORCE_TEAM_FORCE), //not in SP, but needed to get the set_force code to work
	ENUM2STRING(SET_FORCE_DRAIN_LEVEL),
	ENUM2STRING(SET_FORCE_SIGHT_LEVEL),
	ENUM2STRING(SET_SABER_THROW),
	ENUM2STRING(SET_SABER_DEFENSE),
	ENUM2STRING(SET_SABER_OFFENSE),
	ENUM2STRING(SET_VIEWENTITY),
	ENUM2STRING(SET_WATCHTARGET),
	ENUM2STRING(SET_SABERACTIVE),
	ENUM2STRING(SET_ADJUST_AREA_PORTALS),
	ENUM2STRING(SET_DMG_BY_HEAVY_WEAP_ONLY),
	ENUM2STRING(SET_SHIELDED),
	ENUM2STRING(SET_NO_GROUPS),
	ENUM2STRING(SET_FIRE_WEAPON),
	ENUM2STRING(SET_SAFE_REMOVE),
	ENUM2STRING(SET_INACTIVE),
	ENUM2STRING(SET_FUNC_USABLE_VISIBLE),
	ENUM2STRING(SET_MISSION_STATUS_SCREEN),
	ENUM2STRING(SET_END_SCREENDISSOLVE),
	ENUM2STRING(SET_LOOPSOUND),
	ENUM2STRING(SET_ICARUS_FREEZE),
	ENUM2STRING(SET_ICARUS_UNFREEZE),
	ENUM2STRING(SET_USE_CP_NEAREST),
	ENUM2STRING(SET_MORELIGHT),
	ENUM2STRING(SET_CINEMATIC_SKIPSCRIPT),
	ENUM2STRING(SET_NO_FORCE),
	ENUM2STRING(SET_NO_FALLTODEATH),
	ENUM2STRING(SET_DISMEMBERABLE),
	ENUM2STRING(SET_NO_ACROBATICS),
	ENUM2STRING(SET_MUSIC_STATE),
	ENUM2STRING(SET_USE_SUBTITLES),
	ENUM2STRING(SET_CLEAN_DAMAGING_ENTS),
	ENUM2STRING(SET_HUD),
	ENUM2STRING(SET_NO_PVS_CULL),
	ENUM2STRING(SET_FORCE_PULL),
	ENUM2STRING(SET_WINTER_GEAR),
	ENUM2STRING(SET_RENDER_CULL_RADIUS),
	ENUM2STRING(SET_FORCE_PROTECT),
	//camera scripting commands
	ENUM2STRING(ENABLE),
	ENUM2STRING(MOVE),
	ENUM2STRING(PAN),
	ENUM2STRING(FADE),
	ENUM2STRING(ZOOM),
	ENUM2STRING(DISABLE),
	ENUM2STRING(SHAKE),
	ENUM2STRING(FOLLOW),

	{"", SET_},
};

//stringID_table_t INVTable[] =
//{
//	ENUM2STRING(INV_ELECTROBINOCULARS),
//	ENUM2STRING(INV_BACTA_CANISTER),
//	ENUM2STRING(INV_SEEKER),
//	ENUM2STRING(INV_LIGHTAMP_GOGGLES),
//	ENUM2STRING(INV_SENTRY),
//	{ "", 0 }
//};

stringID_table_t eventTable[] =
{
	"", EV_BAD,
};

stringID_table_t DMSTable[] =
{
	{"NULL", -1},
	ENUM2STRING(DM_AUTO), //# let the game determine the dynamic music as normal
	ENUM2STRING(DM_SILENCE), //# stop the music
	ENUM2STRING(DM_EXPLORE), //# force the exploration music to play
	ENUM2STRING(DM_ACTION), //# force the action music to play
	ENUM2STRING(DM_BOSS), //# force the boss battle music to play (if there is any)
	ENUM2STRING(DM_DEATH), //# force the "player dead" music to play
	{"", -1}
};

// g_subtimes.h -- English subtitle timings for coop serverside

stringID_table_t SubtitleTimeTable[] =
{
	{"ACADEMY1_01LUK011", 3900},
	{"ACADEMY1_01LUK012", 9750},
	{"ACADEMY1_01LUK013", 11115},
	{"ACADEMY1_01LUK014", 3380},
	{"ACADEMY1_01ROP026", 2145},
	{"ACADEMY1_01LUK015", 7020},
	{"ACADEMY1_01LUK016", 4615},
	{"ACADEMY1_01KYK006", 6760},
	{"ACADEMY1_01LUK017", 585},
	{"ACADEMY1_01LUK018", 4550},
	{"ACADEMY1_01ROP027", 3380},
	{"ACADEMY1_01KYK007", 9945},
	{"ACADEMY1_01ROP028", 2730},
	{"ACADEMY1_01KYK008", 4290},
	{"ACADEMY1_01KYK009", 4810},
	{"ACADEMY2_09LUK001", 15600},
	{"ACADEMY2_09ROP001", 2925},
	{"ACADEMY2_09KYK001", 975},
	{"ACADEMY2_09LUK002", 7280},
	{"ACADEMY2_09JE1001", 2600},
	{"ACADEMY2_09LUK003", 8645},
	{"ACADEMY2_09KYK002", 5980},
	{"ACADEMY2_09LUK004", 2015},
	{"ACADEMY2_09JAK001", 1690},
	{"ACADEMY2_09LUK005", 11700},
	{"ACADEMY2_09ROP002", 1625},
	{"ACADEMY2_09JAK002", 2470},
	{"ACADEMY2_09ROP003", 5850},
	{"ACADEMY2_09JAK003", 2990},
	{"ACADEMY2_09KYK003", 4940},
	{"ACADEMY2_09LUK006", 7670},
	{"ACADEMY2_09LUK007", 12285},
	{"ACADEMY2_09ROP004", 650},
	{"ACADEMY2_09LUK008", 3575},
	{"ACADEMY2_09ROP005", 2535},
	{"ACADEMY3_10LUK001", 9490},
	{"ACADEMY3_10KYK001", 1885},
	{"ACADEMY3_10JAK005", 4290},
	{"ACADEMY3_10LUK002", 4485},
	{"ACADEMY3_10LUK003", 1365},
	{"ACADEMY3_10KYK002", 4550},
	{"ACADEMY3_10LUK004", 1690},
	{"ACADEMY3_10KYK003", 9425},
	{"ACADEMY3_10LUK005", 585},
	{"ACADEMY3_10JAK006", 3185},
	{"ACADEMY3_10KYK004", 3705},
	{"ACADEMY3_10LUK006", 8580},
	{"ACADEMY3_10JAK007", 585},
	{"ACADEMY3_10LUK007", 4420},
	{"ACADEMY3_10JAK008", 3055},
	{"ACADEMY4_17LUK001", 13585},
	{"ACADEMY4_17LUK002", 3770},
	{"ACADEMY4_17JE1001", 4095},
	{"ACADEMY4_17LUK003", 10660},
	{"ACADEMY4_17LUK004", 12090},
	{"ACADEMY4_17KYK001", 2535},
	{"ACADEMY4_17LUK005", 4420},
	{"ACADEMY4_17KYK002", 2860},
	{"ACADEMY4_17LUK006", 1820},
	{"ACADEMY4_17KYK003", 7345},
	{"ACADEMY4_17LUK007", 5590},
	{"ACADEMY4_17KYK004", 1560},
	{"ACADEMY5_19KYK009", 5395},
	{"ACADEMY5_19LUK001", 6825},
	{"ACADEMY5_19KYK010", 5720},
	{"ACADEMY5_19JAK010", 7475},
	{"ACADEMY5_19LUK002", 7865},
	{"ACADEMY5_19KYK011", 7865},
	{"ACADEMY5_19LUK003", 390},
	{"ACADEMY5_19LUK004", 12155},
	{"ACADEMY5_19JAK011", 195},
	{"ACADEMY5_19LUK005", 13000},
	{"ACADEMY5_19KYK012", 975},
	{"ACADEMY5_19JAK012", 2470},
	{"ACADEMY5_19KYK013", 8840},
	{"ACADEMY5_19JAK013", 2340},
	{"ACADEMY6_26LUK001", 10660},
	{"ACADEMY6_26JAK001", 1040},
	{"ACADEMY6_26LUK002", 12675},
	{"ACADEMY6_26JAK002", 1300},
	{"ACADEMY6_26KYK001", 4810},
	{"ACADEMY6_26JAK003", 1820},
	{"ACADEMY6_26KYK002", 3380},
	{"ACADEMY6_26LUK003", 7865},
	{"ACADEMY6_26KYK003", 5460},
	{"ACADEMY6_26JAK004", 1170},
	{"ACADEMY6_26KYK004", 5915},
	{"ACADEMY6_26JAK005", 1820},
	{"ACADEMY6_26KYK005", 2795},
	{"ACADEMY6_26JAK006", 3965},
	{"ACADEMY6_26KYK006", 4290},
	{"ACADEMY6_26JAK007", 3315},
	{"ACADEMY6_26KYK007", 7085},
	{"ACADEMY6_26JAK008", 910},
	{"HOTH2_09JAK004", 3835},
	{"HOTH2_09JAK005", 715},
	{"HOTH2_09JAK006", 1885},
	{"HOTH2_09JAK007", 4030},
	{"HOTH2_09JAK008", 390},
	{"HOTH2_09JAK009", 3640},
	{"HOTH2_09JAK010", 1235},
	{"HOTH2_09JAK011", 1560},
	{"HOTH2_09JAK012", 650},
	{"HOTH2_09JAK013", 975},
	{"HOTH2_09JAK014", 910},
	{"HOTH2_09JAK015", 1170},
	{"HOTH2_09JAK016", 4160},
	{"HOTH2_09JAK017", 5200},
	{"HOTH2_09JAK018", 3315},
	{"HOTH2_09JAK019", 2795},
	{"HOTH2_09JAK020", 2860},
	{"HOTH3_10SO1001", 1170},
	{"HOTH3_10ST1001", 455},
	{"HOTH3_10SO1002", 9360},
	{"HOTH3_10ST2001", 3900},
	{"HOTH3_10ST1002", 2730},
	{"HOTH3_10ST2002", 5005},
	{"HOTH3_10ST1003", 1690},
	{"HOTH3_10JAK001", 2925},
	{"HOTH3_10JAK002", 4355},
	{"HOTH3_10CU1001", 1495},
	{"HOTH3_10ALO001", 650},
	{"HOTH3_10CU1002", 11180},
	{"HOTH3_10ALO002", 390},
	{"HOTH3_10CU1003", 8710},
	{"HOTH3_10ALO003", 2145},
	{"HOTH3_10JAK003", 2860},
	{"HOTH3_10ALO004", 7410},
	{"HOTH3_10TAA001", 2600},
	{"HOTH3_10ALO005", 11765},
	{"HOTH3_10ALO006", 1495},
	{"HOTH3_10JAK004", 780},
	{"KOR1_28JE1001", 2470},
	{"KOR1_28JAK001", 4420},
	{"KOR1_28JE1002", 8190},
	{"KOR1_28JAK002", 1300},
	{"KOR1_28JE1003", 3640},
	{"KOR1_28JE1004", 1560},
	{"KOR1_28JAK003", 2600},
	{"KOR1_28JE1005", 4485},
	{"KOR1_28JAK004", 2730},
	{"KOR1_28JAK005", 1885},
	{"KOR1_28JAK006", 2665},
	{"KOR1_28JAK007", 1365},
	{"KOR1_28JAK008", 3120},
	{"KOR1_MR_28JE2006", 520},
	{"KOR1_MS_28JE2007", 520},
	{"KOR1_28JE2008", 1755},
	{"KOR1_28JE2009", 715},
	{"KOR1_28JE2010", 780},
	{"KOR1_28JE2011", 780},
	{"KOR1_28JE2012", 1430},
	{"KOR1_28CU1001", 2340},
	{"KOR1_28CU1002", 910},
	{"KOR1_28CU1003", 845},
	{"KOR2_29JAK001", 1560},
	{"KOR2_29TAA001", 8320},
	{"KOR2_29JAK002", 6305},
	{"KOR2_29TAA002", 910},
	{"KOR2_29TAA003", 8190},
	{"KOR2_29JAK003", 325},
	{"KOR2_29TAA004", 2730},
	{"KOR2_29MAR001", 1365},
	{"KOR2_29JAK004", 780},
	{"KOR2_29TAA005", 780},
	{"KOR2_29MAR002", 2665},
	{"KOR2_29JAK005", 1690},
	{"KOR2_29MAR003", 1950},
	{"KOR2_29MAR004", 6305},
	{"KOR2_29JAK006", 4485},
	{"KOR2_29KYK001", 650},
	{"KOR2_29JAK007", 10140},
	{"KOR2_29LUK001", 5135},
	{"KOR2_29JAK008", 4550},
	{"KOR2_29KYK002", 3900},
	{"KOR2_29LUK002", 13975},
	{"KOR2_29JAK009", 2405},
	{"KOR2_29KYK003", 3575},
	{"KOR2_29LUK003", 7410},
	{"KOR2_29ROP001", 2015},
	{"KOR2_29LUK004", 9230},
	{"KOR2_29KYK004", 5525},
	{"KOR2_29JAK010", 910},
	{"KOR2_29KYK005", 5395},
	{"KOR2_29JAK011", 1755},
	{"KOR2_29JAK012", 1820},
	{"KOR2_29TAA006", 7215},
	{"KOR2_29JAK013", 4290},
	{"KOR2_29TAA007", 5850},
	{"KOR2_29JAK014", 6630},
	{"KOR2_29TAA008", 2600},
	{"KOR2_29TAA009", 4095},
	{"KOR2_29KYK006", 715},
	{"KOR2_29JAK015", 1755},
	{"KOR2_29KYK007", 8840},
	{"KOR2_29JAK016", 2340},
	{"KOR2_29KYK008", 7930},
	{"KOR2_29JAK017", 4810},
	{"KOR2_29KYK009", 2080},
	{"KOR2_29JAK018", 1300},
	{"KOR2_29LUK005", 1625},
	{"KOR2_MR_29KYK010", 4225},
	{"KOR2_MS_29KYK010", 4290},
	{"KOR2_29LUK006", 520},
	{"KOR2_MR_29KYK012", 6370},
	{"KOR2_MS_29KYK012", 6435},
	{"KOR2_MR_29LUK007", 2340},
	{"KOR2_MS_29LUK007", 2340},
	{"KOR2_29KYK014", 8580},
	{"KOR2_29LUK009", 4940},
	{"KOR2_MR_29LUK010", 1885},
	{"KOR2_MS_29LUK010", 1885},
	{"KOR2_29LUK012", 2600},
	{"KOR2_29KYK015", 1040},
	{"KOR2_29KYK016", 5330},
	{"KOR2_29LUK013", 4355},
	{"KOR2_29KYK017", 10465},
	{"KOR2_29LUK014", 3315},
	{"KOR2_29KYK018", 390},
	{"KOR2_29LUK015", 2275},
	{"T1_DANGER_06LUK001", 11765},
	{"T1_DANGER_06JAK001", 1040},
	{"T1_DANGER_06JAK002", 1235},
	{"T1_DANGER_06JAK003", 325},
	{"T1_DANGER_06JAK004", 325},
	{"T1_DANGER_06JAK005", 910},
	{"T1_DANGER_06ME1001", 2795},
	{"T1_DANGER_06JAK006", 845},
	{"T1_DANGER_06JAK007", 3185},
	{"T1_DANGER_06JAK008", 1950},
	{"T1_DANGER_06JAK009", 1300},
	{"T1_DANGER_06JAK010", 3185},
	{"T1_DANGER_06JAK011", 4095},
	{"T1_DANGER_06JAK012", 3965},
	{"T1_DANGER_06JAK013", 4875},
	{"T1_DANGER_06JAK014", 910},
	{"T1_DANGER_06JAK015", 260},
	{"T1_DANGER_06JAK016", 2015},
	{"T1_DANGER_06JAK017", 910},
	{"T1_DANGER_06JAK018", 585},
	{"T1_DANGER_06JAK019", 1625},
	{"T1_DANGER_06JAK020", 2080},
	{"T1_DANGER_06JAK021", 2275},
	{"T1_DANGER_06JAK022", 1755},
	{"T1_DANGER_06JAK023", 1235},
	{"T1_DANGER_06JAK024", 3250},
	{"T1_FATAL_08LUK001", 10920},
	{"T1_FATAL_08JAK001", 3315},
	{"T1_FATAL_08JAK002", 3315},
	{"T1_FATAL_08JAK003", 3770},
	{"T1_FATAL_08IS1001", 780},
	{"T1_FATAL_08IS2001", 455},
	{"T1_FATAL_MR_08IS3001", 2405},
	{"T1_FATAL_MS_08IS3001", 2405},
	{"T1_FATAL_08JAK004", 3640},
	{"T1_FATAL_08IS2002", 1560},
	{"T1_FATAL_08IS1002", 4160},
	{"T1_FATAL_08IS1003", 2990},
	{"T1_FATAL_08IS3002", 3640},
	{"T1_FATAL_08IS1004", 975},
	{"T1_FATAL_08JAK005", 4940},
	{"T1_FATAL_08IS1005", 2340},
	{"T1_FATAL_08IS3001", 325},
	{"T1_FATAL_08JAK006", 1625},
	{"T1_FATAL_08JAK007", 1495},
	{"T1_FATAL_08JAK008", 650},
	{"T1_FATAL_08JAK009", 1170},
	{"T1_FATAL_08JAK010", 975},
	{"T1_FATAL_08JAK011", 2665},
	{"T1_INTER_03ROP001", 5525},
	{"T1_INTER_03JE1001", 3445},
	{"T1_INTER_03ROP002", 1560},
	{"T1_INTER_03ROP003", 6370},
	{"T1_INTER_03JE1002", 1430},
	{"T1_INTER_03ROP004", 10270},
	{"T1_INTER_03JE1003", 6045},
	{"T1_INTER_03ROP005", 2665},
	{"T1_INTER_03JAK001", 585},
	{"T1_INTER_03KYK001", 3575},
	{"T1_INTER_03ROP006", 2340},
	{"T1_RAIL_05KYK001", 12155},
	{"T1_RAIL_05KYK002", 2665},
	{"T1_RAIL_05ME1001", 5265},
	{"T1_RAIL_05KYK003", 3445},
	{"T1_RAIL_05KYK004", 3185},
	{"T1_RAIL_05KYK005", 7930},
	{"T1_RAIL_05JAK001", 2210},
	{"T1_RAIL_05KYK006", 4225},
	{"T1_RAIL_05JAK002", 1170},
	{"T1_RAIL_05JAK003", 1690},
	{"T1_RAIL_05KYK007", 9685},
	{"T1_RAIL_05JAK005", 1300},
	{"T1_RAIL_05KYK008", 5005},
	{"T1_SOUR_07KYK001", 8190},
	{"T1_SOUR_07KYK002", 2210},
	{"T1_SOUR_07KYK003", 1625},
	{"T1_SOUR_07KYK004", 1235},
	{"T1_SOUR_07KYK005", 4225},
	{"T1_SOUR_07KYK006", 14560},
	{"T1_SOUR_07JAK001", 3900},
	{"T1_SOUR_07JAK002", 8580},
	{"T1_SOUR_07JAK003", 3185},
	{"T1_SOUR_07JAK004", 3770},
	{"T1_SOUR_07JAK005", 3055},
	{"T1_SOUR_07JAK006", 2925},
	{"T1_SOUR_07JAK007", 2990},
	{"T1_SOUR_07JAK008", 4485},
	{"T1_SOUR_07JAK009", 3640},
	{"T1_SOUR_07JAK010", 3640},
	{"T1_SOUR_07JAK011", 3315},
	{"T1_SOUR_07KYK007", 1300},
	{"T1_SOUR_07KYK008", 1820},
	{"T1_SOUR_07KYK009", 2405},
	{"T1_SOUR_07KYK010", 2990},
	{"T1_SOUR_07JAK012", 1105},
	{"T1_SOUR_07KYK011", 13585},
	{"T1_SOUR_07JAK013", 4810},
	{"T1_SOUR_07KYK012", 4290},
	{"T1_SURPRISE_04KYK001", 8450},
	{"T1_SURPRISE_04KYK002", 2470},
	{"T1_SURPRISE_04KYK003", 2990},
	{"T1_SURPRISE_04KYK004", 10270},
	{"T1_SURPRISE_04JAK001", 585},
	{"T1_SURPRISE_04KYK005", 2600},
	{"T1_SURPRISE_04JAK002", 1950},
	{"T1_SURPRISE_04JAK003", 2535},
	{"T1_SURPRISE_04JAK004", 1365},
	{"T1_SURPRISE_04JAK005", 1755},
	{"T1_SURPRISE_04JAK006", 2275},
	{"T1_SURPRISE_04JAK007", 1950},
	{"T1_SURPRISE_04JAK008", 9230},
	{"T1_SURPRISE_04KYK006", 2795},
	{"T1_SURPRISE_04JAK009", 3055},
	{"T1_SURPRISE_04KYK007", 7800},
	{"T2_DPRED_16PRO001", 12545},
	{"T2_DPRED_16RAJ001", 6760},
	{"T2_DPRED_16RAJ002", 3900},
	{"T2_DPRED_16JAK001", 2665},
	{"T2_DPRED_16RAJ003", 29705},
	{"T2_DPRED_16JAK002", 1885},
	{"T2_DPRED_16RAJ004", 6045},
	{"T2_DPRED_16RAJ005", 1235},
	{"T2_DPRED_16RAJ006", 2210},
	{"T2_DPRED_16RAJ007", 5980},
	{"T2_DPRED_16JAK003", 4030},
	{"T2_DPRED_16RAJ008", 780},
	{"T2_DPRED_16JAK004", 1820},
	{"T2_DPRED_16JAK005", 2145},
	{"T2_DPRED_16RAJ009", 4160},
	{"T2_DPRED_16RAJ010", 6565},
	{"T2_DPRED_16RAJ011", 3315},
	{"T2_RANCOR_12PRO001", 9750},
	{"T2_RANCOR_12KYK001", 10010},
	{"T2_RANCOR_12JAK001", 390},
	{"T2_RANCOR_12JAK002", 2470},
	{"T2_RANCOR_12JAK003", 1365},
	{"T2_RANCOR_12JAK004", 2860},
	{"T2_RANCOR_12JAK005", 1235},
	{"T2_RANCOR_12JAK006", 1820},
	{"T2_RANCOR_12PR1001", 3250},
	{"T2_RANCOR_12JAK007", 455},
	{"T2_RANCOR_12PR1002", 7085},
	{"T2_RANCOR_12JAK008", 6695},
	{"T2_RANCOR_12PR1003", 1040},
	{"T2_RANCOR_12JAK009", 195},
	{"T2_RANCOR_12PR1004", 2145},
	{"T2_RANCOR_12JAK010", 1495},
	{"T2_RANCOR_12JAK011", 1300},
	{"T2_RANCOR_12KYK002", 1625},
	{"T2_RANCOR_12JAK012", 6565},
	{"T2_RANCOR_12KYK003", 3900},
	{"T2_RANCOR_12JAK013", 2990},
	{"T2_RANCOR_12JAK014", 1690},
	{"T2_RANCOR_12PR1005", 650},
	{"T2_RANCOR_12PR2001", 520},
	{"T2_RANCOR_12PR1006", 195},
	{"T2_RANCOR_12PR2002", 260},
	{"T2_RANCOR_12JAK015", 2600},
	{"T2_RANCOR_12KYK004", 3510},
	{"T2_ROGUE_14KYK001", 9425},
	{"T2_ROGUE_14LAR001", 4810},
	{"T2_ROGUE_14LAR002", 6955},
	{"T2_ROGUE_14LAR003", 2340},
	{"T2_ROGUE_14JAK001", 2795},
	{"T2_ROGUE_14LAR004", 780},
	{"T2_ROGUE_14JAK002", 1365},
	{"T2_ROGUE_14LAR005", 4615},
	{"T2_ROGUE_14JAK003", 1365},
	{"T2_TRIP_15PRO001", 7540},
	{"T2_TRIP_15JAK001", 910},
	{"T2_TRIP_15JAK002", 325},
	{"T2_TRIP_15JAK003", 260},
	{"T2_TRIP_15JAK004", 1105},
	{"T2_TRIP_15JAK005", 2535},
	{"T2_TRIP_15JAK006", 195},
	{"T2_TRIP_15JAK007", 1560},
	{"T2_TRIP_15ME1001", 1040},
	{"T2_TRIP_15JAK008", 10335},
	{"T2_TRIP_15ME1002", 2275},
	{"T2_TRIP_15ME1003", 910},
	{"T2_TRIP_15JAK009", 2340},
	{"T2_TRIP_15JAK010", 2470},
	{"T2_TRIP_15JAK011", 2080},
	{"T2_TRIP_15JAK012", 1560},
	{"T2_TRIP_15JAK013", 650},
	{"T2_WEDGE_13WEA001", 8970},
	{"T2_WEDGE_13WEA002", 21125},
	{"T2_WEDGE_13WEA003", 5395},
	{"T2_WEDGE_13WEA004", 4420},
	{"T2_WEDGE_13WEA005", 5200},
	{"T2_WEDGE_13WEA006", 3965},
	{"T2_WEDGE_13WEA007", 8580},
	{"T2_WEDGE_13WEA008", 3835},
	{"T2_WEDGE_13WEA009", 4030},
	{"T2_WEDGE_13WEA010", 1820},
	{"T2_WEDGE_13WEA011", 1625},
	{"T2_WEDGE_13WEA012", 1040},
	{"T2_WEDGE_13WEA013", 1170},
	{"T2_WEDGE_13WEA014", 1365},
	{"T2_WEDGE_13WEA015", 1235},
	{"T2_WEDGE_13WEA016", 845},
	{"T2_WEDGE_13WEA017", 3835},
	{"T2_WEDGE_13WEA018", 2600},
	{"T2_WEDGE_13WEA019", 975},
	{"T2_WEDGE_13WEA020", 1040},
	{"T2_WEDGE_13WEA021", 1560},
	{"T2_WEDGE_13WEA022", 2210},
	{"T2_WEDGE_13JAK001", 1560},
	{"T2_WEDGE_13JAK002", 1430},
	{"T2_WEDGE_13JAK003", 1235},
	{"T3_BOUNTY_24KYK001", 6565},
	{"T3_BOUNTY_24JAK001", 2145},
	{"T3_BOUNTY_24JAK002", 585},
	{"T3_BOUNTY_24BOF001", 3055},
	{"T3_BOUNTY_24JAK003", 1495},
	{"T3_BOUNTY_24JAK004", 1105},
	{"T3_BOUNTY_24JAK005", 1560},
	{"T3_BOUNTY_24JAK006", 2730},
	{"T3_BOUNTY_24JAK007", 1625},
	{"T3_BOUNTY_24BOF002", 1820},
	{"T3_BYSS_21KYK001", 6825},
	{"T3_BYSS_21JAK001", 2470},
	{"T3_BYSS_21KYK002", 4160},
	{"T3_BYSS_21KYK003", 3445},
	{"T3_BYSS_21KYK004", 10335},
	{"T3_BYSS_21JAK002", 1365},
	{"T3_BYSS_21KYK005", 2340},
	{"T3_BYSS_21KYK006", 2535},
	{"T3_BYSS_21KYK007", 130},
	{"T3_BYSS_21KYK008", 3445},
	{"T3_BYSS_21KYK009", 3705},
	{"T3_BYSS_21JAK003", 1365},
	{"T3_BYSS_21KYK010", 3900},
	{"T3_BYSS_21KYK011", 5070},
	{"T3_BYSS_21KYK012", 4615},
	{"T3_BYSS_21KYK013", 1755},
	{"T3_BYSS_21KYK014", 845},
	{"T3_BYSS_21KYK015", 1235},
	{"T3_BYSS_21KYK016", 715},
	{"T3_BYSS_21KYK017", 1690},
	{"T3_BYSS_21KYK018", 4290},
	{"T3_BYSS_21KYK019", 2210},
	{"T3_BYSS_21KYK020", 3510},
	{"T3_BYSS_21KYK021", 3055},
	{"T3_HEVIL_22LUK001", 7930},
	{"T3_HEVIL_22JAK001", 5980},
	{"T3_HEVIL_22JAK002", 2860},
	{"T3_HEVIL_22JAK003", 5395},
	{"T3_HEVIL_22JAK004", 1950},
	{"T3_HEVIL_22JAK005", 1430},
	{"T3_HEVIL_22JAK006", 1820},
	{"T3_HEVIL_22JAK007", 2405},
	{"T3_RIFT_23LUK001", 9100},
	{"T3_RIFT_23JAK001", 1365},
	{"T3_RIFT_23JAK002", 2080},
	{"T3_RIFT_23JAK003", 1495},
	{"T3_RIFT_23JAK004", 1430},
	{"T3_RIFT_23JAK005", 1105},
	{"T3_RIFT_23JAK006", 2275},
	{"T3_RIFT_23JAK007", 1560},
	{"T3_RIFT_23JAK008", 1950},
	{"T3_RIFT_23JAK009", 4355},
	{"T3_RIFT_23JAK010", 3575},
	{"T3_RIFT_23JAK011", 1430},
	{"T3_RIFT_23JAK012", 2275},
	{"T3_STAMP_25JAK001", 4745},
	{"T3_STAMP_25JAK002", 975},
	{"T3_STAMP_25JAK003", 2600},
	{"T3_STAMP_25JAK004", 1690},
	{"T3_STAMP_25JAK005", 975},
	{"T3_STAMP_25JAK006", 3835},
	{"T3_STAMP_25JAK007", 1105},
	{"T3_STAMP_25KYK001", 7150},
	{"TASPIR1_26KYK008", 5070},
	{"TASPIR1_26JAK009", 845},
	{"TASPIR1_26JAK010", 1235},
	{"TASPIR1_26JAK011", 2080},
	{"TASPIR1_26JAK012", 5135},
	{"TASPIR1_26JAK013", 2860},
	{"TASPIR1_26KYK009", 4680},
	{"TASPIR1_26KYK010", 2080},
	{"TASPIR1_26KYK011", 2535},
	{"TASPIR2_27JAK001", 195},
	{"TASPIR2_27ALO001", 4680},
	{"TASPIR2_27JAK002", 780},
	{"TASPIR2_27ALO002", 6565},
	{"TASPIR2_27JAK003", 715},
	{"TASPIR2_27ALO003", 5265},
	{"TASPIR2_27JAK004", 5005},
	{"TASPIR2_27ALO004", 455},
	{"TASPIR2_27JAK005", 5005},
	{"TASPIR2_27ALO005", 3120},
	{"TASPIR2_27ALO006", 2210},
	{"TASPIR2_27ALO007", 3965},
	{"TASPIR2_27ALO008", 2990},
	{"TASPIR2_27ALO009", 2340},
	{"TASPIR2_27JAK006", 260},
	{"TASPIR2_27ROP001", 455},
	{"TASPIR2_27JAK007", 5915},
	{"TASPIR2_27ROP002", 5720},
	{"TASPIR2_27ROP003", 1040},
	{"TASPIR2_27ROP004", 1495},
	{"TASPIR2_27JAK008", 3770},
	{"TASPIR2_27ROP005", 7865},
	{"TASPIR2_27JAK009", 7735},
	{"TASPIR2_27KYK001", 1235},
	{"TASPIR2_27ALO010", 1040},
	{"TASPIR2_27ROP006", 7670},
	{"TASPIR2_27KYK002", 5915},
	{"TASPIR2_27ALO011", 2535},
	{"TASPIR2_27KYK003", 5720},
	{"TASPIR2_27JAK010", 6175},
	{"TASPIR2_27ROP007", 1040},
	{"TASPIR2_27ALO012", 5720},
	{"TASPIR2_27ALO013", 4940},
	{"TASPIR2_27JAK011", 5395},
	{"TASPIR2_27ALO014", 4290},
	{"TASPIR2_27ROP008", 585},
	{"TASPIR2_27JAK012", 260},
	{"TASPIR2_27ROP009", 520},
	{"TASPIR2_27KYK004", 260},
	{"TASPIR2_27ROP010", 585},
	{"TASPIR2_27KYK005", 8060},
	{"TASPIR2_27KYK006", 5590},
	{"TASPIR2_27JAK013", 6760},
	{"TASPIR2_27KYK007", 975},
	{"TASPIR2_27ROP011", 2080},
	{"TASPIR2_27JAK014", 4095},
	{"TASPIR2_27ROP012", 715},
	{"TASPIR2_27JAK015", 1105},
	{"TASPIR2_27ROP013", 715},
	{"TASPIR2_27ALO015", 2795},
	{"TASPIR2_27JAK016", 130},
	{"TASPIR2_27ALO016", 5590},
	{"TASPIR2_27JAK017", 11895},
	{"TASPIR2_27ALO017", 1170},
	{"TASPIR2_27JAK018", 4550},
	{"TASPIR2_27ALO018", 4420},
	{"TASPIR2_27ROP014", 715},
	{"TASPIR2_27KYK008", 260},
	{"TASPIR2_27ROP015", 5070},
	{"TASPIR2_27KYK009", 1235},
	{"TASPIR2_27ROP016", 910},
	{"TASPIR2_MR_27KYK010", 2795},
	{"TASPIR2_MS_27KYK010", 2860},
	{"TASPIR2_27KYK012", 2275},
	{"TIER1_1", 20085},
	{"TIER1_3", 12675},
	{"TIER1_4", 9490},
	{"TIER1_2", 11635},
	{"TIER1_5", 13520},
	{"TIER1_6", 3380},
	{"TIER2_7", 8320},
	{"TIER2_8", 5655},
	{"TIER2_9", 14820},
	{"TIER2_10", 7865},
	{"TIER2_11", 12155},
	{"TIER2_12", 5655},
	{"TIER3_13", 10725},
	{"TIER3_14", 9945},
	{"TIER3_15", 9880},
	{"TIER3_16", 11310},
	{"TIER3_17", 16250},
	{"TIER3_18", 2730},
	{"TIERVICTORY_T1_SURPRISE", 11635},
	{"TIERVICTORY_T1_FATAL", 4810},
	{"TIERVICTORY_T1_SOUR", 13650},
	{"TIERVICTORY_T1_DANGER", 13390},
	{"TIERVICTORY_T1_RAIL_01", 9490},
	{"TIERVICTORY_T1_RAIL_02", 12090},
	{"TIERVICTORY_T1_RAIL_03", 5785},
	{"TIERVICTORY_T1_RAIL_04", 3120},
	{"TIERVICTORY_T1_RAIL_05", 3445},
	{"TIERVICTORY_T2_TRIP", 5070},
	{"TIERVICTORY_T2_RANCOR", 10140},
	{"TIERVICTORY_T2_WEDGE", 12610},
	{"TIERVICTORY_T2_DPRED", 13325},
	{"TIERVICTORY_T2_ROGUE", 8970},
	{"TIERVICTORY_T3_BYSS", 6110},
	{"TIERVICTORY_T3_STAMP", 13520},
	{"TIERVICTORY_T3_RIFT", 11050},
	{"TIERVICTORY_T3_HEVIL", 17095},
	{"TIERVICTORY_T3_HEVIL_ALT", 11700},
	{"TIERVICTORY_T3_BOUNTY", 13000},
	{"VJUN1_17KYK005", 8580},
	{"VJUN1_17KYK006", 7670},
	{"VJUN1_17KYK007", 3380},
	{"VJUN1_17KYK008", 8905},
	{"VJUN1_17KYK009", 5590},
	{"VJUN1_17KYK010", 2470},
	{"VJUN1_17KYK011", 1365},
	{"VJUN1_17KYK012", 4550},
	{"VJUN1_17KYK013", 4225},
	{"VJUN1_17KYK014", 650},
	{"VJUN1_17KYK015", 2080},
	{"VJUN1_17KYK016", 4680},
	{"VJUN1_17KYK017", 3965},
	{"VJUN1_17KYK018", 715},
	{"VJUN1_17KYK019", 5200},
	{"VJUN1_17JAK001", 1820},
	{"VJUN1_17KYK020", 910},
	{"VJUN1_17KYK021", 2600},
	{"VJUN2_18KYK001", 7345},
	{"VJUN2_18KYK002", 6890},
	{"VJUN2_18KYK003", 4225},
	{"VJUN2_18KYK004", 3640},
	{"VJUN2_18KYK005", 7670},
	{"VJUN2_18KYK006", 1625},
	{"VJUN2_18KYK007", 7670},
	{"VJUN2_18KYK008", 3250},
	{"VJUN2_18KYK009", 8710},
	{"VJUN2_18KYK010", 5005},
	{"VJUN2_18KYK011", 1885},
	{"VJUN2_18KYK012", 1235},
	{"VJUN2_18KYK013", 845},
	{"VJUN2_18KYK014", 325},
	{"VJUN2_18KYK015", 1170},
	{"VJUN2_18KYK016", 7540},
	{"VJUN2_18KYK017", 2990},
	{"VJUN2_18JAK001", 260},
	{"VJUN2_18KYK018", 4745},
	{"VJUN2_18KYK019", 4095},
	{"VJUN2_18KYK020", 1170},
	{"VJUN2_18KYK021", 5135},
	{"VJUN2_18KYK022", 1495},
	{"VJUN2_18KYK023", 4160},
	{"VJUN2_18KYK032", 780},
	{"VJUN2_18KYK024", 1755},
	{"VJUN2_18KYK025", 7995},
	{"VJUN2_18KYK026", 5720},
	{"VJUN2_18KYK027", 4680},
	{"VJUN2_18KYK028", 1235},
	{"VJUN2_18JAK003", 1885},
	{"VJUN2_18KYK029", 4940},
	{"VJUN2_18KYK030", 3120},
	{"VJUN2_18JAK004", 780},
	{"VJUN2_18KYK031", 5070},
	{"VJUN3_19KYK001", 1430},
	{"VJUN3_19JAK001", 1430},
	{"VJUN3_19KYK002", 4485},
	{"VJUN3_19JAK002", 2535},
	{"VJUN3_19JAK003", 2535},
	{"VJUN3_19KYK003", 6760},
	{"VJUN3_19JAK004", 975},
	{"VJUN3_19KYK004", 2080},
	{"VJUN3_19JAK005", 2405},
	{"VJUN3_19ROP001", 1820},
	{"VJUN3_19JAK006", 1950},
	{"VJUN3_19ROP002", 7215},
	{"VJUN3_19ROP003", 10270},
	{"VJUN3_19JAK007", 2860},
	{"VJUN3_19ROP004", 715},
	{"VJUN3_19VIK001", 715},
	{"VJUN3_19DAK001", 3640},
	{"VJUN3_19ROP005", 5525},
	{"VJUN3_19VIK002", 1820},
	{"VJUN3_MR_19DAK002", 3120},
	{"VJUN3_MS_19DAK002", 3185},
	{"VJUN3_19VIK003", 1755},
	{"VJUN3_19DAK004", 2860},
	{"VJUN3_MR_19DAK005", 1820},
	{"VJUN3_MS_19DAK005", 1820},
	{"VJUN3_19VIK004", 715},
	{"VJUN3_19DAK007", 2210},
	{"VJUN3_19VIK005", 2210},
	{"VJUN3_19ROP006", 780},
	{"VJUN3_19ROP007", 520},
	{"VJUN3_19ROP008", 1105},
	{"VJUN3_19ROP009", 1560},
	{"VJUN3_19ROP010", 1365},
	{"VJUN3_19ROP011", 715},
	{"VJUN3_19TAA001", 4290},
	{"VJUN3_19KYK005", 390},
	{"VJUN3_19TAA002", 11115},
	{"VJUN3_19TAA003", 2015},
	{"VJUN3_19ROP012", 715},
	{"VJUN3_19JAK008", 520},
	{"VJUN3_19TAA004", 4875},
	{"VJUN3_19KYK006", 7085},
	{"VJUN3_19TAA005", 8190},
	{"VJUN3_19TAA006", 6045},
	{"VJUN3_19KYK007", 2795},
	{"VJUN3_19TAA007", 4225},
	{"VJUN3_19KYK008", 2080},
	{"VJUN3_19JAK009", 455},
	{"YAVIN1B_01PIL006", 5785},
	{"YAVIN1B_01ROP008", 2405},
	{"YAVIN1B_01JAK005", 1820},
	{"YAVIN1B_01ROP009", 3120},
	{"YAVIN1B_01ROP010", 4875},
	{"YAVIN1B_01ROP011", 2535},
	{"YAVIN1B_01ROP012", 845},
	{"YAVIN1B_01ROP013", 585},
	{"YAVIN1B_01ROP014", 3250},
	{"YAVIN1B_01ROP015", 390},
	{"YAVIN1B_01ROP016", 1690},
	{"YAVIN1B_01ROP017", 3640},
	{"YAVIN1B_01ROP018", 975},
	{"YAVIN1B_01ROP019", 5070},
	{"YAVIN1B_01ROP020", 3575},
	{"YAVIN1B_01ROP021", 1885},
	{"YAVIN1B_01ROP022", 2860},
	{"YAVIN1B_01JAK006", 585},
	{"YAVIN1B_01TAA001", 260},
	{"YAVIN1B_01JAK007", 1430},
	{"YAVIN1B_01KYK001", 4485},
	{"YAVIN1B_01JAK008", 845},
	{"YAVIN1B_01KYK002", 2600},
	{"YAVIN1B_01ROP023", 4875},
	{"YAVIN1B_01LUK004", 1430},
	{"YAVIN1B_01JAK009", 6955},
	{"YAVIN1B_01ROP024", 1690},
	{"YAVIN1B_01KYK003", 780},
	{"YAVIN1B_01LUK005", 1365},
	{"YAVIN1B_01JAK010", 1300},
	{"YAVIN1B_01LUK006", 2210},
	{"YAVIN1B_01KYK004", 8320},
	{"YAVIN1B_01LUK007", 585},
	{"YAVIN1B_01LUK008", 1365},
	{"YAVIN1B_01KYK005", 5265},
	{"YAVIN1B_01LUK009", 975},
	{"YAVIN1B_01LUK010", 2145},
	{"YAVIN1B_01ROP025", 3315},
	{"YAVIN1B_01TAA002", 2275},
	{"YAVIN1B_01ALO001", 3900},
	{"YAVIN1B_01TAA003", 585},
	{"YAVIN1B_09ROP004_Y1", 650},
	{"YAVIN1B_HINT1", 2080},
	{"YAVIN1_01PIL001", 3510},
	{"YAVIN1_01ROP001", 1625},
	{"YAVIN1_01ROP002", 6370},
	{"YAVIN1_01ROP003", 6110},
	{"YAVIN1_01JAK001", 1755},
	{"YAVIN1_01ROP004", 3380},
	{"YAVIN1_01JAK002", 1495},
	{"YAVIN1_01ROP005", 8060},
	{"YAVIN1_01ROP006", 1365},
	{"YAVIN1_01JAK003", 325},
	{"YAVIN1_01ROP007", 2275},
	{"YAVIN1_01JAK004", 3380},
	{"YAVIN1_01PIL002", 455},
	{"YAVIN1_01LUK001", 2600},
	{"YAVIN1_01PIL003", 5135},
	{"YAVIN1_01LUK002", 1365},
	{"YAVIN1_01PIL004", 650},
	{"YAVIN1_01LUK003", 6370},
	{"YAVIN1_01PIL005", 2730},
	{"YAVIN2_02KYK001", 10400},
	{"YAVIN2_02KYK002", 975},
	{"YAVIN2_02KYK003", 27105},
	{"YAVIN2_02KYK004", 9165},
	{"YAVIN2_02ROP001", 325},
	{"YAVIN2_02JAK001", 325},
	{"YAVIN2_02KYK005", 1365},
	{"YAVIN2_02ROP002", 260},
	{"YAVIN2_02KYK006", 975},
	{"YAVIN2_02KYK007", 1495},
	{"YAVIN2_02KYK008", 17745},
	{"YAVIN2_02KYK009", 4420},
	{"YAVIN2_02KYK010", 9685},
	{"YAVIN2_02KYK011", 4225},
	{"YAVIN2_02KYK012", 7735},
	{"YAVIN2_02ROP003", 4030},
	{"YAVIN2_02KYK013", 1820},
	{"YAVIN2_02JAK002", 455},
	{"YAVIN2_02KYK014", 715},
	{"YAVIN2_02JAK003", 910},
	{"YAVIN2_02KYK015", 17875},
	{"YAVIN2_02KYK016", 7215},
	{"YAVIN2_02KYK017", 11050},
	{"YAVIN2_02ROP004", 845},
	{"YAVIN2_02KYK018", 1495},
	{"YAVIN2_02ROP005", 910},
	{"YAVIN2_02KYK019", 2860},
	{"YAVIN2_02JAK004", 3965},
	{"YAVIN2_02ROP006", 3185},
	{"YAVIN2_02KYK020", 6565},
	{"YAVIN2_02ROP007", 4550},
	{"YAVIN2_02JAK005", 845},
	{"YAVIN2_02KYK021", 6370},
	{"YAVIN2_02JAK006", 1885},
	{"YAVIN2_02JAK007", 1430},
	{"YAVIN2_02KYK022", 2990},
	{"YAVIN2_02JAK008", 1040},
	{"YAVIN2_02ROP008", 1040},
	{"YAVIN2_02KYK023", 7020},
	{"YAVIN2_02LUK001", 11375},
	{"YAVIN2_02KYK024", 4550},
	{"YAVIN2_02LUK002", 7475},
	{"YAVIN2_02KYK025", 975},
	{"YAVIN2_02KYK026", 7865},
	{"ZOJP_COOP_MIS_01L01", 3055},
	{"ZOJP_COOP_MIS_01L02", 3640},
	{"ZOJP_COOP_MIS_01L03", 2600},
	{"ZOJP_COOP_MIS_01L04", 3965},
	{"ZOJP_COOP_MME_01L01", 5070},
	{"ZOJP_COOP_MME_01L02", 1495},
	{"ZOJP_COOP_MME_01L03", 5330},
	{"ZOJP_COOP_MME_01L04", 4745},
	{"ZOJP_COOP_MME_01L05", 845},

	//must be terminated
	{NULL, -1}
};

void Q3_TaskIDClear(int* taskID)
{
	*taskID = -1;
}

void G_DebugPrint(int level, const char* format, ...)
{
	va_list		argptr;
	char		text[1024] = { 0 };

	if (developer.integer != 2)
		return;

	va_start(argptr, format);
	Q_vsnprintf(text, sizeof(text), format, argptr);
	va_end(argptr);

	//Add the color formatting
	switch (level)
	{
	case WL_ERROR:
		Com_Printf(S_COLOR_RED"ERROR: %s", text);
		break;

	case WL_WARNING:
		Com_Printf(S_COLOR_YELLOW"WARNING: %s", text);
		break;

	case WL_DEBUG:
	{
		int		entNum;
		char* buffer;

		entNum = atoi(text);

		buffer = (char*)text;
		buffer += 5;

		if ((entNum < 0) || (entNum >= MAX_GENTITIES))
			entNum = 0;

		Com_Printf(S_COLOR_BLUE"DEBUG: %s(%d): %s\n", g_entities[entNum].script_targetname, entNum, buffer);
		break;
	}
	default:
	case WL_VERBOSE:
		Com_Printf(S_COLOR_GREEN"INFO: %s", text);
		break;
	}
}

/*
-------------------------
Q3_GetAnimLower
-------------------------
*/
static char* Q3_GetAnimLower(const gentity_t* ent)
{
	if (ent->client == NULL)
	{
		G_DebugPrint(WL_WARNING, "Q3_GetAnimLower: attempted to read animation state off non-client!\n");
		return NULL;
	}

	const int anim = ent->client->ps.legsAnim;

	return (char*)animTable[anim].name;
}

/*
-------------------------
Q3_GetAnimUpper
-------------------------
*/
static char* Q3_GetAnimUpper(const gentity_t* ent)
{
	if (ent->client == NULL)
	{
		G_DebugPrint(WL_WARNING, "Q3_GetAnimUpper: attempted to read animation state off non-client!\n");
		return NULL;
	}

	const int anim = ent->client->ps.torsoAnim;

	return (char*)animTable[anim].name;
}

/*
-------------------------
Q3_GetAnimBoth
-------------------------
*/
static char* Q3_GetAnimBoth(const gentity_t* ent)
{
	char* lowerName = Q3_GetAnimLower(ent);
	const char* upperName = Q3_GetAnimUpper(ent);

	if (!lowerName || !lowerName[0])
	{
		G_DebugPrint(WL_WARNING, "Q3_GetAnimBoth: NULL legs animation string found!\n");
		return NULL;
	}

	if (!upperName || !upperName[0])
	{
		G_DebugPrint(WL_WARNING, "Q3_GetAnimBoth: NULL torso animation string found!\n");
		return NULL;
	}

	if (Q_stricmp(lowerName, upperName))
	{
#ifdef _DEBUG	// sigh, cut down on tester reports that aren't important
		G_DebugPrint(WL_WARNING, "Q3_GetAnimBoth: legs and torso animations did not match : returning legs\n");
#endif
	}

	return lowerName;
}

static int Icarus_SoundTime(char soundName[MAX_QPATH])
{
	char temp[MAX_QPATH];
	char* sound = Q_strrchr(soundName, '/');
	sound++;
	trap->Cvar_VariableStringBuffer("mapname", temp, MAX_QPATH);
	int time = GetIDForString(SubtitleTimeTable, va("%s_%s", temp, sound));
	if (time < 0)
	{
		//couldn't find it in the original file.  Try looking into OJP's supplimental file.
		time = GetIDForString(SubtitleTimeTable, va("zojp_coop_%s", sound));
	}
	if (time < 0)
	{
		//no dice, so a default sound time
		time = 5000;
	}

	return time;
}

int Q3_PlaySound(const int taskID, const int entID, const char* name, const char* channel)
{
	gentity_t* ent = &g_entities[entID];
	char finalName[MAX_QPATH];
	soundChannel_t voice_chan = CHAN_VOICE; // set a default so the compiler doesn't bitch
	qboolean type_voice = qfalse;

	Q_strncpyz(finalName, name, MAX_QPATH);
	Q_strupr(finalName);

	COM_StripExtension(finalName, finalName, sizeof finalName);

	const int soundHandle = G_SoundIndex(finalName);
	qboolean bBroadcast = qfalse;

	if (Q_stricmp(channel, "CHAN_ANNOUNCER") == 0 || ent->classname && Q_stricmp("target_scriptrunner", ent->classname)
		== 0)
	{
		bBroadcast = qtrue;
	}

	// moved here from further down so I can easily check channel-type without code dup...
	//
	if (Q_stricmp(channel, "CHAN_VOICE") == 0)
	{
		voice_chan = CHAN_VOICE;
		type_voice = qtrue;
	}
	else if (Q_stricmp(channel, "CHAN_VOICE_ATTEN") == 0)
	{
		voice_chan = CHAN_AUTO; //CHAN_VOICE_ATTEN;
		type_voice = qtrue;
	}
	else if (Q_stricmp(channel, "CHAN_VOICE_GLOBAL") == 0)
		// this should broadcast to everyone, put only casue animation on G_SoundOnEnt...
	{
		voice_chan = CHAN_VOICE_GLOBAL;
		type_voice = qtrue;
		bBroadcast = qtrue;
	}

	if (type_voice)
	{
		char buf[128];

		trap->Cvar_VariableStringBuffer("timescale", buf, sizeof buf);

		const float tFVal = atof(buf);

		if (tFVal > 1.0f)
		{
			//Skip the damn sound!
			return qtrue;
		}
		//This the voice channel
		//these should be playing on the entity in question, not a temp entity
		G_EntitySound(ent, voice_chan, G_SoundIndex(finalName));
		//Remember we're waiting for this
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_CHAN_VOICE, taskID);
		//Set sound debounce time
		ent->IcarusSoundTime = level.time + Icarus_SoundTime(finalName);

		return qfalse;
	}

	if (bBroadcast)
	{
		//Broadcast the sound

		gentity_t* te = G_TempEntity(ent->r.currentOrigin, EV_GLOBAL_SOUND);
		te->s.eventParm = soundHandle;
		te->r.svFlags |= SVF_BROADCAST;
	}
	else
	{
		G_Sound(ent, CHAN_AUTO, soundHandle);
	}

	return qtrue;
}

/*
-------------------------
Q3_Play
-------------------------
*/
void Q3_Play(const int taskID, const int entID, const char* type, const char* name)
{
	gentity_t* ent = &g_entities[entID];

	if (stricmp(type, "PLAY_ROFF") == 0)
	{
		// Try to load the requested ROFF
		if (G_LoadRoffs(name))
		{
			ent->roffname = G_NewString(name);

			// Start the roff from the beginning
			ent->roff_ctr = 0;

			//Save this off for later
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);

			// Let the ROFF playing start.
			ent->next_roff_time = level.time;

			// These need to be initialised up front...
			VectorCopy(ent->r.currentOrigin, ent->pos1);
			VectorCopy(ent->r.currentAngles, ent->pos2);
			trap->LinkEntity((sharedEntity_t*)ent);
		}
	}
}

/*
=============
anglerCallback

Utility function
=============
*/
void anglerCallback(gentity_t* ent)
{
	//Complete the task
	trap->ICARUS_TaskIDComplete((sharedEntity_t*)ent, TID_ANGLE_FACE);

	//Set the currentAngles, clear all movement
	VectorMA(ent->s.apos.trBase, ent->s.apos.trDuration * 0.001f, ent->s.apos.trDelta, ent->r.currentAngles);
	VectorCopy(ent->r.currentAngles, ent->s.apos.trBase);
	VectorClear(ent->s.apos.trDelta);
	ent->s.apos.trDuration = 1;
	ent->s.apos.trType = TR_STATIONARY;
	ent->s.apos.trTime = level.time;

	//Stop thinking
	ent->reached = 0;
	if (ent->think == anglerCallback)
	{
		ent->think = 0;
	}

	//link
	trap->LinkEntity((sharedEntity_t*)ent);
}

void MatchTeam(gentity_t* team_leader, int mover_state, int time);
void Blocked_Mover(gentity_t* ent, gentity_t* other);

/*
=============
moverCallback

Utility function
=============
*/
void moverCallback(gentity_t* ent)
{
	//complete the task
	trap->ICARUS_TaskIDComplete((sharedEntity_t*)ent, TID_MOVE_NAV);

	// play sound
	ent->s.loopSound = 0; //stop looping sound
	ent->s.loopIsSoundset = qfalse;
	G_PlayDoorSound(ent, BMS_END); //play end sound

	if (ent->moverState == MOVER_1TO2)
	{
		//reached open
		// reached pos2
		MatchTeam(ent, MOVER_POS2, level.time);
	}
	else if (ent->moverState == MOVER_2TO1)
	{
		//reached closed
		MatchTeam(ent, MOVER_POS1, level.time);
	}

	if (ent->blocked == Blocked_Mover)
	{
		ent->blocked = 0;
	}
}

void Blocked_Mover(gentity_t* ent, gentity_t* other)
{
	// remove anything other than a client -- no longer the case

	// don't remove security keys or goodie keys
	if (other->s.eType == ET_ITEM)
	{
		// should we be doing anything special if a key blocks it... move it somehow..?
	}
	// if your not a client, or your a dead client remove yourself...
	else if (other->s.number && (!other->client || other->client && other->health <= 0 && other->r.contents ==
		CONTENTS_CORPSE && !other->message))
	{
		//if ( !other->task_manager || !other->task_manager->IsRunning() )
		{
			// if an item or weapon can we do a little explosion..?
			G_FreeEntity(other);
			return;
		}
	}

	if (ent->damage)
	{
		G_Damage(other, ent, ent, NULL, NULL, ent->damage, 0, MOD_CRUSH);
	}
}

/*
=============
moveAndRotateCallback

Utility function
=============
*/
void moveAndRotateCallback(gentity_t* ent)
{
	//stop turning
	anglerCallback(ent);
	//stop moving
	moverCallback(ent);
}

/*
=============
Q3_Lerp2Start

Lerps the origin of an entity to its starting position
=============
*/
void Q3_Lerp2Start(const int entID, const int taskID, const float duration)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Lerp2Start: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_Lerp2Start: ent %d is NOT a mover!\n", entID);
		return;
	}

	if (ent->s.eType != ET_MOVER)
	{
		ent->s.eType = ET_MOVER;
	}

	//FIXME: set up correctly!!!
	ent->moverState = MOVER_2TO1;
	ent->s.eType = ET_MOVER;
	ent->reached = moverCallback; //Callsback the the completion of the move
	if (ent->damage)
	{
		ent->blocked = Blocked_Mover;
	}

	ent->s.pos.trDuration = duration * 10; //In seconds
	ent->s.pos.trTime = level.time;

	trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
	// starting sound
	G_PlayDoorLoopSound(ent);
	G_PlayDoorSound(ent, BMS_START); //??

	trap->LinkEntity((sharedEntity_t*)ent);
}

/*
=============
Q3_Lerp2End

Lerps the origin of an entity to its ending position
=============
*/
void Q3_Lerp2End(const int entID, const int taskID, const float duration)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Lerp2End: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_Lerp2End: ent %d is NOT a mover!\n", entID);
		return;
	}

	if (ent->s.eType != ET_MOVER)
	{
		ent->s.eType = ET_MOVER;
	}

	//FIXME: set up correctly!!!
	ent->moverState = MOVER_1TO2;
	ent->s.eType = ET_MOVER;
	ent->reached = moverCallback; //Callsback the the completion of the move
	if (ent->damage)
	{
		ent->blocked = Blocked_Mover;
	}

	ent->s.pos.trDuration = duration * 10; //In seconds
	ent->s.time = level.time;

	trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
	// starting sound
	G_PlayDoorLoopSound(ent);
	G_PlayDoorSound(ent, BMS_START); //??

	trap->LinkEntity((sharedEntity_t*)ent);
}

void InitMoverTrData(gentity_t* ent);

/*
=============
Q3_Lerp2Pos

Lerps the origin and angles of an entity to the destination values

=============
*/
void Q3_Lerp2Pos(const int taskID, const int entID, vec3_t origin, vec3_t angles, float duration)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Lerp2Pos: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_Lerp2Pos: ent %d is NOT a mover!\n", entID);
		return;
	}

	if (ent->s.eType != ET_MOVER)
	{
		ent->s.eType = ET_MOVER;
	}

	//Don't allow a zero duration
	if (duration == 0)
		duration = 1;

	//
	// Movement

	moverState_t moverState = ent->moverState;

	if (moverState == MOVER_POS1 || moverState == MOVER_2TO1)
	{
		VectorCopy(ent->r.currentOrigin, ent->pos1);
		VectorCopy(origin, ent->pos2);

		moverState = MOVER_1TO2;
	}
	else
	{
		VectorCopy(ent->r.currentOrigin, ent->pos2);
		VectorCopy(origin, ent->pos1);

		moverState = MOVER_2TO1;
	}

	InitMoverTrData(ent);

	ent->s.pos.trDuration = duration;

	// start it going
	MatchTeam(ent, moverState, level.time);

	//Only do the angles if specified
	if (angles != NULL)
	{
		vec3_t ang;
		//
		// Rotation

		for (int i = 0; i < 3; i++)
		{
			ang[i] = AngleDelta(angles[i], ent->r.currentAngles[i]);
			ent->s.apos.trDelta[i] = ang[i] / (duration * 0.001f);
		}

		VectorCopy(ent->r.currentAngles, ent->s.apos.trBase);

		if (ent->alt_fire)
		{
			ent->s.apos.trType = TR_LINEAR_STOP;
		}
		else
		{
			ent->s.apos.trType = TR_NONLINEAR_STOP;
		}
		ent->s.apos.trDuration = duration;

		ent->s.apos.trTime = level.time;

		ent->reached = moveAndRotateCallback;
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANGLE_FACE, taskID);
	}
	else
	{
		//Setup the last bits of information
		ent->reached = moverCallback;
	}

	if (ent->damage)
	{
		ent->blocked = Blocked_Mover;
	}

	trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
	// starting sound
	G_PlayDoorLoopSound(ent);
	G_PlayDoorSound(ent, BMS_START);

	trap->LinkEntity((sharedEntity_t*)ent);
}

/*
=============
Q3_LerpAngles

Lerps the angles to the destination value
=============
*/
void Q3_Lerp2Angles(const int taskID, const int entID, vec3_t angles, const float duration)
{
	gentity_t* ent = &g_entities[entID];
	vec3_t ang;

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Lerp2Angles: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_Lerp2Angles: ent %d is NOT a mover!\n", entID);
		return;
	}

	//If we want an instant move, don't send 0...
	ent->s.apos.trDuration = duration > 0 ? duration : 1;

	for (int i = 0; i < 3; i++)
	{
		ang[i] = AngleSubtract(angles[i], ent->r.currentAngles[i]);
		ent->s.apos.trDelta[i] = ang[i] / (ent->s.apos.trDuration * 0.001f);
	}

	VectorCopy(ent->r.currentAngles, ent->s.apos.trBase);

	if (ent->alt_fire)
	{
		ent->s.apos.trType = TR_LINEAR_STOP;
	}
	else
	{
		ent->s.apos.trType = TR_NONLINEAR_STOP;
	}

	ent->s.apos.trTime = level.time;

	trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANGLE_FACE, taskID);

	ent->think = anglerCallback;
	ent->nextthink = level.time + duration;

	trap->LinkEntity((sharedEntity_t*)ent);
}

/*
=============
Q3_GetTag

Gets the value of a tag by the give name
=============
*/
int Q3_GetTag(const int entID, const char* name, const int lookup, vec3_t info)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent->inuse)
	{
		assert(0);
		return 0;
	}

	switch (lookup)
	{
	case TYPE_ORIGIN:
		return TAG_GetOrigin(ent->ownername, name, info);

	case TYPE_ANGLES:
		return TAG_GetAngles(ent->ownername, name, info);
	default:;
	}

	return 0;
}

//-----------------------------------------------

/*
============
Q3_Use

Uses an entity
============
*/
void Q3_Use(const int entID, const char* target)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Use: invalid entID %d\n", entID);
		return;
	}

	if (!target || !target[0])
	{
		G_DebugPrint(WL_WARNING, "Q3_Use: string is NULL!\n");
		return;
	}

	G_UseTargets2(ent, ent, target);
}

/*
============
Q3_Kill
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: const char *name
============
*/
void Q3_Kill(const int entID, const char* name)
{
	gentity_t* ent = &g_entities[entID];
	gentity_t* victim;

	if (!Q_stricmp(name, "self"))
	{
		victim = ent;
	}
	else if (!Q_stricmp(name, "enemy"))
	{
		victim = ent->enemy;
	}
	else
	{
		victim = G_Find(NULL, FOFS(targetname), (char*)name);
	}

	if (!victim)
	{
		G_DebugPrint(WL_WARNING, "Q3_Kill: can't find %s\n", name);
		return;
	}

	const int o_health = victim->health;
	victim->health = 0;
	if (victim->client)
	{
		victim->flags |= FL_NO_KNOCKBACK;
	}
	if (victim->die != NULL) // check can be omitted
	{
		victim->die(victim, victim, victim, o_health, MOD_UNKNOWN);
	}
}

/*
============
Q3_RemoveEnt
  Description	:
  Return type	: void
  Argument		: sharedEntity_t *victim
============
*/
static void Q3_RemoveEnt(gentity_t* victim)
{
	if (!victim || !victim->inuse)
	{
		return;
	}
	if (victim->client)
	{
		if (victim->client->NPC_class == CLASS_VEHICLE)
		{
			//eject everyone out of a vehicle that's about to remove itself
			Vehicle_t* p_veh = victim->m_pVehicle;
			if (p_veh && p_veh->m_pVehicleInfo)
			{
				p_veh->m_pVehicleInfo->EjectAll(p_veh);
			}
		}
		victim->s.eFlags |= EF_NODRAW;
		victim->s.eType = ET_INVISIBLE;
		victim->r.contents = 0;
		victim->health = 0;
		victim->targetname = NULL;

		if (victim->NPC && victim->NPC->tempGoal != NULL)
		{
			G_FreeEntity(victim->NPC->tempGoal);
			victim->NPC->tempGoal = NULL;
		}
		if (victim->client->ps.saberEntityNum != ENTITYNUM_NONE && victim->client->ps.saberEntityNum > 0)
		{
			if (g_entities[victim->client->ps.saberEntityNum].inuse)
			{
				G_FreeEntity(&g_entities[victim->client->ps.saberEntityNum]);
			}
			victim->client->ps.saberEntityNum = ENTITYNUM_NONE;
		}
		//Disappear in half a second
		victim->think = G_FreeEntity;
		victim->nextthink = level.time + 500;
		return;
	}
	victim->think = G_FreeEntity;
	victim->nextthink = level.time + 100;
}

/*
============
Q3_Remove
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: const char *name
============
*/
void Q3_Remove(const int entID, const char* name)
{
	gentity_t* ent = &g_entities[entID];
	gentity_t* victim;

	if (!Q_stricmp("self", name))
	{
		victim = ent;
		if (!victim)
		{
			G_DebugPrint(WL_WARNING, "Q3_Remove: can't find %s\n", name);
			return;
		}
		Q3_RemoveEnt(victim);
	}
	else if (!Q_stricmp("enemy", name))
	{
		victim = ent->enemy;
		if (!victim)
		{
			G_DebugPrint(WL_WARNING, "Q3_Remove: can't find %s\n", name);
			return;
		}
		Q3_RemoveEnt(victim);
	}
	else
	{
		victim = G_Find(NULL, FOFS(targetname), (char*)name);
		if (!victim)
		{
			G_DebugPrint(WL_WARNING, "Q3_Remove: can't find %s\n", name);
			return;
		}

		while (victim)
		{
			Q3_RemoveEnt(victim);
			victim = G_Find(victim, FOFS(targetname), (char*)name);
		}
	}
}

/*
=================================================

  Get / Set Functions

=================================================
*/

/*
============
Q3_GetFloat
  Description	:
  Return type	: int
  Argument		:  int entID
  Argument		: int type
  Argument		: const char *name
  Argument		: float *value
============
*/
int Q3_GetFloat(const int entID, int type, const char* name, float* value)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		return 0;
	}

	const int toGet = GetIDForString(setTable, name); //FIXME: May want to make a "getTable" as well
	//FIXME: I'm getting really sick of these huge switch statements!

	//NOTENOTE: return true if the value was correctly obtained
	switch (toGet)
	{
	case SET_PARM1:
	case SET_PARM2:
	case SET_PARM3:
	case SET_PARM4:
	case SET_PARM5:
	case SET_PARM6:
	case SET_PARM7:
	case SET_PARM8:
	case SET_PARM9:
	case SET_PARM10:
	case SET_PARM11:
	case SET_PARM12:
	case SET_PARM13:
	case SET_PARM14:
	case SET_PARM15:
	case SET_PARM16:
		if (ent->parms == NULL)
		{
			G_DebugPrint(WL_ERROR, "GET_PARM: %s %s did not have any parms set!\n", ent->classname, ent->targetname);
			return 0; // would prefer qfalse, but I'm fitting in with what's here <sigh>
		}
		*value = atof(ent->parms->parm[toGet - SET_PARM1]);
		break;

	case SET_COUNT:
		*value = ent->count;
		break;

	case SET_HEALTH:
		*value = ent->health;
		break;

	case SET_SKILL:
		*value = g_npcspskill.integer;
		break;

	case SET_XVELOCITY: //## %f="0.0" # Velocity along X axis
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_XVELOCITY, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.velocity[0];
		break;

	case SET_YVELOCITY: //## %f="0.0" # Velocity along Y axis
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_YVELOCITY, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.velocity[1];
		break;

	case SET_ZVELOCITY: //## %f="0.0" # Velocity along Z axis
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_ZVELOCITY, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.velocity[2];
		break;

	case SET_Z_OFFSET:
		*value = ent->r.currentOrigin[2] - ent->s.origin[2];
		break;

	case SET_DPITCH: //## %f="0.0" # Pitch for NPC to turn to
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_DPITCH, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->desiredPitch;
		break;

	case SET_DYAW: //## %f="0.0" # Yaw for NPC to turn to
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_DYAW, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->desiredPitch;
		break;

	case SET_WIDTH: //## %f="0.0" # Width of NPC bounding box
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_WIDTH, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->r.mins[0];
		break;
	case SET_TIMESCALE: //## %f="0.0" # Speed-up slow down game (0 - 1.0)
		return 0;
	case SET_CAMERA_GROUP_Z_OFS: //## %s="NULL" # all ents with this cameraGroup will be focused on
		return 0;

	case SET_VISRANGE: //## %f="0.0" # How far away NPC can see
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_VISRANGE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.visrange;
		break;

	case SET_EARSHOT: //## %f="0.0" # How far an NPC can hear
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_EARSHOT, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.earshot;
		break;

	case SET_VIGILANCE: //## %f="0.0" # How often to look for enemies (0 - 1.0)
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_VIGILANCE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.vigilance;
		break;

	case SET_GRAVITY: //## %f="0.0" # Change this ent's gravity - 800 default
		if (ent->r.svFlags & SVF_CUSTOM_GRAVITY && ent->client)
		{
			*value = ent->client->ps.gravity;
		}
		else
		{
			*value = g_gravity.value;
		}
		break;

	case SET_FACEEYESCLOSED:
	case SET_FACEEYESOPENED:
	case SET_FACEAUX: //## %f="0.0" # Set face to Aux expression for number of seconds
	case SET_FACEBLINK: //## %f="0.0" # Set face to Blink expression for number of seconds
	case SET_FACEBLINKFROWN: //## %f="0.0" # Set face to Blinkfrown expression for number of seconds
	case SET_FACEFROWN: //## %f="0.0" # Set face to Frown expression for number of seconds
	case SET_FACESMILE: //## %f="0.0" # Set face to Smile expression for number of seconds
	case SET_FACEGLAD: //## %f="0.0" # Set face to Glad expression for number of seconds
	case SET_FACEHAPPY: //## %f="0.0" # Set face to Happy expression for number of seconds
	case SET_FACESHOCKED: //## %f="0.0" # Set face to Shocked expression for number of seconds
	case SET_FACENORMAL: //## %f="0.0" # Set face to Normal expression for number of seconds
		G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_FACE___ not implemented\n");
		return 0;
	case SET_WAIT: //## %f="0.0" # Change an entity's wait field
		*value = ent->wait;
		break;
	case SET_FOLLOWDIST: //## %f="0.0" # How far away to stay from leader in BS_FOLLOW_LEADER
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_FOLLOWDIST, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->followDist;
		break;
		//# #sep ints
	case SET_ANIM_HOLDTIME_LOWER: //## %d="0" # Hold lower anim for number of milliseconds
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_ANIM_HOLDTIME_LOWER, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.legsTimer;
		break;
	case SET_ANIM_HOLDTIME_UPPER: //## %d="0" # Hold upper anim for number of milliseconds
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_ANIM_HOLDTIME_UPPER, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.torsoTimer;
		break;
	case SET_ANIM_HOLDTIME_BOTH: //## %d="0" # Hold lower and upper anims for number of milliseconds
		G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_ANIM_HOLDTIME_BOTH not implemented\n");
		return 0;
	case SET_ARMOR: //## %d="0" # Change armor
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_ARMOR, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.stats[STAT_ARMOR];
		break;
	case SET_WALKSPEED: //## %d="0" # Change walkSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_WALKSPEED, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.walkSpeed;
		break;
	case SET_RUNSPEED: //## %d="0" # Change runSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_RUNSPEED, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.runSpeed;
		break;
	case SET_YAWSPEED: //## %d="0" # Change yawSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_YAWSPEED, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.yawSpeed;
		break;
	case SET_AGGRESSION: //## %d="0" # Change aggression 1-5
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_AGGRESSION, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.aggression;
		break;
	case SET_AIM: //## %d="0" # Change aim 1-5
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_AIM, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.aim;
		break;
	case SET_FRICTION: //## %d="0" # Change ent's friction - 6 default
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_FRICTION, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->ps.friction;
		break;
	case SET_SHOOTDIST: //## %d="0" # How far the ent can shoot - 0 uses weapon
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_SHOOTDIST, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.shootDistance;
		break;
	case SET_HFOV: //## %d="0" # Horizontal field of view
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_HFOV, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.hfov;
		break;
	case SET_VFOV: //## %d="0" # Vertical field of view
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_VFOV, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->stats.vfov;
		break;
	case SET_DELAYSCRIPTTIME: //## %d="0" # How many seconds to wait before running delayscript
		*value = ent->delayScriptTime - level.time;
		break;
	case SET_FORWARDMOVE: //## %d="0" # NPC move forward -127(back) to 127
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_FORWARDMOVE, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->forced_forwardmove;
		break;
	case SET_RIGHTMOVE: //## %d="0" # NPC move right -127(left) to 127
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_RIGHTMOVE, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = ent->client->forced_rightmove;
		break;
	case SET_STARTFRAME: //## %d="0" # frame to start animation sequence on
		*value = ent->startFrame;
		break;
	case SET_ENDFRAME: //## %d="0" # frame to end animation sequence on
		*value = ent->endFrame;
		break;
	case SET_ANIMFRAME: //## %d="0" # of current frame
		*value = ent->s.frame;
		break;

	case SET_SHOT_SPACING: //## %d="1000" # Time between shots for an NPC - reset to defaults when changes weapon
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_SHOT_SPACING, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->burstSpacing;
		break;
	case SET_MISSIONSTATUSTIME: //## %d="0" # Amount of time until Mission Status should be shown after death
		return 0;
		//# #sep booleans
	case SET_IGNOREPAIN: //## %t="BOOL_TYPES" # Do not react to pain
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_IGNOREPAIN, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->ignorePain;
		break;
	case SET_IGNOREENEMIES: //## %t="BOOL_TYPES" # Do not acquire enemies
		*value = ent->r.svFlags & SVF_IGNORE_ENEMIES;
		break;
	case SET_IGNOREALERTS: //## Do not get enemy set by allies in area(ambush)
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_IGNOREALERTS, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_IGNORE_ALERTS;
		break;
	case SET_DONTSHOOT: //## %t="BOOL_TYPES" # Others won't shoot you
		*value = ent->flags & FL_DONT_SHOOT;
		break;
	case SET_NOTARGET: //## %t="BOOL_TYPES" # Others won't pick you as enemy
		*value = ent->flags & FL_NOTARGET;
		break;
	case SET_DONTFIRE: //## %t="BOOL_TYPES" # Don't fire your weapon
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_DONTFIRE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_DONT_FIRE;
		break;

	case SET_LOCKED_ENEMY: //## %t="BOOL_TYPES" # Keep current enemy until dead
		*value = ent->r.svFlags & SVF_LOCKEDENEMY;
		break;
	case SET_CROUCHED: //## %t="BOOL_TYPES" # Force NPC to crouch
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_CROUCHED, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_CROUCHED;
		break;
	case SET_WALKING: //## %t="BOOL_TYPES" # Force NPC to move at walkSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_WALKING, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_WALKING;
		break;
	case SET_RUNNING: //## %t="BOOL_TYPES" # Force NPC to move at runSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_RUNNING, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_RUNNING;
		break;
	case SET_CHASE_ENEMIES: //## %t="BOOL_TYPES" # NPC will chase after enemies
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_CHASE_ENEMIES, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_CHASE_ENEMIES;
		break;
	case SET_LOOK_FOR_ENEMIES: //## %t="BOOL_TYPES" # NPC will be on the lookout for enemies
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_LOOK_FOR_ENEMIES, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_LOOK_FOR_ENEMIES;
		break;
	case SET_FACE_MOVE_DIR: //## %t="BOOL_TYPES" # NPC will face in the direction it's moving
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_FACE_MOVE_DIR, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_FACE_MOVE_DIR;
		break;
	case SET_FORCED_MARCH: //## %t="BOOL_TYPES" # Force NPC to move at runSpeed
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_FORCED_MARCH, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SET_FORCED_MARCH;
		break;
	case SET_UNDYING: //## %t="BOOL_TYPES" # Can take damage down to 1 but not die
		*value = ent->flags & FL_UNDYING;
		break;
	case SET_NOAVOID: //## %t="BOOL_TYPES" # Will not avoid other NPCs or architecture
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NOAVOID, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->aiFlags & NPCAI_NO_COLL_AVOID;
		break;

	case SET_SOLID: //## %t="BOOL_TYPES" # Make yourself notsolid or solid
		*value = ent->r.contents;
		break;
	case SET_PLAYER_USABLE: //## %t="BOOL_TYPES" # Can be activateby the player's "use" button
		*value = ent->r.svFlags & SVF_PLAYER_USABLE;
		break;
	case SET_LOOP_ANIM: //## %t="BOOL_TYPES" # For non-NPCs: loop your animation sequence
		*value = ent->loopAnim;
		break;
	case SET_INTERFACE: //## %t="BOOL_TYPES" # Player interface on/off
		G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_INTERFACE not implemented\n");
		return 0;
	case SET_SHIELDS: //## %t="BOOL_TYPES" # NPC has no shields (Borg do not adapt)
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_SHIELDS, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->aiFlags & NPCAI_SHIELDS;
		break;
	case SET_INVISIBLE: //## %t="BOOL_TYPES" # Makes an NPC not solid and not visible
		*value = ent->s.eFlags & EF_NODRAW;
		break;
	case SET_VAMPIRE: //## %t="BOOL_TYPES" # Makes an NPC not solid and not visible
	{
		if (!ent->client)
		{
			return 0;
		}
		*value = ent->client->ps.powerups[PW_DISINT_4] > level.time;
	}
	break;
	case SET_FORCE_INVINCIBLE: //## %t="BOOL_TYPES" # Makes an NPC not solid and not visible
	{
		if (!ent->client)
		{
			return 0;
		}
		*value = ent->client->ps.powerups[PW_INVINCIBLE] > level.time;
	}
	break;
	case SET_GREET_ALLIES: //## %t="BOOL_TYPES" # Makes an NPC greet teammates
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_GREET_ALLIES, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->aiFlags & NPCAI_GREET_ALLIES;
		break;
	case SET_VIDEO_FADE_IN: //## %t="BOOL_TYPES" # Makes video playback fade in
		G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_VIDEO_FADE_IN not implemented\n");
		return 0;
	case SET_VIDEO_FADE_OUT: //## %t="BOOL_TYPES" # Makes video playback fade out
		G_DebugPrint(WL_WARNING, "Q3_GetFloat: SET_VIDEO_FADE_OUT not implemented\n");
		return 0;
	case SET_PLAYER_LOCKED: //## %t="BOOL_TYPES" # Makes it so player cannot move
		*value = player_locked;
		break;
	case SET_LOCK_PLAYER_WEAPONS: //## %t="BOOL_TYPES" # Makes it so player cannot switch weapons
		*value = ent->flags & FL_LOCK_PLAYER_WEAPONS;
		break;
	case SET_NO_IMPACT_DAMAGE: //## %t="BOOL_TYPES" # Makes it so player cannot switch weapons
		*value = ent->flags & FL_NO_IMPACT_DMG;
		break;
	case SET_NO_KNOCKBACK: //## %t="BOOL_TYPES" # Stops this ent from taking knockback from weapons
		*value = ent->flags & FL_NO_KNOCKBACK;
		break;
	case SET_altFire: //## %t="BOOL_TYPES" # Force NPC to use altfire when shooting
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_altFire, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_altFire;
		break;
	case SET_NO_RESPONSE:
		//## %t="BOOL_TYPES" # NPCs will do generic responses when this is on (usescripts override generic responses as well)
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_RESPONSE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_RESPONSE;
		break;
	case SET_INVINCIBLE: //## %t="BOOL_TYPES" # Completely unkillable
		*value = ent->flags & FL_GODMODE;
		break;
	case SET_MISSIONSTATUSACTIVE: //# Turns on Mission Status Screen
		return 0;
	case SET_NO_COMBAT_TALK: //## %t="BOOL_TYPES" # NPCs will not do their combat talking noises when this is on
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_COMBAT_TALK, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_COMBAT_TALK;
		break;
	case SET_NO_ALERT_TALK: //## %t="BOOL_TYPES" # NPCs will not do their combat talking noises when this is on
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_ALERT_TALK, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_ALERT_TALK;
		break;
	case SET_USE_CP_NEAREST:
		//## %t="BOOL_TYPES" # NPCs will use their closest combat points, not try and find ones next to the player, or flank player
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_USE_CP_NEAREST, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_USE_CP_NEAREST;
		break;
	case SET_DISMEMBERABLE: //## %t="BOOL_TYPES" # NPC will not be affected by force powers
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_DISMEMBERABLE, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = !ent->client->dismembered;
		break;
	case SET_NO_FORCE:
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_FORCE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_FORCE;
		break;
	case SET_NO_ACROBATICS:
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_ACROBATICS, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_ACROBATICS;
		break;
	case SET_USE_SUBTITLES:
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_USE_SUBTITLES, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_USE_SUBTITLES;
		break;
	case SET_NO_FALLTODEATH: //## %t="BOOL_TYPES" # NPC will not be affected by force powers
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_NO_FALLTODEATH, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_NO_FALLTODEATH;
		break;
	case SET_MORELIGHT:
		//## %t="BOOL_TYPES" # NPCs will use their closest combat points, not try and find ones next to the player, or flank player
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetFloat: SET_MORELIGHT, %s not an NPC\n", ent->targetname);
			return 0;
		}
		*value = ent->NPC->scriptFlags & SCF_MORELIGHT;
		break;
	case SET_TREASONED:
		//## %t="BOOL_TYPES" # Player has turned on his own- scripts will stop: NPCs will turn on him and level changes load the brig
		G_DebugPrint(WL_VERBOSE, "SET_TREASONED is disabled, do not use\n");
		*value = 0;
		break;
	case SET_DISABLE_SHADER_ANIM: //## %t="BOOL_TYPES" # Shaders won't animate
		*value = ent->s.eFlags & EF_DISABLE_SHADER_ANIM;
		break;
	case SET_SHADER_ANIM: //## %t="BOOL_TYPES" # Shader will be under frame control
		*value = ent->s.eFlags & EF_SHADER_ANIM;
		break;
	case SET_OBJECTIVE_LIGHTSIDE:
		return 0;

	default:
		/*if (trap->ICARUS_VariableDeclared(name) != VTYPE_FLOAT)
			return 0;

		return trap->ICARUS_GetFloatVariable(name, value);*/
		return GetFloatDeclaredVariable(name, value);
	}

	return 1;
}

/*
============
Q3_GetVector
  Description	:
  Return type	: int
  Argument		:  int entID
  Argument		: int type
  Argument		: const char *name
  Argument		: vec3_t value
============
*/
int Q3_GetVector(const int entID, int type, const char* name, vec3_t value)
{
	const gentity_t* ent = &g_entities[entID];
	if (!ent)
	{
		return 0;
	}

	const int toGet = GetIDForString(setTable, name); //FIXME: May want to make a "getTable" as well
	//FIXME: I'm getting really sick of these huge switch statements!

	//NOTENOTE: return true if the value was correctly obtained
	switch (toGet)
	{
	case SET_PARM1:
	case SET_PARM2:
	case SET_PARM3:
	case SET_PARM4:
	case SET_PARM5:
	case SET_PARM6:
	case SET_PARM7:
	case SET_PARM8:
	case SET_PARM9:
	case SET_PARM10:
	case SET_PARM11:
	case SET_PARM12:
	case SET_PARM13:
	case SET_PARM14:
	case SET_PARM15:
	case SET_PARM16:
		if (sscanf(ent->parms->parm[toGet - SET_PARM1], "%f %f %f", &value[0], &value[1], &value[2]) != 3)
		{
			G_DebugPrint(WL_WARNING, "Q3_GetVector: failed sscanf on SET_PARM%d (%s)\n", toGet, name);
			VectorClear(value);
		}
		break;

	case SET_ORIGIN:
		VectorCopy(ent->r.currentOrigin, value);
		break;

	case SET_ANGLES:
		VectorCopy(ent->r.currentAngles, value);
		break;

	case SET_TELEPORT_DEST: //## %v="0.0 0.0 0.0" # Set origin here as soon as the area is clear
		G_DebugPrint(WL_WARNING, "Q3_GetVector: SET_TELEPORT_DEST not implemented\n");
		return 0;

	default:

		/*if (trap->ICARUS_VariableDeclared(name) != VTYPE_VECTOR)
			return 0;

		return trap->ICARUS_GetVectorVariable(name, value);*/
		return GetVectorDeclaredVariable(name, value);
	}

	return 1;
}

/*
============
Q3_GetString
  Description	:
  Return type	: int
  Argument		:  int entID
  Argument		: int type
  Argument		: const char *name
  Argument		: char **value
============
*/
char* G_GetLocationForEnt(const gentity_t* self);

int Q3_GetString(const int entID, int type, const char* name, char** value)
{
	const gentity_t* ent = &g_entities[entID];
	if (!ent)
	{
		return 0;
	}

	const int toGet = GetIDForString(setTable, name); //FIXME: May want to make a "getTable" as well

	switch (toGet)
	{
	case SET_ANIM_BOTH:
		*value = Q3_GetAnimBoth(ent);

		if (!value || !value[0])
			return 0;

		break;

	case SET_PARM1:
	case SET_PARM2:
	case SET_PARM3:
	case SET_PARM4:
	case SET_PARM5:
	case SET_PARM6:
	case SET_PARM7:
	case SET_PARM8:
	case SET_PARM9:
	case SET_PARM10:
	case SET_PARM11:
	case SET_PARM12:
	case SET_PARM13:
	case SET_PARM14:
	case SET_PARM15:
	case SET_PARM16:
		if (ent->parms)
		{
			*value = (char*)ent->parms->parm[toGet - SET_PARM1];
		}
		else
		{
			G_DebugPrint(WL_WARNING, "Q3_GetString: invalid ent %s has no parms!\n", ent->targetname);
			return 0;
		}
		break;

	case SET_TARGET:
		*value = ent->target;
		break;

	case SET_LOCATION:
		*value = G_GetLocationForEnt(ent);
		if (!value || !value[0])
		{
			return qfalse;
		}
		break;

		//# #sep Scripts and other file paths
	case SET_SPAWNSCRIPT:
		//## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when spawned //0 - do not change these, these are equal to BSET_SPAWN, etc
		*value = ent->behaviorSet[BSET_SPAWN];
		break;
	case SET_USESCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when used
		*value = ent->behaviorSet[BSET_USE];
		break;
	case SET_AWAKESCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when startled
		*value = ent->behaviorSet[BSET_AWAKE];
		break;
	case SET_ANGERSCRIPT:
		//## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script run when find an enemy for the first time
		*value = ent->behaviorSet[BSET_ANGER];
		break;
	case SET_ATTACKSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when you shoot
		*value = ent->behaviorSet[BSET_ATTACK];
		break;
	case SET_VICTORYSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when killed someone
		*value = ent->behaviorSet[BSET_VICTORY];
		break;
	case SET_LOSTENEMYSCRIPT:
		//## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when you can't find your enemy
		*value = ent->behaviorSet[BSET_LOSTENEMY];
		break;
	case SET_PAINSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when hit
		*value = ent->behaviorSet[BSET_PAIN];
		break;
	case SET_FLEESCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when hit and low health
		*value = ent->behaviorSet[BSET_FLEE];
		break;
	case SET_DEATHSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when killed
		*value = ent->behaviorSet[BSET_DEATH];
		break;
	case SET_DELAYEDSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run after a delay
		*value = ent->behaviorSet[BSET_DELAYED];
		break;
	case SET_BLOCKEDSCRIPT: //## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when blocked by teammate
		*value = ent->behaviorSet[BSET_BLOCKED];
		break;
	case SET_FFIRESCRIPT:
		//## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when player has shot own team repeatedly
		*value = ent->behaviorSet[BSET_FFIRE];
		break;
	case SET_FFDEATHSCRIPT:
		//## %s="NULL" !!"W:\game\base\scripts\!!#*.txt" # Script to run when player kills a teammate
		*value = ent->behaviorSet[BSET_FFDEATH];
		break;

		//# #sep Standard strings
	case SET_ENEMY: //## %s="NULL" # Set enemy by targetname
		if (ent->enemy != NULL)
		{
			*value = ent->enemy->targetname;
		}
		else return 0;
		break;
	case SET_LEADER: //## %s="NULL" # Set for BS_FOLLOW_LEADER
	{
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_LEADER, %s not a client\n", ent->targetname);
			return 0;
		}
		if (ent->client->leader)
		{
			*value = ent->client->leader->targetname;
		}
		else return 0;
	}
	break;
	case SET_CAPTURE: //## %s="NULL" # Set captureGoal by targetname
	{
		if (ent->NPC == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_CAPTURE, %s not an NPC\n", ent->targetname);
			return 0;
		}
		if (ent->NPC->captureGoal != NULL)
		{
			*value = ent->NPC->captureGoal->targetname;
		}
		else return 0;
	}
	break;

	case SET_TARGETNAME: //## %s="NULL" # Set/change your targetname
		*value = ent->targetname;
		break;
	case SET_PAINTARGET: //## %s="NULL" # Set/change what to use when hit
		*value = ent->paintarget;
		break;
	case SET_CAMERA_GROUP: //## %s="NULL" # all ents with this cameraGroup will be focused on
		*value = ent->cameraGroup;
		break;
	case SET_CAMERA_GROUP_TAG: //## %s="NULL" # all ents with this cameraGroup will be focused on
		return 0;
	case SET_LOOK_TARGET: //## %s="NULL" # object for NPC to look at
	{
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_LOOK_TARGET, %s not a client\n", ent->targetname);
			return qfalse;
		}
		const gentity_t* lookTarg = &g_entities[ent->client->renderInfo.lookTarget];
		if (lookTarg != NULL)
		{
			*value = lookTarg->targetname;
		}
		else return qfalse;
	}
	break;
	case SET_TARGET2:
		//## %s="NULL" # Set/change your target2: on NPC's: this fires when they're knocked out by the red hypo
		*value = ent->target2;
		break;

	case SET_REMOVE_TARGET: //## %s="NULL" # Target that is fired when someone completes the BS_REMOVE behaviorState
		*value = ent->target3;
		break;
	case SET_WEAPON:
	{
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_WEAPON, %s not a client\n", ent->targetname);
			return 0;
		}
		*value = (char*)GetStringForID(WPTable, ent->client->ps.weapon);
	}
	break;

	case SET_ITEM:
	{
		if (ent->client == NULL)
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_ITEM, %s not a client\n", ent->targetname);
			return 0;
		}
		//	*value = (char *)GetStringForID( WPTable, ent->client->ps.weapon );
	}
	break;
	case SET_MUSIC_STATE:
		return 0;
		//The below cannot be gotten
	case SET_NAVGOAL: //## %s="NULL" # *Move to this navgoal then continue script
		if (!ent->NPC)
			return 0;

		if (!ent->NPC->goalEntity)
			return 0;

		if (!ent->NPC->goalEntity->targetname)
			return 0;

		if (!ent->NPC->goalEntity->targetname[0])
			return 0;

		*value = ent->NPC->goalEntity->targetname;
		break;
	case SET_VIEWTARGET: //## %s="NULL" # Set angles toward ent by targetname
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_VIEWTARGET not implemented\n");
		return 0;
	case SET_WATCHTARGET: //## %s="NULL" # Set angles toward ent by targetname
		if (ent && ent->NPC && ent->NPC->watchTarget)
		{
			*value = ent->NPC->watchTarget->targetname;
		}
		else
		{
			G_DebugPrint(WL_WARNING, "GetString: SET_WATCHTARGET no watchTarget!\n");
			return 0;
		}
		break;
	case SET_VIEWENTITY:
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_VIEWENTITY not implemented\n");
		return 0;
	case SET_CAPTIONTEXTCOLOR: //## %s=""  # Color of text RED:WHITE:BLUE: YELLOW
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_CAPTIONTEXTCOLOR not implemented\n");
		return 0;
	case SET_CENTERTEXTCOLOR: //## %s=""  # Color of text RED:WHITE:BLUE: YELLOW
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_CENTERTEXTCOLOR not implemented\n");
		return 0;
	case SET_SCROLLTEXTCOLOR: //## %s=""  # Color of text RED:WHITE:BLUE: YELLOW
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_SCROLLTEXTCOLOR not implemented\n");
		return 0;
	case SET_COPY_ORIGIN: //## %s="targetname"  # Copy the origin of the ent with targetname to your origin
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_COPY_ORIGIN not implemented\n");
		return 0;
	case SET_DEFEND_TARGET: //## %s="targetname"  # This NPC will attack the target NPC's enemies
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_COPY_ORIGIN not implemented\n");
		return 0;
	case SET_VIDEO_PLAY: //## %s="filename" !!"W:\game\base\video\!!#*.roq" # Play a Video (inGame)
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_VIDEO_PLAY not implemented\n");
		return 0;
	case SET_LOADGAME: //## %s="exitholodeck" # Load the savegame that was auto-saved when you started the holodeck
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_LOADGAME not implemented\n");
		return 0;
	case SET_LOCKYAW: //## %s="off"  # Lock legs to a certain yaw angle (or "off" or "auto" uses current)
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_LOCKYAW not implemented\n");
		return 0;
	case SET_SCROLLTEXT: //## %s="" # key of text string to print
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_SCROLLTEXT not implemented\n");
		return 0;
	case SET_LCARSTEXT: //## %s="" # key of text string to print in LCARS frame
		G_DebugPrint(WL_WARNING, "Q3_GetString: SET_LCARSTEXT not implemented\n");
		return 0;

	case SET_FULLNAME: //## %s="NULL" # Set/change your targetname
		*value = ent->fullName;
		break;
	default:

		/*if (trap->ICARUS_VariableDeclared(name) != VTYPE_STRING)
			return 0;

		return trap->ICARUS_GetStringVariable(name, (const char *)*value);*/
		return GetStringDeclaredVariable(name, value);
	}

	return 1;
}

/*
============
MoveOwner
  Description	:
  Return type	: void
  Argument		: sharedEntity_t *self
============
*/
qboolean spot_would_telefrag2(const gentity_t* mover, vec3_t dest);

void MoveOwner(gentity_t* self)
{
	gentity_t* owner = &g_entities[self->r.ownerNum];

	self->nextthink = level.time + FRAMETIME;
	self->think = G_FreeEntity;

	if (!owner || !owner->inuse)
	{
		return;
	}

	if (spot_would_telefrag2(owner, self->r.currentOrigin))
	{
		self->think = MoveOwner;
	}
	else
	{
		G_SetOrigin(owner, self->r.currentOrigin);
		trap->ICARUS_TaskIDComplete((sharedEntity_t*)owner, TID_MOVE_NAV);
	}
}

/*
=============
Q3_SetTeleportDest

Copies passed origin to ent running script once there is nothing there blocking the spot
=============
*/
static qboolean Q3_SetTeleportDest(const int entID, vec3_t org)
{
	gentity_t* teleEnt = &g_entities[entID];

	if (teleEnt)
	{
		if (spot_would_telefrag2(teleEnt, org))
		{
			gentity_t* teleporter = G_Spawn();

			G_SetOrigin(teleporter, org);
			teleporter->r.ownerNum = teleEnt->s.number;

			teleporter->think = MoveOwner;
			teleporter->nextthink = level.time + FRAMETIME;

			return qfalse;
		}
		G_SetOrigin(teleEnt, org);
	}

	return qtrue;
}

/*
=============
Q3_SetOrigin

Sets the origin of an entity directly
=============
*/
static void Q3_SetOrigin(const int entID, vec3_t origin)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetOrigin: bad ent %d\n", entID);
		return;
	}

	trap->UnlinkEntity((sharedEntity_t*)ent);

	if (ent->client)
	{
		VectorCopy(origin, ent->client->ps.origin);
		VectorCopy(origin, ent->r.currentOrigin);
		ent->client->ps.origin[2] += 1;

		VectorClear(ent->client->ps.velocity);
		ent->client->ps.pm_time = 160; // hold time
		ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;

		ent->client->ps.eFlags ^= EF_TELEPORT_BIT;
	}
	else
	{
		G_SetOrigin(ent, origin);
	}

	trap->LinkEntity((sharedEntity_t*)ent);
}

/*
=============
Q3_SetCopyOrigin

Copies origin of found ent into ent running script
=============`
*/
static void Q3_SetCopyOrigin(const int entID, const char* name)
{
	gentity_t* found = G_Find(NULL, FOFS(targetname), (char*)name);

	if (found)
	{
		Q3_SetOrigin(entID, found->r.currentOrigin);
		SetClientViewAngle(&g_entities[entID], found->s.angles);
	}
	else
	{
		G_DebugPrint(WL_WARNING, "Q3_SetCopyOrigin: ent %s not found!\n", name);
	}
}

/*
=============
Q3_SetVelocity

Set the velocity of an entity directly
=============
*/
static void Q3_SetVelocity(const int entID, const int axis, const float speed)
{
	const gentity_t* found = &g_entities[entID];
	//FIXME: Not supported
	if (!found)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetVelocity invalid entID %d\n", entID);
		return;
	}

	if (!found->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetVelocity: not a client %d\n", entID);
		return;
	}

	//FIXME: add or set?
	found->client->ps.velocity[axis] += speed;

	found->client->ps.pm_time = 500;
	found->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
}

/*
=============
Q3_SetAngles

Sets the angles of an entity directly
=============
*/
void UpdatePlayerCameraAngle(const gentity_t* ent, vec3_t newAngle);
static void Q3_SetDYaw(int entID, float data);

static void Q3_SetAngles(const int entID, vec3_t angles)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAngles: bad ent %d\n", entID);
		return;
	}

	if (ent->client)
	{
		SetClientViewAngle(ent, angles);
		if (in_camera && ent->s.number < MAX_CLIENTS)
		{
			//the players are currently in a cutscene.  This means that we need to change the player's stored origin.
			UpdatePlayerCameraAngle(ent, angles);
		}

		//SP Code
		if (ent->NPC)
		{
			Q3_SetDYaw(entID, angles[YAW]);
		}
	}
	else
	{
		VectorCopy(angles, ent->s.angles);
		VectorCopy(angles, ent->s.apos.trBase);
		VectorCopy(angles, ent->r.currentAngles);
	}
	trap->LinkEntity((sharedEntity_t*)ent);
}

/*
=============
Q3_Lerp2Origin

Lerps the origin to the destination value
=============
*/
void Q3_Lerp2Origin(const int taskID, const int entID, vec3_t origin, const float duration)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Lerp2Origin: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_Lerp2Origin: ent %d is NOT a mover!\n", entID);
		return;
	}

	if (ent->s.eType != ET_MOVER)
	{
		ent->s.eType = ET_MOVER;
	}

	moverState_t moverState = ent->moverState;

	if (moverState == MOVER_POS1 || moverState == MOVER_2TO1)
	{
		VectorCopy(ent->r.currentOrigin, ent->pos1);
		VectorCopy(origin, ent->pos2);

		moverState = MOVER_1TO2;
	}
	else if (moverState == MOVER_POS2 || moverState == MOVER_1TO2)
	{
		VectorCopy(ent->r.currentOrigin, ent->pos2);
		VectorCopy(origin, ent->pos1);

		moverState = MOVER_2TO1;
	}

	InitMoverTrData(ent); //FIXME: This will probably break normal things that are being moved...

	ent->s.pos.trDuration = duration;

	// start it going
	MatchTeam(ent, moverState, level.time);

	ent->reached = moverCallback;
	if (ent->damage)
	{
		ent->blocked = Blocked_Mover;
	}
	if (taskID != -1)
	{
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
	}
	// starting sound
	G_PlayDoorLoopSound(ent); //start looping sound
	G_PlayDoorSound(ent, BMS_START); //play start sound

	trap->LinkEntity((sharedEntity_t*)ent);
}

static void Q3_SetOriginOffset(const int entID, const int axis, const float offset)
{
	const gentity_t* ent = &g_entities[entID];
	vec3_t origin;

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetOriginOffset: invalid entID %d\n", entID);
		return;
	}

	if (ent->client || Q_stricmp(ent->classname, "target_scriptrunner") == 0)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetOriginOffset: ent %d is NOT a mover!\n", entID);
		return;
	}

	VectorCopy(ent->s.origin, origin);
	origin[axis] += offset;
	float duration = 0;
	if (ent->speed)
	{
		duration = fabs(offset) / fabs(ent->speed) * 1000.0f;
	}
	Q3_Lerp2Origin(-1, entID, origin, duration);
}

/*
=============
Q3_SetEnemy

Sets the enemy of an entity
=============
*/
static void Q3_SetEnemy(const int entID, const char* name)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent || !ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetEnemy: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("NONE", name) || !Q_stricmp("NULL", name))
	{
		if (ent->NPC)
		{
			G_ClearEnemy(ent);
		}
		else
		{
			ent->enemy = NULL;
		}
	}
	else
	{
		gentity_t* enemy = G_Find(NULL, FOFS(targetname), (char*)name);

		if (!Q_stricmp(name, "player") || !Q_stricmp(name, "kyle")) //old school JKO script target for "the player"
		{
			int i;
			qboolean cFound = qfalse;

			for (i = 0; i < MAX_CLIENTS; i++)
			{
				if (g_entities[i].client != NULL)
				{
					cFound = qtrue;

					if (g_entities[i].client->playerTeam == ent->client->enemyTeam && !Q_irand(0, MAX_CLIENTS / 2 - 1))
					{
						enemy = &g_entities[i];
						break;
					}
				}
			}

			if (cFound)
			{
				for (i = 0; i < MAX_CLIENTS; i++)
				{
					if (g_entities[i].client != NULL)
					{
						if (g_entities[i].client->playerTeam == ent->client->enemyTeam)
						{
							enemy = &g_entities[i];
							break;
						}
					}
				}
			}
		}
		if (enemy == NULL)
		{
			G_DebugPrint(WL_ERROR, "Q3_SetEnemy: no such enemy: '%s'\n", name);
			return;
		}
		if (ent->NPC)
		{
			G_SetEnemy(ent, enemy);
			ent->cantHitEnemyCounter = 0;
		}
		else
		{
			G_SetEnemy(ent, enemy);
		}
	}
}

/*
=============
Q3_SetLeader

Sets the leader of an NPC
=============
*/
static void Q3_SetLeader(const int entID, const char* name)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLeader: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetLeader: ent %d is NOT a player or NPC!\n", entID);
		return;
	}

	if (!Q_stricmp("NONE", name) || !Q_stricmp("NULL", name))
	{
		ent->client->leader = NULL;
	}
	else
	{
		gentity_t* leader = G_Find(NULL, FOFS(targetname), (char*)name);

		if (leader == NULL)
		{
			return;
		}
		if (leader->health <= 0)
		{
			return;
		}
		ent->client->leader = leader;
	}
}

/*
=============
Q3_SetNavGoal

Sets the navigational goal of an entity
=============
*/
static qboolean Q3_SetNavGoal(const int entID, const char* name)
{
	gentity_t* ent = &g_entities[entID];
	vec3_t goalPos;

	if (!ent->health)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNavGoal: tried to set a navgoal (\"%s\") on a corpse! \"%s\"\n", name,
			ent->script_targetname);
		return qfalse;
	}
	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNavGoal: tried to set a navgoal (\"%s\") on a non-NPC: \"%s\"\n", name,
			ent->script_targetname);
		return qfalse;
	}
	if (!ent->NPC->tempGoal)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNavGoal: tried to set a navgoal (\"%s\") on a dead NPC: \"%s\"\n", name,
			ent->script_targetname);
		return qfalse;
	}
	if (!ent->NPC->tempGoal->inuse)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNavGoal: NPC's (\"%s\") navgoal is freed: \"%s\"\n", name,
			ent->script_targetname);
		return qfalse;
	}
	if (Q_stricmp("null", name) == 0
		|| Q_stricmp("NULL", name) == 0)
	{
		ent->NPC->goalEntity = NULL;
		trap->ICARUS_TaskIDComplete((sharedEntity_t*)ent, TID_MOVE_NAV);
		return qfalse;
	}
	//Get the position of the goal
	if (TAG_GetOrigin2(NULL, name, goalPos) == qfalse)
	{
		gentity_t* targ = G_Find(NULL, FOFS(targetname), (char*)name);
		if (!targ)
		{
			G_DebugPrint(WL_ERROR, "Q3_SetNavGoal: can't find NAVGOAL \"%s\"\n", name);
			return qfalse;
		}
		ent->NPC->goalEntity = targ;
		ent->NPC->goalRadius = sqrt(ent->r.maxs[0] + ent->r.maxs[0]) + sqrt(targ->r.maxs[0] + targ->r.maxs[0]);
		ent->NPC->aiFlags &= ~NPCAI_TOUCHED_GOAL;
	}
	else
	{
		const int goalRadius = TAG_GetRadius(NULL, name);
		NPC_SetMoveGoal(ent, goalPos, goalRadius, qtrue, -1, NULL);
		//We know we want to clear the lastWaypoint here
		ent->NPC->goalEntity->lastWaypoint = WAYPOINT_NONE;
		ent->NPC->aiFlags &= ~NPCAI_TOUCHED_GOAL;
#ifdef _DEBUG
		//this is *only* for debugging navigation
		ent->NPC->tempGoal->target = G_NewString(name);
#endif// _DEBUG
		return qtrue;
	}
	return qfalse;
}

/*
============
SetLowerAnim
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int animID
============
*/
static void SetLowerAnim(const int entID, const int animID)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "SetLowerAnim: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "SetLowerAnim: ent %d is NOT a player or NPC!\n", entID);
		return;
	}

	G_SetAnim(ent, NULL, SETANIM_LEGS, animID, SETANIM_FLAG_RESTART | SETANIM_FLAG_HOLD | SETANIM_FLAG_OVERRIDE, 0);
}

/*
============
SetUpperAnim
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int animID
============
*/
static void SetUpperAnim(const int entID, const int animID)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "SetUpperAnim: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "SetLowerAnim: ent %d is NOT a player or NPC!\n", entID);
		return;
	}

	G_SetAnim(ent, NULL, SETANIM_TORSO, animID, SETANIM_FLAG_RESTART | SETANIM_FLAG_HOLD | SETANIM_FLAG_OVERRIDE, 0);
}

/*
=============
Q3_SetAnimUpper

Sets the upper animation of an entity
=============
*/
static qboolean Q3_SetAnimUpper(const int entID, const char* anim_name)
{
	const int animID = GetIDForString(animTable, anim_name);

	if (animID == -1)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAnimUpper: unknown animation sequence '%s'\n", anim_name);
		return qfalse;
	}

	SetUpperAnim(entID, animID);
	return qtrue;
}

/*
=============
Q3_SetAnimLower

Sets the lower animation of an entity
=============
*/
static qboolean Q3_SetAnimLower(const int entID, const char* anim_name)
{
	//FIXME: Setting duck anim does not actually duck!

	const int animID = GetIDForString(animTable, anim_name);

	if (animID == -1)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAnimLower: unknown animation sequence '%s'\n", anim_name);
		return qfalse;
	}

	SetLowerAnim(entID, animID);
	return qtrue;
}

/*
============
Q3_SetAnimHoldTime
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int int_data
  Argument		: qboolean lower
============
*/
static void Q3_SetAnimHoldTime(const int entID, const int int_data, const qboolean lower)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		return;
	}

	if (!ent->client)
	{
		return;
	}

	if (lower)
	{
		ent->client->ps.legsTimer = int_data;
	}
	else
	{
		ent->client->ps.torsoTimer = int_data;
	}
}

static void Q3_SetRenderCullRadius(int entID, float float_data);

static void Q3_SetPlayerTeam(const int entID, const char* data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
		return;

	if (!ent->client)
		return;

	ent->client->playerTeam = GetIDForString(TeamTable, data);
}

//==========
static void Q3_SetEnemyTeam(const int entID, const char* data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
		return;

	if (!ent->client)
		return;

	ent->client->enemyTeam = GetIDForString(TeamTable, data);
}

/*
============
Q3_SetHealth
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int data
============
*/
static void Q3_SetHealth(const int entID, int data)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetHealth: invalid entID %d\n", entID);
		return;
	}

	if (data < 0)
	{
		data = 0;
	}

	ent->health = data;

	if (!ent->client)
	{
		return;
	}

	ent->client->ps.stats[STAT_HEALTH] = data;

	if (ent->client->ps.stats[STAT_HEALTH] > ent->client->ps.stats[STAT_MAX_HEALTH])
	{
		ent->health = ent->client->ps.stats[STAT_HEALTH] = ent->client->ps.stats[STAT_MAX_HEALTH];
	}
	if (data == 0)
	{
		ent->health = 1;
		if (ent->client->sess.sessionTeam == TEAM_SPECTATOR)
		{
			//this would be silly
			return;
		}

		if (ent->client->tempSpectate >= level.time)
		{
			//this would also be silly
			return;
		}

		ent->flags &= ~FL_GODMODE;
		ent->client->ps.stats[STAT_HEALTH] = ent->health = -999;
		player_die(ent, ent, ent, 100000, MOD_FALLING);
	}
}

/*
============
Q3_SetArmor
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int data
============
*/
static void Q3_SetArmor(const int entID, const int data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetArmor: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		return;
	}

	ent->client->ps.stats[STAT_ARMOR] = data;
	if (ent->client->ps.stats[STAT_ARMOR] > ent->client->ps.stats[STAT_MAX_HEALTH])
	{
		ent->client->ps.stats[STAT_ARMOR] = ent->client->ps.stats[STAT_MAX_HEALTH];
	}
}

/*
============
Q3_SetBState
  Description	:
  Return type	: static qboolean
  Argument		:  int entID
  Argument		: const char *bs_name
FIXME: this should be a general NPC wrapper function
	that is called ANY time	a b_state is changed...
============
*/
void ClearNPCGlobals(void);

static qboolean Q3_SetBState(const int entID, const char* bs_name)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetBState: invalid entID %d\n", entID);
		return qtrue;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetBState: '%s' is not an NPC\n", ent->targetname);
		return qtrue; //ok to complete
	}

	//some of the below called functions use the NPCGlobals, make sure they've been set up.
	SetNPCGlobals(ent);

	const bState_t bSID = GetIDForString(BSTable, bs_name);

	if (bSID != (bState_t)-1)
	{
		if (bSID == BS_SEARCH || bSID == BS_WANDER)
		{
			if (ent->waypoint != WAYPOINT_NONE)
			{
				NPC_BSSearchStart(ent->waypoint, bSID);
			}
			else
			{
				ent->waypoint = NAV_FindClosestWaypointForEnt(ent, WAYPOINT_NONE);

				if (ent->waypoint != WAYPOINT_NONE)
				{
					NPC_BSSearchStart(ent->waypoint, bSID);
				}
				else
				{
					G_DebugPrint(WL_ERROR, "Q3_SetBState: '%s' is not in a valid waypoint to search from!\n",
						ent->targetname);
					return qtrue;
				}
			}
		}

		ent->NPC->tempBehavior = BS_DEFAULT; //need to clear any temp behaviour
		if (ent->NPC->behaviorState == BS_NOCLIP && bSID != BS_NOCLIP)
		{
			//need to rise up out of the floor after noclipping
			ent->r.currentOrigin[2] += 0.125;
			G_SetOrigin(ent, ent->r.currentOrigin);
		}
		ent->NPC->behaviorState = bSID;
		if (bSID == BS_DEFAULT)
		{
			ent->NPC->defaultBehavior = bSID;
		}
	}

	//finished making NPC function calls, don't need globals anymore
	ClearNPCGlobals();
	ent->NPC->aiFlags &= ~NPCAI_TOUCHED_GOAL;

	if (bSID == BS_NOCLIP)
	{
		ent->client->noclip = qtrue;
	}
	else
	{
		ent->client->noclip = qfalse;
	}
	if (bSID == BS_ADVANCE_FIGHT)
	{
		return qfalse; //need to wait for task complete message
	}

	if (bSID == BS_JUMP)
	{
		ent->NPC->jumpState = JS_FACING;
	}

	return qtrue; //ok to complete
}

/*
============
Q3_SetTempBState
  Description	:
  Return type	: static qboolean
  Argument		:  int entID
  Argument		: const char *bs_name
============
*/
static qboolean Q3_SetTempBState(const int entID, const char* bs_name)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetTempBState: invalid entID %d\n", entID);
		return qtrue;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetTempBState: '%s' is not an NPC\n", ent->targetname);
		return qtrue; //ok to complete
	}

	const bState_t bSID = GetIDForString(BSTable, bs_name);
	if (bSID != (bState_t)-1)
	{
		ent->NPC->tempBehavior = bSID;
	}
	return qtrue; //ok to complete
}

/*
============
Q3_SetDefaultBState
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: const char *bs_name
============
*/
static void Q3_SetDefaultBState(const int entID, const char* bs_name)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDefaultBState: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetDefaultBState: '%s' is not an NPC\n", ent->targetname);
		return;
	}

	const bState_t bSID = GetIDForString(BSTable, bs_name);
	if (bSID != (bState_t)-1)
	{
		ent->NPC->defaultBehavior = bSID;
	}
}

#define SET_NPC(s) gentity_t	*ent = &g_entities[entID];\
	if (!ent->NPC) return;\
	ent->NPC->s = data;

#define SET_NPCSTAT(s) gentity_t	*ent = &g_entities[entID];\
	if (!ent->NPC) return;\
	ent->NPC->stats.s = data;

/*
============
Q3_SetDPitch
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetDPitch(const int entID, float data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDPitch: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC || !ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetDPitch: '%s' is not an NPC\n", ent->targetname);
		return;
	}

	const int pitchMin = -ent->client->renderInfo.headPitchRangeUp + 1;
	const int pitchMax = ent->client->renderInfo.headPitchRangeDown - 1;

	//clamp angle to -180 -> 180
	data = AngleNormalize180(data);

	//Clamp it to my valid range
	if (data < -1)
	{
		if (data < pitchMin)
		{
			data = pitchMin;
		}
	}
	else if (data > 1)
	{
		if (data > pitchMax)
		{
			data = pitchMax;
		}
	}

	ent->NPC->lockedDesiredPitch = ent->NPC->desiredPitch = data;
}

/*
============
Q3_SetDYaw
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetDYaw(const int entID, const float data)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDYaw: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetDYaw: '%s' is not an NPC\n", ent->targetname);
		return;
	}

	if (!ent->enemy)
	{
		//don't mess with this if they're aiming at someone
		ent->NPC->lockedDesiredYaw = ent->NPC->desiredYaw = ent->s.angles[1] = data;
	}
	else
	{
		G_DebugPrint(WL_WARNING, "Could not set DYAW: '%s' has an enemy (%s)!\n", ent->targetname,
			ent->enemy->targetname);
	}
}

/*
============
Q3_SetShootDist
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetShootDist(const int entID, const float data)
{
	SET_NPCSTAT(shootDistance);
}

/*
============
Q3_SetVisrange
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetVisrange(const int entID, const float data)
{
	SET_NPCSTAT(visrange);
}

/*
============
Q3_SetEarshot
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetEarshot(const int entID, const float data)
{
	SET_NPCSTAT(earshot);
}

/*
============
Q3_SetVigilance
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetVigilance(const int entID, const float data)
{
	SET_NPCSTAT(vigilance);
}

/*
============
Q3_SetVFOV
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int data
============
*/
static void Q3_SetVFOV(const int entID, const int data)
{
	SET_NPCSTAT(vfov);
}

/*
============
Q3_SetHFOV
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int data
============
*/
static void Q3_SetHFOV(const int entID, const int data)
{
	SET_NPCSTAT(hfov);
}

/*
============
Q3_SetWidth
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: float data
============
*/
static void Q3_SetWidth(const int entID, const int data)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWidth: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWidth: '%s' is not an NPC\n", ent->targetname);
		return;
	}

	ent->r.maxs[0] = ent->r.maxs[1] = data;
	ent->r.mins[0] = ent->r.mins[1] = -data;
}

/*
============
Q3_SetTimeScale
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: const char *data
============
*/
static void Q3_SetTimeScale(int entID, const char* data)
{
	trap->Cvar_Set("timescale", data);
}

/*
============
Q3_SetInvisible
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: qboolean invisible
============
*/
static void Q3_SetInvisible(const int entID, const qboolean invisible)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetInvisible: invalid entID %d\n", entID);
		return;
	}

	if (invisible)
	{
		self->s.eFlags |= EF_NODRAW;
		if (self->client)
		{
			self->client->ps.eFlags |= EF_NODRAW;
		}
		self->r.contents = 0;
	}
	else
	{
		self->s.eFlags &= ~EF_NODRAW;
		if (self->client)
		{
			self->client->ps.eFlags &= ~EF_NODRAW;
		}
	}
}

/*
============
Q3_SetVampire
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: qboolean vampire
============
*/
static void Q3_SetVampire(int entID, qboolean vampire)
{
}

/*
============
Q3_SetGreetAllies
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: qboolean greet
============
*/
static void Q3_SetGreetAllies(const int entID, const qboolean greet)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetGreetAllies: invalid entID %d\n", entID);
		return;
	}

	if (!self->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetGreetAllies: ent %s is not an NPC!\n", self->targetname);
		return;
	}

	if (greet)
	{
		self->NPC->aiFlags |= NPCAI_GREET_ALLIES;
	}
	else
	{
		self->NPC->aiFlags &= ~NPCAI_GREET_ALLIES;
	}
}

/*
============
Q3_SetViewTarget
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *name
============
*/
static void Q3_SetViewTarget(const int entID, const char* name)
{
	const gentity_t* self = &g_entities[entID];
	const gentity_t* viewtarget = G_Find(NULL, FOFS(targetname), (char*)name);
	vec3_t viewspot, selfspot, viewvec, viewangles;

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetViewTarget: invalid entID %d\n", entID);
		return;
	}

	if (!self->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetViewTarget: '%s' is not a player/NPC!\n", self->targetname);
		return;
	}

	//FIXME: Exception handle here
	if (viewtarget == NULL)
	{
		if (strcmp(name, "player") == 0)
		{
			viewtarget = SelectSPSpawnPoint(viewspot, viewspot);
		}

		if (!viewtarget)
		{
			G_DebugPrint(WL_WARNING, "Q3_SetViewTarget: can't find ViewTarget: '%s'\n", name);
			return;
		}
	}

	//FIXME: should we set behavior to BS_FACE and keep facing this ent as it moves
	//around for a script-specified length of time...?
	VectorCopy(self->s.origin, selfspot);
	selfspot[2] += self->client->ps.viewheight;

	if (viewtarget->client && !skippingCutscene)
	{
		VectorCopy(viewtarget->client->renderInfo.eyePoint, viewspot);
	}
	else
	{
		VectorCopy(viewtarget->s.origin, viewspot);
	}

	VectorSubtract(viewspot, selfspot, viewvec);

	vectoangles(viewvec, viewangles);

	Q3_SetDYaw(entID, viewangles[YAW]);
	if (!skippingCutscene)
	{
		Q3_SetDPitch(entID, viewangles[PITCH]);
	}
}

/*
============
Q3_SetWatchTarget
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *name
============
*/
static void Q3_SetWatchTarget(const int entID, const char* name)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWatchTarget: invalid entID %d\n", entID);
		return;
	}

	if (!self->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWatchTarget: '%s' is not an NPC!\n", self->targetname);
		return;
	}

	if (Q_stricmp("NULL", name) == 0 || Q_stricmp("NONE", name) == 0 || self->targetname && Q_stricmp(
		self->targetname, name) == 0)
	{
		//clearing watchTarget
		self->NPC->watchTarget = NULL;
	}

	gentity_t* watchTarget = G_Find(NULL, FOFS(targetname), (char*)name);
	if (watchTarget == NULL)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWatchTarget: can't find WatchTarget: '%s'\n", name);
		return;
	}

	self->NPC->watchTarget = watchTarget;
}

static void Q3_SetLoopSound(const int entID, const char* name)
{
	gentity_t* self = &g_entities[entID];

	if (Q_stricmp("NULL", name) == 0 || Q_stricmp("NONE", name) == 0)
	{
		self->s.loopSound = 0;
		self->s.loopIsSoundset = qfalse;
		return;
	}

	const sfxHandle_t index = G_SoundIndex((char*)name);

	if (index)
	{
		self->s.loopSound = index;
		self->s.loopIsSoundset = qfalse;
	}
	else
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLoopSound: can't find sound file: '%s'\n", name);
	}
}

static void Q3_SetICARUSFreeze(int entID, const char* name, const qboolean freeze)
{
	gentity_t* self = G_Find(NULL, FOFS(targetname), name);
	if (!self)
	{
		//hmm, targetname failed, try script_targetname?
		self = G_Find(NULL, FOFS(script_targetname), name);
	}

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetICARUSFreeze: invalid ent %s\n", name);
		return;
	}

	if (freeze)
	{
		self->r.svFlags |= SVF_ICARUS_FREEZE;
	}
	else
	{
		self->r.svFlags &= ~SVF_ICARUS_FREEZE;
	}
}

/*
============
Q3_SetViewEntity
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *name
============
*/
void Q3_SetViewEntity(int entID, const char* name)
{
	G_DebugPrint(WL_WARNING, "Q3_SetViewEntity currently unsupported in MP, ask if you need it.\n");
}

/*
============
Q3_SetWeapon
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *wp_name
============
*/
extern void ChangeWeapon(const gentity_t* ent, int new_weapon);
int SpawnWeapons; //used to set default weapons for spawn when using ICARUS scripts.
qboolean UseSpawnWeapons;
//Indicates if SpawnWeapons is to be used.used to set default forcepowers for spawn when using ICARUS scripts.
int SpawnForcePowerLevels[NUM_FORCE_POWERS];
qboolean UseSpawnForcePowers; //Indicates if SpawnForcePowers is to be used.
void InitSpawnScriptValues(void)
{
	//initialize the spawn values used to override the defaults used by spawns for ICARUS scripts

	UseSpawnWeapons = qfalse;
	SpawnWeapons = 0;

	UseSpawnForcePowers = qfalse;
	for (int i = 0; i < NUM_FORCE_POWERS; i++)
	{
		SpawnForcePowerLevels[i] = 0;
	}
}

static void SetSpawnWeapon(const int weap)
{
	if (weap == WP_NONE)
	{
		//reset SpawnWeapons
		SpawnWeapons = WP_NONE;
	}
	else
	{
		//add weapon
		SpawnWeapons |= 1 << weap;
	}
	UseSpawnWeapons = qtrue;
}

void G_SetWeapon(gentity_t* self, const int wp)
{
	qboolean had_weapon = qfalse;

	if (!self->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWeapon: '%s' is not a player/NPC!\n", self->targetname);
		return;
	}

	if (self->NPC)
	{
		//since a script sets a weapon, we presume we don't want to auto-match the player's weapon anymore
		self->NPC->aiFlags &= ~NPCAI_MATCHPLAYERWEAPON;
	}

	if (wp == WP_NONE)
	{
		//no weapon
		self->client->ps.weapon = WP_NONE;

		if (self->s.number < MAX_CLIENTS)
		{
			//make sure the cgame-side knows this
			self->client->ps.weapon = WP_MELEE;
			self->client->ps.stats[STAT_WEAPONS] = WP_MELEE; //remove all the player's weapons.
			SetSpawnWeapon(WP_MELEE);
		}
		else
		{
			self->client->ps.weapon = WP_NONE;
			self->client->ps.stats[STAT_WEAPONS] = WP_NONE; // remove all the npc's weapons.
			SetSpawnWeapon(WP_NONE);
		}
		return;
	}

	const gitem_t* item = BG_FindItemForWeapon(wp);
	register_item(item); //make sure the weapon is cached in case this runs at startup

	if (self->client->ps.stats[STAT_WEAPONS] & 1 << wp)
	{
		had_weapon = qtrue;
	}
	if (self->NPC)
	{
		//Should NPCs have only 1 weapon at a time?
		self->client->ps.stats[STAT_WEAPONS] = 1 << wp;
		self->client->ps.ammo[weaponData[wp].ammoIndex] = 999;

		ChangeWeapon(self, wp);
		self->client->ps.weapon = wp;
		self->client->ps.weaponstate = WEAPON_READY; //WEAPON_RAISING;
		G_AddEvent(self, EV_GENERAL_SOUND, G_SoundIndex("sound/weapons/change.wav"));
	}
	else
	{
		self->client->ps.stats[STAT_WEAPONS] |= 1 << wp;
		self->client->ps.ammo[weaponData[wp].ammoIndex] = ammoData[weaponData[wp].ammoIndex].max;

		G_AddEvent(self, EV_ITEM_PICKUP, item - bg_itemlist);
		G_AddEvent(self, EV_GENERAL_SOUND, G_SoundIndex("sound/weapons/change.wav"));

		//also set things up so players respawn with the these weapons.
		SetSpawnWeapon(wp);

		//force a switch to this weapon as well (for start game scripts.)
		self->client->ps.weapon = wp;
	}

	if (!had_weapon)
	{
		G_AddEvent(self, EV_WEAPINVCHANGE, self->client->ps.stats[STAT_WEAPONS]);
	}

	if (wp == WP_SABER)
	{
		if (!had_weapon)
		{
			wp_saber_init_blade_data(self);
		}
	}
	else
	{
		//G_CreateG2AttachedWeaponModel( self, weaponData[wp].weaponMdl, self->handRBolt, 0 );
	}
}

static void Q3_SetWeapon(const int entID, const char* wp_name)
{
	gentity_t* ent = &g_entities[entID];
	int wp = GetIDForString(WPTable, wp_name);

	if (wp == -1)
	{
		//unknown weapon
		wp = WP_NONE;
	}

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWeapon: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWeapon: '%s' is not a player/NPC!\n", ent->targetname);
		return;
	}

	if (ent->NPC)
	{
		//since a script sets a weapon, we presume we don't want to auto-match the player's weapon anymore
		ent->NPC->aiFlags &= ~NPCAI_MATCHPLAYERWEAPON;
	}

	//account for the "drop" weapon command
	if (!Q_stricmp("drop", wp_name))
	{
		//no weapon, drop it
		TossClientItems(ent);
		ent->client->ps.weapon = WP_NONE;
		return;
	}

	G_SetWeapon(ent, wp);
}

/*
============
Q3_SetItem
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *wp_name
============
*/
static void Q3_SetItem(int entID, const char* item_name)
{
	//gentity_t	*self = &g_entities[entID];
	//int		inv;

	//if (!self)
	//{
	//	G_DebugPrint(WL_WARNING, "Q3_SetWeapon: invalid entID %d\n", entID);
	//	return;
	//}

	//if (!self->client)
	//{
	//	G_DebugPrint(WL_WARNING, "Q3_SetWeapon: '%s' is not a player/NPC!\n", self->targetname);
	//	return;
	//}

	//inv = GetIDForString(INVTable, item_name);

	//gitem_t *item = BG_FindItemForHoldable(inv);
	//register_item(item);	//make sure the item is cached in case this runs at startup

	//self->client->ps.stats[STAT_HOLDABLE_ITEMS] |= (1 << item->giTag);
}

/*
============
Q3_SetWalkSpeed
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: int int_data
============
*/
static void Q3_SetWalkSpeed(const int entID, const int int_data)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWalkSpeed: invalid entID %d\n", entID);
		return;
	}

	if (!self->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWalkSpeed: '%s' is not an NPC!\n", self->targetname);
		return;
	}

	if (int_data == 0)
	{
		self->NPC->stats.walkSpeed = self->client->ps.speed = 1;
	}

	self->NPC->stats.walkSpeed = self->client->ps.speed = int_data;
}

/*
============
Q3_SetRunSpeed
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: int int_data
============
*/
static void Q3_SetRunSpeed(const int entID, const int int_data)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetRunSpeed: invalid entID %d\n", entID);
		return;
	}

	if (!self->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetRunSpeed: '%s' is not an NPC!\n", self->targetname);
		return;
	}

	if (int_data == 0)
	{
		self->NPC->stats.runSpeed = self->client->ps.speed = 1;
	}

	self->NPC->stats.runSpeed = self->client->ps.speed = int_data;
}

/*
============
Q3_SetYawSpeed
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: float float_data
============
*/
static void Q3_SetYawSpeed(const int entID, const float data)
{
	SET_NPCSTAT(yawSpeed);
}

/*
============
Q3_SetAggression
Description	:
Return type	: static void
Argument		: int entID
Argument		: int int_data
============
*/
static void Q3_SetAggression(const int entID, const int data)
{
	SET_NPCSTAT(aggression);
}

/*
============
Q3_SetAim
Description	:
Return type	: static void
Argument		: int entID
Argument		: int int_data
============
*/
static void Q3_SetAim(const int entID, const int data)
{
	SET_NPCSTAT(aim);
}

/*
============
Q3_SetFriction
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: int int_data
============
*/
static void Q3_SetFriction(const int entID, const int int_data)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetFriction: invalid entID %d\n", entID);
		return;
	}

	if (!self->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetFriction: '%s' is not an NPC/player!\n", self->targetname);
		return;
	}

	self->client->ps.friction = int_data;
}

/*
============
Q3_SetGravity
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: float float_data
============
*/
static void Q3_SetGravity(const int entID, const float float_data)
{
	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetGravity: invalid entID %d\n", entID);
		return;
	}

	if (!self->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetGravity: '%s' is not an NPC/player!\n", self->targetname);
		return;
	}

	//FIXME: what if we want to return them to normal global gravity?
	if (self->NPC)
	{
		self->NPC->aiFlags |= NPCAI_CUSTOM_GRAVITY;
	}
	self->client->ps.gravity = float_data;
}

/*
============
Q3_SetWait
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: float float_data
============
*/
static void Q3_SetWait(const int entID, const float float_data)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWait: invalid entID %d\n", entID);
		return;
	}

	self->wait = float_data;
}

static void Q3_SetShotSpacing(const int entID, const int data)
{
	SET_NPC(burstSpacing);
}

/*
============
Q3_SetFollowDist
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: float float_data
============
*/
static void Q3_SetFollowDist(const int entID, const float data)
{
	SET_NPC(followDist);
}

/*
============
Q3_SetScale
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: float float_data
============
*/
static void Q3_SetScale(const int entID, const float float_data)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetScale: invalid entID %d\n", entID);
		return;
	}

	if (self->client)
	{
		if (float_data < 0)
		{
			self->client->ps.iModelScale = float_data;
		}
		else
		{
			self->client->ps.iModelScale = float_data * 100.0f;
		}
	}
	else
	{
		if (float_data < 0)
		{
			self->s.iModelScale = float_data;
		}
		else
		{
			self->s.iModelScale = float_data * 100.0f;
		}
	}
}

/*
============
Q3_GameSideCheckStringCounterIncrement
  Description	:
  Return type	: static float
  Argument		: const char *string
============
*/
static float Q3_GameSideCheckStringCounterIncrement(const char* string)
{
	char* numString;
	float val = 0.0f;

	if (string[0] == '+')
	{
		//We want to increment whatever the value is by whatever follows the +
		if (string[1])
		{
			numString = (char*)&string[1];
			val = atof(numString);
		}
	}
	else if (string[0] == '-')
	{
		//we want to decrement
		if (string[1])
		{
			numString = (char*)&string[1];
			val = atof(numString) * -1;
		}
	}

	return val;
}

/*
============
Q3_SetCount
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *data
============
*/
static void Q3_SetCount(const int entID, const char* data)
{
	gentity_t* self = &g_entities[entID];
	float val;

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetCount: invalid entID %d\n", entID);
		return;
	}

	if ((val = Q3_GameSideCheckStringCounterIncrement(data)))
	{
		self->count += (int)val;
	}
	else
	{
		self->count = atoi((char*)data);
	}
}

/*
============
Q3_SetTargetName
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *targetname
============
*/
static void Q3_SetTargetName(const int entID, const char* targetname)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetTargetName: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("NULL", (char*)targetname))
	{
		self->targetname = NULL;
	}
	else
	{
		self->targetname = G_NewString(targetname);
	}
}

/*
============
Q3_SetTarget
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *target
============
*/
static void Q3_SetTarget(const int entID, const char* target)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetTarget: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("NULL", (char*)target))
	{
		self->target = NULL;
	}
	else
	{
		self->target = G_NewString(target);
	}
}

/*
============
Q3_SetTarget2
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *target
============
*/
static void Q3_SetTarget2(const int entID, const char* target2)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetTarget2: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("NULL", (char*)target2))
	{
		self->target2 = NULL;
	}
	else
	{
		self->target2 = G_NewString(target2);
	}
}

/*
============
Q3_SetRemoveTarget
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *target
============
*/
static void Q3_SetRemoveTarget(const int entID, const char* target)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetRemoveTarget: invalid entID %d\n", entID);
		return;
	}

	if (!self->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetRemoveTarget: '%s' is not an NPC!\n", self->targetname);
		return;
	}

	if (!Q_stricmp("NULL", (char*)target))
	{
		self->target3 = NULL;
	}
	else
	{
		self->target3 = G_NewString(target);
	}
}

/*
============
Q3_SetPainTarget
  Description	:
  Return type	: void
  Argument		: int entID
  Argument		: const char *targetname
============
*/
static void Q3_SetPainTarget(const int entID, const char* targetname)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetPainTarget: invalid entID %d\n", entID);
		return;
	}

	if (Q_stricmp("NULL", (char*)targetname) == 0)
	{
		self->paintarget = NULL;
	}
	else
	{
		self->paintarget = G_NewString((char*)targetname);
	}
}

/*
============
Q3_SetFullName
  Description	:
  Return type	: static void
  Argument		: int entID
  Argument		: const char *fullName
============
*/
static void Q3_SetFullName(const int entID, const char* fullName)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetFullName: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("NULL", (char*)fullName))
	{
		self->fullName = NULL;
	}
	else
	{
		self->fullName = G_NewString(fullName);
	}
}

static void Q3_SetMusicState(const char* dms)
{
	const int newDMS = GetIDForString(DMSTable, dms);
	if (newDMS != -1 && DMSData.valid)
	{
		SetDMSState(newDMS);
	}
}

static void SetSpawnForcePower(const int forcePower, const int forceLevel)
{
	//sets a new force power level for the default force powers for the clients in CoOp.
	SpawnForcePowerLevels[forcePower] = forceLevel;
	UseSpawnForcePowers = qtrue;
}

static void Q3_SetForcePowerLevel(const int entID, const int forcePower, const int forceLevel)
{
	if (forcePower < FP_FIRST || forceLevel >= NUM_FORCE_POWERS)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetForcePowerLevel: Force Power index %d out of range (%d-%d)\n", forcePower,
			FP_FIRST, NUM_FORCE_POWERS - 1);
		return;
	}

	if (forceLevel < 0 || forceLevel >= NUM_FORCE_POWER_LEVELS)
	{
		if (forcePower != FP_SABER_OFFENSE || forceLevel >= SS_NUM_SABER_STYLES)
		{
			G_DebugPrint(WL_ERROR, "Q3_SetForcePowerLevel: Force power setting %d out of range (0-3)\n", forceLevel);
			return;
		}
	}

	const gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetForcePowerLevel: invalid entID %d\n", entID);
		return;
	}

	if (!self->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetForcePowerLevel: ent %s is not a player or NPC\n", self->targetname);
		return;
	}

	self->client->ps.fd.forcePowerLevel[forcePower] = forceLevel;
	if (forceLevel)
	{
		self->client->ps.fd.forcePowersKnown |= 1 << forcePower;
	}
	else
	{
		self->client->ps.fd.forcePowersKnown &= ~(1 << forcePower);
	}

	if (!self->NPC)
	{
		//this is the player, set default spawn force levels.
		SetSpawnForcePower(forcePower, forceLevel);
	}
}

/*
============
Q3_SetParm
  Description	:
  Return type	: void
  Argument		: int entID
  Argument		: int parmNum
  Argument		: const char *parmValue
============
*/
void Q3_SetParm(const int entID, const int parmNum, const char* parmValue)
{
	gentity_t* ent = &g_entities[entID];
	float val;

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetParm: invalid entID %d\n", entID);
		return;
	}

	if (parmNum < 0 || parmNum >= MAX_PARMS)
	{
		G_DebugPrint(WL_WARNING, "SET_PARM: parmNum %d out of range!\n", parmNum);
		return;
	}

	if (!ent->parms)
	{
		ent->parms = (parms_t*)G_Alloc(sizeof(parms_t));
		memset(ent->parms, 0, sizeof(parms_t));
	}

	if ((val = Q3_GameSideCheckStringCounterIncrement(parmValue)))
	{
		val += atof(ent->parms->parm[parmNum]);
		Com_sprintf(ent->parms->parm[parmNum], sizeof ent->parms->parm[parmNum], "%f", val);
	}
	else
	{
		//Just copy the string
		//copy only 16 characters
		strncpy(ent->parms->parm[parmNum], parmValue, sizeof ent->parms->parm[parmNum]);
		//set the last character to null in case we had to truncate their passed string
		if (ent->parms->parm[parmNum][sizeof ent->parms->parm[parmNum] - 1] != 0)
		{
			//Tried to set a string that is too long
			ent->parms->parm[parmNum][sizeof ent->parms->parm[parmNum] - 1] = 0;
			G_DebugPrint(WL_WARNING, "SET_PARM: parm%d string too long, truncated to '%s'!\n", parmNum,
				ent->parms->parm[parmNum]);
		}
	}
}

/*
=============
Q3_SetCaptureGoal

Sets the capture spot goal of an entity
=============
*/
static void Q3_SetCaptureGoal(const int entID, const char* name)
{
	const gentity_t* ent = &g_entities[entID];
	gentity_t* goal = G_Find(NULL, FOFS(targetname), (char*)name);

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetCaptureGoal: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetCaptureGoal: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	//FIXME: Exception handle here
	if (goal == NULL)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetCaptureGoal: can't find CaptureGoal target: '%s'\n", name);
		return;
	}

	if (ent->NPC)
	{
		ent->NPC->captureGoal = goal;
		ent->NPC->goalEntity = goal;
		ent->NPC->goalTime = level.time + 100000;
	}
}

/*
=============
Q3_SetEvent

?
=============
*/
static void Q3_SetEvent(const int entID, const char* event_name)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetEvent: invalid entID %d\n", entID);
		return;
	}

	const int event = GetIDForString(eventTable, event_name);
	switch (event)
	{
	case EV_BAD:
	default:
		return;
	}
}

#define SET_ENT(s) gentity_t	*ent = &g_entities[entID];\
	ent->s = data;

/*
============
Q3_SetIgnorePain

?
============
*/
static void Q3_SetIgnorePain(const int entID, const qboolean data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetIgnorePain: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetIgnorePain: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	ent->NPC->ignorePain = data;
}

/*
============
Q3_SetIgnoreEnemies

?
============
*/
static void Q3_SetIgnoreEnemies(const int entID, const qboolean data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetIgnoreEnemies: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetIgnoreEnemies: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (data)
	{
		ent->NPC->scriptFlags |= SCF_IGNORE_ENEMIES;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_IGNORE_ENEMIES;
	}
}

/*
============
Q3_SetIgnoreAlerts

?
============
*/
static void Q3_SetIgnoreAlerts(const int entID, const qboolean data)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetIgnoreAlerts: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetIgnoreAlerts: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (data)
	{
		ent->NPC->scriptFlags |= SCF_IGNORE_ALERTS;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_IGNORE_ALERTS;
	}
}

/*
============
Q3_SetNoTarget

?
============
*/
static void Q3_SetNoTarget(const int entID, const qboolean data)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoTarget: invalid entID %d\n", entID);
		return;
	}

	if (data)
	{
		ent->flags |= FL_NOTARGET;
	}
	else
	{
		ent->flags &= ~FL_NOTARGET;
	}
}

/*
============
Q3_SetLean

?
============
*/
#define LEAN_NONE	0
#define LEAN_RIGHT	1
#define LEAN_LEFT	2

static void Q3_SetLean(const int entID, const int lean)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLean: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLean: '%s' is not an NPC!\n", entID);
		return;
	}

	if (lean == LEAN_RIGHT)
	{
		ent->NPC->scriptFlags |= SCF_LEAN_RIGHT;
		ent->NPC->scriptFlags &= ~SCF_LEAN_LEFT;
	}
	else if (lean == LEAN_LEFT)
	{
		ent->NPC->scriptFlags |= SCF_LEAN_LEFT;
		ent->NPC->scriptFlags &= ~SCF_LEAN_RIGHT;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_LEAN_LEFT;
		ent->NPC->scriptFlags &= ~SCF_LEAN_RIGHT;
	}
}

/*
============
Q3_SetDontShoot

?
============
*/
static void Q3_SetDontShoot(const int entID, const qboolean add)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDontShoot: invalid entID %d\n", entID);
		return;
	}

	if (add)
	{
		ent->flags |= FL_DONT_SHOOT;
	}
	else
	{
		ent->flags &= ~FL_DONT_SHOOT;
	}
}

/*
============
Q3_SetDontFire

?
============
*/
static void Q3_SetDontFire(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDontFire: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetDontFire: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_DONT_FIRE;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_DONT_FIRE;
	}
}

/*
============
Q3_SetFireWeapon

?
============
*/
static void Q3_SetFireWeapon(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_FireWeapon: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetFireWeapon: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_FIRE_WEAPON;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_FIRE_WEAPON;
	}
}

/*
============
Q3_SetSafeRemove

If true, NPC will remove itself once player is not in PVS
============
*/
static void Q3_SetSafeRemove(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetSafeRemove: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetSafeRemove: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_SAFE_REMOVE;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_SAFE_REMOVE;
	}
}

//This sets weither or not a given entity will always been seen by clients or not.
void Q3_SetBroadcast(const int entID, const qboolean broadcast)
{
	gentity_t* ent = &g_entities[entID];
	if (broadcast)
	{
		ent->r.svFlags |= SVF_BROADCAST;
	}
	else
	{
		ent->r.svFlags &= ~SVF_BROADCAST;
	}
}

/*
============
Q3_SetInactive

?
============
*/
static void Q3_SetInactive(const int entID, const qboolean add)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetInactive: invalid entID %d\n", entID);
		return;
	}

	if (add)
	{
		ent->flags |= FL_INACTIVE;
	}
	else
	{
		ent->flags &= ~FL_INACTIVE;
	}
}

/*
============
Q3_SetFuncUsableVisible

?
============
*/
static void Q3_SetFuncUsableVisible(const int entID, const qboolean visible)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetFuncUsableVisible: invalid entID %d\n", entID);
		return;
	}

	// Yeah, I know that this doesn't even do half of what the func_usable use code does, but if I've got two things on top of each other...and only
	//	one is visible at a time....and neither can ever be used......and finally, the shader on it has the shader_anim stuff going on....It doesn't seem
	//	like I can easily use the other version without nasty side effects.
	if (visible)
	{
		ent->r.svFlags &= ~SVF_NOCLIENT;
		ent->s.eFlags &= ~EF_NODRAW;
	}
	else
	{
		ent->r.svFlags |= SVF_NOCLIENT;
		ent->s.eFlags |= EF_NODRAW;
	}
}

/*
============
Q3_SetLockedEnemy

?
============
*/
static void Q3_SetLockedEnemy(const int entID, const qboolean locked)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLockedEnemy: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLockedEnemy: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (locked)
	{
		ent->r.svFlags |= SVF_LOCKEDENEMY;
	}
	else
	{
		ent->r.svFlags &= ~SVF_LOCKEDENEMY;
	}
}

char cinematicSkipScript[1024];

/*
============
Q3_SetCinematicSkipScript

============
*/
static void Q3_SetCinematicSkipScript(const char* scriptname)
{
	if (Q_stricmp("none", scriptname) == 0 || Q_stricmp("NULL", scriptname) == 0)
	{
		cinematicSkipScript[0] = 0;
	}
	else
	{
		Q_strncpyz(cinematicSkipScript, scriptname, sizeof cinematicSkipScript);
	}
}

/*
============
Q3_SetNoMindTrick

?
============
*/
static void Q3_SetNoMindTrick(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoMindTrick: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoMindTrick: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_MIND_TRICK;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_MIND_TRICK;
	}
}

/*
============
Q3_SetCrouched

?
============
*/
static void Q3_SetCrouched(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetCrouched: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetCrouched: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_CROUCHED;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_CROUCHED;
	}
}

/*
============
Q3_SetWalking

?
============
*/
static void Q3_SetWalking(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetWalking: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetWalking: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_WALKING;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_WALKING;
	}
}

/*
============
Q3_SetRunning

?
============
*/
static void Q3_SetRunning(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetRunning: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetRunning: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_RUNNING;
		ent->NPC->scriptFlags &= ~SCF_WALKING;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_RUNNING;
	}
}

/*
============
Q3_SetForcedMarch

?
============
*/
static void Q3_SetForcedMarch(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetForcedMarch: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetForcedMarch: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_FORCED_MARCH;
		ent->NPC->scriptFlags &= ~SCF_RUNNING;
		ent->NPC->scriptFlags &= ~SCF_WALKING;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_FORCED_MARCH;
	}
}

/*
============
Q3_SetChaseEnemies

indicates whether the npc should chase after an enemy
============
*/
static void Q3_SetChaseEnemies(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetChaseEnemies: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetChaseEnemies: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_CHASE_ENEMIES;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_CHASE_ENEMIES;
	}
}

/*
============
Q3_SetLookForEnemies

if set npc will be on the look out for potential enemies
if not set, npc will ignore enemies
============
*/
static void Q3_SetLookForEnemies(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLookForEnemies: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetLookForEnemies: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_LOOK_FOR_ENEMIES;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_LOOK_FOR_ENEMIES;
	}
}

/*
============
Q3_SetFaceMoveDir

============
*/
static void Q3_SetFaceMoveDir(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetFaceMoveDir: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetFaceMoveDir: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_FACE_MOVE_DIR;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_FACE_MOVE_DIR;
	}
}

/*
============
Q3_SetAltFire

?
============
*/
static void Q3_SetAltFire(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAltFire: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetAltFire: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_altFire;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_altFire;
	}

	ChangeWeapon(ent, ent->client->ps.weapon);
}

/*
============
Q3_SetDontFlee

?
============
*/
static void Q3_SetDontFlee(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDontFlee: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetDontFlee: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_DONT_FLEE;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_DONT_FLEE;
	}
}

/*
============
Q3_SetNoResponse

?
============
*/
static void Q3_SetNoResponse(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoResponse: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoResponse: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_RESPONSE;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_RESPONSE;
	}
}

/*
============
Q3_SetCombatTalk

?
============
*/
static void Q3_SetCombatTalk(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetCombatTalk: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetCombatTalk: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_COMBAT_TALK;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_COMBAT_TALK;
	}
}

/*
============
Q3_SetAlertTalk

?
============
*/
static void Q3_SetAlertTalk(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAlertTalk: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetAlertTalk: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_ALERT_TALK;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_ALERT_TALK;
	}
}

/*
============
Q3_SetUseCpNearest

?
============
*/
static void Q3_SetUseCpNearest(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetUseCpNearest: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetUseCpNearest: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_USE_CP_NEAREST;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_USE_CP_NEAREST;
	}
}

/*
============
Q3_SetNoForce

?
============
*/
static void Q3_SetNoForce(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoForce: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoForce: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_FORCE;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_FORCE;
	}
}

/*
============
Q3_SetNoAcrobatics

?
============
*/
static void Q3_SetNoAcrobatics(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoAcrobatics: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoAcrobatics: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_ACROBATICS;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_ACROBATICS;
	}
}

/*
============
Q3_SetUseSubtitles

?
============
*/
static void Q3_SetUseSubtitles(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetUseSubtitles: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetUseSubtitles: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_USE_SUBTITLES;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_USE_SUBTITLES;
	}
}

/*
============
Q3_SetNoFallToDeath

?
============
*/
static void Q3_SetNoFallToDeath(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoFallToDeath: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoFallToDeath: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_NO_FALLTODEATH;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_NO_FALLTODEATH;
	}
}

/*
============
Q3_SetDismemberable

?
============
*/
static void Q3_SetDismemberable(const int entID, const qboolean dismemberable)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDismemberable: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDismemberable: '%s' is not an client!\n", ent->targetname);
		return;
	}

	ent->client->dismembered = (qboolean)!dismemberable;
}

/*
============
Q3_SetMoreLight

?
============
*/
static void Q3_SetMoreLight(const int entID, const qboolean add)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetMoreLight: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetMoreLight: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (add)
	{
		ent->NPC->scriptFlags |= SCF_MORELIGHT;
	}
	else
	{
		ent->NPC->scriptFlags &= ~SCF_MORELIGHT;
	}
}

/*
============
Q3_SetUndying

?
============
*/
static void Q3_SetUndying(const int entID, const qboolean undying)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetUndying: invalid entID %d\n", entID);
		return;
	}

	if (undying)
	{
		ent->flags |= FL_UNDYING;
	}
	else
	{
		ent->flags &= ~FL_UNDYING;
	}
}

/*
============
Q3_SetInvincible

?
============
*/
static void Q3_SetInvincible(const int entID, const qboolean invincible)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetInvincible: invalid entID %d\n", entID);
		return;
	}

	if (!Q_stricmp("func_breakable", ent->classname))
	{
		if (invincible)
		{
			ent->spawnflags |= 1;
		}
		else
		{
			ent->spawnflags &= ~1;
		}
		return;
	}

	if (invincible)
	{
		ent->flags |= FL_GODMODE;
	}
	else
	{
		ent->flags &= ~FL_GODMODE;
	}
}

/*
============
Q3_SetForceInvincible
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: qboolean forceInv
============
*/
static void Q3_SetForceInvincible(const int entID, const qboolean forceInv)
{
	const gentity_t* self = &g_entities[entID];

	if (!self || !self->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetForceInvincible: entID %d not a client\n", entID);
		return;
	}

	Q3_SetInvincible(entID, forceInv);
	if (forceInv)
	{
		self->client->ps.powerups[PW_INVINCIBLE] = Q3_INFINITE;
	}
	else
	{
		self->client->ps.powerups[PW_INVINCIBLE] = 0;
	}
}

/*
============
Q3_SetNoAvoid

?
============
*/
static void Q3_SetNoAvoid(const int entID, const qboolean noAvoid)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoAvoid: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetNoAvoid: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (noAvoid)
	{
		ent->NPC->aiFlags |= NPCAI_NO_COLL_AVOID;
	}
	else
	{
		ent->NPC->aiFlags &= ~NPCAI_NO_COLL_AVOID;
	}
}

/*
============
SolidifyOwner
  Description	:
  Return type	: void
  Argument		: sharedEntity_t *self
============
*/
void SolidifyOwner(gentity_t* self)
{
	gentity_t* owner = &g_entities[self->r.ownerNum];

	self->nextthink = level.time + FRAMETIME;
	self->think = G_FreeEntity;

	if (!owner || !owner->inuse)
	{
		return;
	}

	const int oldContents = owner->r.contents;
	owner->r.contents = CONTENTS_BODY;
	if (spot_would_telefrag2(owner, owner->r.currentOrigin))
	{
		owner->r.contents = oldContents;
		self->think = SolidifyOwner;
	}
	else
	{
		trap->ICARUS_TaskIDComplete((sharedEntity_t*)owner, TID_RESIZE);
	}
}

/*
============
Q3_SetSolid

?
============
*/
static qboolean Q3_SetSolid(const int entID, const qboolean solid)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent || !ent->inuse)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetSolid: invalid entID %d\n", entID);
		return qtrue;
	}

	if (solid)
	{
		//FIXME: Presumption
		const int oldContents = ent->r.contents;
		ent->r.contents = CONTENTS_BODY;
		if (spot_would_telefrag2(ent, ent->r.currentOrigin))
		{
			gentity_t* solidifier = G_Spawn();

			solidifier->r.ownerNum = ent->s.number;

			solidifier->think = SolidifyOwner;
			solidifier->nextthink = level.time + FRAMETIME;

			ent->r.contents = oldContents;
			return qfalse;
		}
		ent->clipmask |= CONTENTS_BODY;
	}
	else
	{
		//FIXME: Presumption
		if (ent->s.eFlags & EF_NODRAW)
		{
			//We're invisible too, so set contents to none
			ent->r.contents = 0;
		}
		else
		{
			ent->r.contents = CONTENTS_CORPSE;
		}
	}
	return qtrue;
}

/*
============
Q3_SetForwardMove

?
============
*/
static void Q3_SetForwardMove(const int entID, const int fmoveVal)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetForwardMove: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetForwardMove: '%s' is not an NPC/player!\n", ent->targetname);
		return;
	}

	ent->client->forced_forwardmove = fmoveVal;
}

/*
============
Q3_SetRightMove

?
============
*/
static void Q3_SetRightMove(const int entID, const int rmoveVal)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetRightMove: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetRightMove: '%s' is not an NPC/player!\n", ent->targetname);
		return;
	}

	ent->client->forced_rightmove = rmoveVal;
}

/*
============
Q3_SetLockAngle

?
============
*/
static void Q3_SetLockAngle(const int entID, const char* lockAngle)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLockAngle: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_SetLockAngle: '%s' is not an NPC/player!\n", ent->targetname);
		return;
	}
	if (!ent->NPC)
	{
		G_DebugPrint(
			WL_WARNING, "Q3_SetLockAngle doesn't work for clients at the moment. Ask if you really need it.\n");
		return;
	}

	if (Q_stricmp("off", lockAngle) == 0)
	{
		//free it
		ent->client->renderInfo.renderFlags &= ~RF_LOCKEDANGLE;
	}
	else
	{
		ent->client->renderInfo.renderFlags |= RF_LOCKEDANGLE;

		if (Q_stricmp("auto", lockAngle) == 0)
		{
			//use current yaw
			if (ent->NPC) // I need this to work on NPCs, so their locked value
			{
				ent->NPC->lockedDesiredYaw = NPCS.NPC->client->ps.viewangles[YAW];
				// could also set s.angles[1] and desiredYaw to this value...
			}
			else
			{
				ent->client->renderInfo.lockYaw = ent->client->ps.viewangles[YAW];
			}
		}
		else
		{
			//specified yaw
			if (ent->NPC) // I need this to work on NPCs, so their locked value
			{
				ent->NPC->lockedDesiredYaw = atof((char*)lockAngle);
				// could also set s.angles[1] and desiredYaw to this value...
			}
			else
			{
				ent->client->renderInfo.lockYaw = atof((char*)lockAngle);
			}
		}
	}
}

/*
============
Q3_CameraGroup

?
============
*/
static void Q3_CameraGroup(const int entID, char* camG)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent || !ent->inuse)
	{
		G_DebugPrint(WL_WARNING, "Q3_CameraGroup: Invalid Ent\n");
		return;
	}

	ent->cameraGroup = camG;
}

/*
============
Q3_CameraGroupZOfs

?
============
*/
static void Q3_CameraGroupZOfs(const float camGZOfs)
{
	client_camera.cameraGroupZOfs = camGZOfs;
}

/*
============
Q3_CameraGroup

?
============
*/
static void Q3_CameraGroupTag(const char* camGTag)
{
	Q_strncpyz(client_camera.cameraGroupTag, camGTag, sizeof client_camera.cameraGroupTag);
}

/*
============
Q3_RemoveRHandModel
============
*/
static void Q3_RemoveRHandModel(int entID, char* addModel)
{
	//G_DebugPrint(WL_WARNING, "Q3_RemoveRHandModel: NOT SUPPORTED IN MP\n");
}

/*
============
Q3_AddRHandModel
============
*/
static void Q3_AddRHandModel(int entID, char* addModel)
{
	//G_DebugPrint( WL_WARNING, "Q3_AddRHandModel: NOT SUPPORTED IN MP\n");
}

/*
============
Q3_AddLHandModel
============
*/
static void Q3_AddLHandModel(int entID, char* addModel)
{
	//G_DebugPrint( WL_WARNING, "Q3_AddLHandModel: NOT SUPPORTED IN MP\n");
}

/*
============
Q3_RemoveLHandModel
============
*/
static void Q3_RemoveLHandModel(int entID, char* addModel)
{
	//G_DebugPrint(WL_WARNING, "Q3_RemoveLHandModel: NOT SUPPORTED IN MP\n");
}

/*
============
Q3_LookTarget

?
============
*/
extern void NPC_SetLookTarget(const gentity_t* self, int entNum, int clear_time);
extern void NPC_ClearLookTarget(const gentity_t* self);

static void Q3_LookTarget(const int entID, char* targetName)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_LookTarget: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_LookTarget: '%s' is not an NPC/player!\n", ent->targetname);
		return;
	}

	if (Q_stricmp("none", targetName) == 0 || Q_stricmp("NULL", targetName) == 0)
	{
		//clearing look target
		NPC_ClearLookTarget(ent);
		return;
	}

	const gentity_t* targ = G_Find(NULL, FOFS(targetname), targetName);
	if (!targ)
	{
		targ = G_Find(NULL, FOFS(script_targetname), targetName);
		if (!targ)
		{
			targ = G_Find(NULL, FOFS(NPC_targetname), targetName);
			if (!targ)
			{
				if (strcmp(targetName, "player") == 0)
				{
					vec3_t viewspot;
					//players probably haven't spawned in yet.  just use the spawnpoin
					targ = SelectSPSpawnPoint(viewspot, viewspot);
				}

				if (!targ)
				{
					G_DebugPrint(WL_ERROR, "Q3_LookTarget: Can't find ent %s\n", targetName);
					return;
				}
			}
		}
	}

	NPC_SetLookTarget(ent, targ->s.number, 0);
}

/*
============
Q3_Face

?
============
*/
static void Q3_Face(const int entID, const int expression, float holdtime)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_Face: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_ERROR, "Q3_Face: '%s' is not an NPC/player!\n", ent->targetname);
		return;
	}

	//FIXME: change to milliseconds to be consistant!
	holdtime *= 1000;

	switch (expression)
	{
	case SET_FACEEYESCLOSED:
		ent->client->facial_blink = 1;
		break;
	case SET_FACEEYESOPENED:
		ent->client->facial_blink = -1;
		break;
	case SET_FACEBLINK:
		ent->client->facial_timer = -(level.time + holdtime);
		break;
	case SET_FACEAUX:
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_ALERT;
		break;
	case SET_FACEBLINKFROWN:
		ent->client->facial_blink = -(level.time + holdtime);
		//fall through
	case SET_FACEFROWN:
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_FROWN;
		break;
		//Extra facial expressions:
	case SET_FACESMILE:
		ent->client->facial_blink = -(level.time + holdtime);
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_SMILE;
		break;
	case SET_FACEGLAD:
		ent->client->facial_blink = 1;
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_TALK1;
		break;
	case SET_FACEHAPPY:
		ent->client->facial_blink = -(level.time + holdtime);
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_TALK1;
		break;
	case SET_FACESHOCKED:
		ent->client->facial_blink = -1;
		ent->client->facial_timer = -(level.time + holdtime);
		ent->client->facial_anim = FACE_TALK3;
		break;

	case SET_FACENORMAL:
		ent->client->facial_timer = level.time + Q_flrand(6000.0, 10000.0);
		ent->client->facial_blink = level.time + Q_flrand(3000.0, 5000.0);
		break;
	default:;
	}
}

/*
============
Q3_SetLocation
  Description	:
  Return type	: qboolean
  Argument		:  int entID
  Argument		: const char *location
============
*/
static qboolean Q3_SetLocation(const int entID, const char* location)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		return qtrue;
	}

	const char* currentLoc = G_GetLocationForEnt(ent);
	if (currentLoc && currentLoc[0] && Q_stricmp(location, currentLoc) == 0)
	{
		return qtrue;
	}

	ent->message = G_NewString(location);
	return qfalse;
}

/*
============
Q3_SetPlayerLocked
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean locked
============
*/
static void Q3_SetPlayerLocked(int entID, const qboolean locked)
{
	const gentity_t* ent = &g_entities[0];

	player_locked = locked;
	if (ent && ent->client)
	{
		//stop him too
		VectorClear(ent->client->ps.velocity);
	}
}

/*
============
Q3_SetLockPlayerWeapons
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean locked
============
*/
static void Q3_SetLockPlayerWeapons(int entID, const qboolean locked)
{
	gentity_t* ent = &g_entities[0];

	ent->flags &= ~FL_LOCK_PLAYER_WEAPONS;

	if (locked)
	{
		ent->flags |= FL_LOCK_PLAYER_WEAPONS;
	}
}

/*
============
Q3_SetNoImpactDamage
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean locked
============
*/
static void Q3_SetNoImpactDamage(const int entID, const qboolean noImp)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoImpactDamage: invalid entID %d\n", entID);
		return;
	}

	ent->flags &= ~FL_NO_IMPACT_DMG;

	if (noImp)
	{
		ent->flags |= FL_NO_IMPACT_DMG;
	}
}

/*
============
Q3_SetBehaviorSet

?
============
*/
static qboolean Q3_SetBehaviorSet(const int entID, const int toSet, const char* scriptname)
{
	gentity_t* ent = &g_entities[entID];
	bSet_t bSet = BSET_INVALID;

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetBehaviorSet: invalid entID %d\n", entID);
		return qfalse;
	}

	switch (toSet)
	{
	case SET_SPAWNSCRIPT:
		bSet = BSET_SPAWN;
		break;
	case SET_USESCRIPT:
		bSet = BSET_USE;
		break;
	case SET_AWAKESCRIPT:
		bSet = BSET_AWAKE;
		break;
	case SET_ANGERSCRIPT:
		bSet = BSET_ANGER;
		break;
	case SET_ATTACKSCRIPT:
		bSet = BSET_ATTACK;
		break;
	case SET_VICTORYSCRIPT:
		bSet = BSET_VICTORY;
		break;
	case SET_LOSTENEMYSCRIPT:
		bSet = BSET_LOSTENEMY;
		break;
	case SET_PAINSCRIPT:
		bSet = BSET_PAIN;
		break;
	case SET_FLEESCRIPT:
		bSet = BSET_FLEE;
		break;
	case SET_DEATHSCRIPT:
		bSet = BSET_DEATH;
		break;
	case SET_DELAYEDSCRIPT:
		bSet = BSET_DELAYED;
		break;
	case SET_BLOCKEDSCRIPT:
		bSet = BSET_BLOCKED;
		break;
	case SET_FFIRESCRIPT:
		bSet = BSET_FFIRE;
		break;
	case SET_FFDEATHSCRIPT:
		bSet = BSET_FFDEATH;
		break;
	case SET_MINDTRICKSCRIPT:
		bSet = BSET_MINDTRICK;
		break;
	default:;
	}

	if (bSet < BSET_SPAWN || bSet >= NUM_BSETS)
	{
		return qfalse;
	}

	if (!Q_stricmp("NULL", scriptname))
	{
		if (ent->behaviorSet[bSet] != NULL)
		{
			//			trap->TagFree( ent->behaviorSet[bSet] );
		}

		ent->behaviorSet[bSet] = NULL;
	}
	else
	{
		if (scriptname)
		{
			if (ent->behaviorSet[bSet] != NULL)
			{
				//				trap->TagFree( ent->behaviorSet[bSet] );
			}

			ent->behaviorSet[bSet] = G_NewString((char*)scriptname); //FIXME: This really isn't good...
		}
	}
	return qtrue;
}

/*
============
Q3_SetDelayScriptTime

?
============
*/
static void Q3_SetDelayScriptTime(const int entID, const int delayTime)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDelayScriptTime: invalid entID %d\n", entID);
		return;
	}

	ent->delayScriptTime = level.time + delayTime;
}

/*
============
Q3_SetPlayerUsable
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean usable
============
*/
static void Q3_SetPlayerUsable(const int entID, const qboolean usable)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetPlayerUsable: invalid entID %d\n", entID);
		return;
	}

	if (usable)
	{
		ent->r.svFlags |= SVF_PLAYER_USABLE;
	}
	else
	{
		ent->r.svFlags &= ~SVF_PLAYER_USABLE;
	}
}

/*
============
Q3_SetDisableShaderAnims
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int disabled
============
*/
static void Q3_SetDisableShaderAnims(const int entID, const int disabled)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDisableShaderAnims: invalid entID %d\n", entID);
		return;
	}

	if (disabled)
	{
		ent->s.eFlags |= EF_DISABLE_SHADER_ANIM;
	}
	else
	{
		ent->s.eFlags &= ~EF_DISABLE_SHADER_ANIM;
	}
}

/*
============
Q3_SetShaderAnim
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int disabled
============
*/
static void Q3_SetShaderAnim(const int entID, const int disabled)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetShaderAnim: invalid entID %d\n", entID);
		return;
	}

	if (disabled)
	{
		ent->s.eFlags |= EF_SHADER_ANIM;
	}
	else
	{
		ent->s.eFlags &= ~EF_SHADER_ANIM;
	}
}

/*
============
Q3_SetStartFrame
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int startFrame
============
*/
static void Q3_SetStartFrame(const int entID, const int startFrame)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetStartFrame: invalid entID %d\n", entID);
		return;
	}

	if (ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLoopAnim: command not valid on players/NPCs!\n");
		return;
	}

	if (startFrame >= 0)
	{
		ent->s.frame = startFrame;
		ent->startFrame = startFrame;
	}
}

/*
============
Q3_SetEndFrame
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int endFrame
============
*/
static void Q3_SetEndFrame(const int entID, const int endFrame)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetEndFrame: invalid entID %d\n", entID);
		return;
	}

	if (ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetEndFrame: command not valid on players/NPCs!\n");
		return;
	}

	if (endFrame >= 0)
	{
		ent->endFrame = endFrame;
	}
}

/*
============
Q3_SetAnimFrame
  Description	:
  Return type	: static void
  Argument		:  int entID
  Argument		: int startFrame
============
*/
static void Q3_SetAnimFrame(const int entID, const int animFrame)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAnimFrame: invalid entID %d\n", entID);
		return;
	}

	if (ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAnimFrame: command not valid on players/NPCs!\n");
		return;
	}

	if (animFrame >= ent->endFrame)
	{
		ent->s.frame = ent->endFrame;
	}
	else if (animFrame >= ent->startFrame)
	{
		ent->s.frame = animFrame;
	}
	else
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAnimFrame: value must be valid number between StartFrame and EndFrame.\n");
	}
}

/*
============
Q3_SetLoopAnim
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean loopAnim
============
*/
static void Q3_SetLoopAnim(const int entID, const qboolean loopAnim)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLoopAnim: invalid entID %d\n", entID);
		return;
	}

	if (ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetLoopAnim: command not valid on players/NPCs!\n");
		return;
	}

	ent->loopAnim = loopAnim;
}

/*
============
Q3_SetInterface
Description	:
Return type	: void
Argument		:  int entID
Argument		: const char *data
============
*/
static void Q3_SetInterface(int entID, const char* data)
{
	trap->Cvar_Set("cg_drawStatus", data);
}

/*
============
Q3_SetShields
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean shields
============
*/
static void Q3_SetShields(const int entID, const qboolean shields)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetShields: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetShields: '%s' is not an NPC!\n", ent->targetname);
		return;
	}

	if (shields)
	{
		ent->NPC->aiFlags |= NPCAI_SHIELDS;
	}
	else
	{
		ent->NPC->aiFlags &= ~NPCAI_SHIELDS;
	}
}

/*
============
Q3_SetSaberActive
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean shields
============
*/
static void Q3_SetSaberActive(const int entID, const qboolean active)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent || !ent->inuse)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetSaberActive: invalid entID %d\n", entID);
		return;
	}

	if (!ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetSaberActive: %d is not a client\n", entID);
	}

	//try to switch to the saber if we're not using it.
	if (ent && ent->client->ps.weapon != WP_SABER)
	{
		if (ent->client->ps.stats[STAT_WEAPONS] & 1 << WP_SABER)
		{
			//change to it right now
			if (ent->NPC)
			{
				ChangeWeapon(ent, WP_SABER);
			}
			else
			{
				const gitem_t* item = BG_FindItemForWeapon(WP_SABER);
				register_item(item); //make sure the weapon is cached in case this runs at startup
				G_AddEvent(ent, EV_ITEM_PICKUP, item - bg_itemlist);
			}
			ent->client->ps.weapon = WP_SABER;
			ent->client->ps.weaponstate = WEAPON_READY;
			G_AddEvent(ent, EV_GENERAL_SOUND, G_SoundIndex("sound/weapons/change.wav"));
		}
		else
		{
			G_DebugPrint(WL_ERROR, "Q3_SetSaberActive: '%s' is not using a saber!\n", ent->targetname);
			return;
		}
	}
	//was reversed
	if (!ent->client->ps.saberHolstered && !active)
	{
		Cmd_ToggleSaber_f(ent);
	}
	else if (BG_SabersOff(&ent->client->ps) && active)
	{
		Cmd_ToggleSaber_f(ent);
	}
}

/*
============
Q3_SetAdjustAreaPortals
Description	:
Return type	: void
Argument		:  int entID
Argument		: qboolean adjust
============
*/
static void Q3_SetAdjustAreaPortals(const int entID, const qboolean adjust)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetAdjustAreaPortals: invalid entID %d\n", entID);
		return;
	}

	trap->AdjustAreaPortalState((sharedEntity_t*)ent, adjust);
}

/*
============
Q3_SetDmgByHeavyWeapOnly
Description	:
Return type	: void
Argument		:  int entID
Argument		: qboolean dmg
============
*/
static void Q3_SetDmgByHeavyWeapOnly(const int entID, const qboolean dmg)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetDmgByHeavyWeapOnly: invalid entID %d\n", entID);
		return;
	}

	ent->flags = dmg ? ent->flags | FL_DMG_BY_HEAVY_WEAP_ONLY : ent->flags & ~FL_DMG_BY_HEAVY_WEAP_ONLY;
}

/*
============
Q3_SetShielded
Description	:
Return type	: void
Argument		:  int entID
Argument		: qboolean dmg
============
*/
static void Q3_SetShielded(const int entID, const qboolean dmg)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetShielded: invalid entID %d\n", entID);
		return;
	}

	ent->flags = dmg ? ent->flags | FL_SHIELDED : ent->flags & ~FL_SHIELDED;
}

/*
============
Q3_SetNoGroups
Description	:
Return type	: void
Argument		:  int entID
Argument		: qboolean noGroups
============
*/
static void Q3_SetNoGroups(const int entID, const qboolean noGroups)
{
	const gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoGroups: invalid entID %d\n", entID);
		return;
	}

	if (!ent->NPC)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoGroups: ent %s is not an NPC!\n", ent->targetname);
		return;
	}

	ent->NPC->scriptFlags = noGroups ? ent->NPC->scriptFlags | SCF_NO_GROUPS : ent->NPC->scriptFlags & ~SCF_NO_GROUPS;
}

/*
============
Q3_SetNoKnockback
  Description	:
  Return type	: void
  Argument		:  int entID
  Argument		: qboolean noKnockback
============
*/
static void Q3_SetNoKnockback(const int entID, const qboolean noKnockback)
{
	gentity_t* ent = &g_entities[entID];

	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetNoKnockback: invalid entID %d\n", entID);
		return;
	}

	if (noKnockback)
	{
		ent->flags |= FL_NO_KNOCKBACK;
	}
	else
	{
		ent->flags &= ~FL_NO_KNOCKBACK;
	}
}

/*
============
Q3_SetCleanDamagingEnts
  Description	:
  Return type	: void
============
*/
static void Q3_SetCleanDamagingEnts(void)
{
	for (int i = 0; i < ENTITYNUM_WORLD; i++)
	{
		gentity_t* ent = &g_entities[i];

		if (ent)
		{
			if (!ent->client && (ent->s.weapon == WP_DET_PACK || ent->s.weapon == WP_TRIP_MINE || ent->s.weapon ==
				WP_THERMAL))
			{
				// check for a client, otherwise we could remove someone holding this weapon
				G_FreeEntity(ent);
			}
			else if (ent->s.weapon == WP_TURRET && ent->activator && ent->activator->s.number == 0 && !Q_stricmp(
				"PAS", ent->classname))
			{
				// is a player owner personal assault sentry gun.
				G_FreeEntity(ent);
			}
			else if (ent->client && ent->client->NPC_class == CLASS_SEEKER)
			{
				// they blow up when they run out of ammo, so this may as well just do the same.
				G_Damage(ent, ent, ent, NULL, NULL, 999, 0, MOD_UNKNOWN);
			}
		}
	}
}

vec4_t textcolor_caption;
vec4_t textcolor_center;
vec4_t textcolor_scroll;

/*
-------------------------
Q3_SetTextColor
-------------------------
*/
#define Vector7Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])

static void Q3_SetTextColor(vec4_t textcolor, const char* color)
{
	if (Q_stricmp(color, "BLACK") == 0)
	{
		Vector7Copy(colorTable[CT_BLACK], textcolor);
	}
	else if (Q_stricmp(color, "RED") == 0)
	{
		Vector7Copy(colorTable[CT_RED], textcolor);
	}
	else if (Q_stricmp(color, "GREEN") == 0)
	{
		Vector7Copy(colorTable[CT_GREEN], textcolor);
	}
	else if (Q_stricmp(color, "YELLOW") == 0)
	{
		Vector7Copy(colorTable[CT_YELLOW], textcolor);
	}
	else if (Q_stricmp(color, "BLUE") == 0)
	{
		Vector7Copy(colorTable[CT_BLUE], textcolor);
	}
	else if (Q_stricmp(color, "CYAN") == 0)
	{
		Vector7Copy(colorTable[CT_CYAN], textcolor);
	}
	else if (Q_stricmp(color, "MAGENTA") == 0)
	{
		Vector7Copy(colorTable[CT_MAGENTA], textcolor);
	}
	else if (Q_stricmp(color, "WHITE") == 0)
	{
		Vector7Copy(colorTable[CT_WHITE], textcolor);
	}
	else
	{
		Vector7Copy(colorTable[CT_WHITE], textcolor);
	}
}

/*
=============
Q3_SetCaptionTextColor

Change color text prints in
=============
*/
static void Q3_SetCaptionTextColor(const char* color)
{
	Q3_SetTextColor(textcolor_caption, color);
}

/*
=============
Q3_SetCenterTextColor

Change color text prints in
=============
*/
static void Q3_SetCenterTextColor(const char* color)
{
	Q3_SetTextColor(textcolor_center, color);
}

/*
=============
Q3_SetScrollTextColor

Change color text prints in
=============
*/
static void Q3_SetScrollTextColor(const char* color)
{
	Q3_SetTextColor(textcolor_scroll, color);
}

/*
=============
Q3_ScrollText

Prints a message in the center of the screen
=============
*/
static void Q3_ScrollText(const char* id)
{
	trap->SendServerCommand(-1, va("st \"%s\"", id));
}

/*
=============
Q3_LCARSText

Prints a message in the center of the screen giving it an LCARS frame around it
=============
*/
static void Q3_LCARSText(const char* id)
{
	trap->SendServerCommand(-1, va("lt \"%s\"", id));
}

void un_lock_doors(gentity_t* ent);
void lock_doors(gentity_t* ent);
void UpdatePlayerCameraOrigin(const gentity_t* ent, vec3_t newPos);

//returns qtrue if it got to the end, otherwise qfalse.
qboolean Q3_Set(const int taskID, const int entID, const char* type_name, const char* data)
{
	gentity_t* ent = &g_entities[entID];
	float float_data;
	int int_data;
	vec3_t vector_data;
	vec3_t vector2_data;
	vec4_t color, color2;
	float float2_data;
	char char_data[1000];

	//Set this for callbacks
	const int toSet = GetIDForString(setTable, type_name);

	//TODO: Throw in a showscript command that will list each command and what they're doing...
	//		maybe as simple as printing that line of the script to the console preceeded by the person's name?
	//		showscript can take any number of targetnames or "all"?  Groupname?
	switch (toSet)
	{
	case SET_ORIGIN:
		if (sscanf(data, "%f %f %f", &vector_data[0], &vector_data[1], &vector_data[2]) != 3)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on SET_ORIGIN (%s)\n", type_name);
			VectorClear(vector_data);
		}
		G_SetOrigin(ent, vector_data);
		if (Q_strncmp("NPC_", ent->classname, 4) == 0)
		{
			//hack for moving spawners
			VectorCopy(vector_data, ent->s.origin);
		}
		if (in_camera && ent->s.number < MAX_CLIENTS)
		{
			//the players are currently in a cutscene.  This means that we need to change the player's stored origin.
			UpdatePlayerCameraOrigin(ent, vector_data);
		}

		//SP Code
		if (ent->client)
		{
			//clear jump start positions so we don't take damage when we land...
			ent->client->ps.fd.forceJumpZStart = vector_data[2];
		}
		trap->LinkEntity((sharedEntity_t*)ent);
		break;

	case SET_TELEPORT_DEST:
		if (sscanf(data, "%f %f %f", &vector_data[0], &vector_data[1], &vector_data[2]) != 3)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on SET_TELEPORT_DEST (%s)\n", type_name);
			VectorClear(vector_data);
		}
		if (!Q3_SetTeleportDest(entID, vector_data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
			return qfalse;
		}
		break;

	case SET_COPY_ORIGIN:
		Q3_SetCopyOrigin(entID, (char*)data);
		break;

	case SET_ANGLES:
		if (sscanf(data, "%f %f %f", &vector_data[0], &vector_data[1], &vector_data[2]) != 3)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on SET_ANGLES (%s)\n", type_name);
			VectorClear(vector_data);
		}
		Q3_SetAngles(entID, vector_data);
		break;

	case SET_XVELOCITY:
		float_data = atof((char*)data);
		Q3_SetVelocity(entID, 0, float_data);
		break;

	case SET_YVELOCITY:
		float_data = atof((char*)data);
		Q3_SetVelocity(entID, 1, float_data);
		break;

	case SET_ZVELOCITY:
		float_data = atof((char*)data);
		Q3_SetVelocity(entID, 2, float_data);
		break;

	case SET_Z_OFFSET:
		float_data = atof((char*)data);
		Q3_SetOriginOffset(entID, 2, float_data);
		break;

	case SET_ENEMY:
		Q3_SetEnemy(entID, (char*)data);
		break;

	case SET_LEADER:
		Q3_SetLeader(entID, (char*)data);
		break;

	case SET_NAVGOAL:
		if (Q3_SetNavGoal(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_MOVE_NAV, taskID);
			return qfalse; //Don't call it back
		}
		break;

	case SET_ANIM_UPPER:
		if (Q3_SetAnimUpper(entID, (char*)data))
		{
			Q3_TaskIDClear(&ent->taskID[TID_ANIM_BOTH]); //We only want to wait for the top
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_UPPER, taskID);
			return qfalse; //Don't call it back
		}
		break;

	case SET_ANIM_LOWER:
		if (Q3_SetAnimLower(entID, (char*)data))
		{
			Q3_TaskIDClear(&ent->taskID[TID_ANIM_BOTH]); //We only want to wait for the bottom
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_LOWER, taskID);
			return qfalse; //Don't call it back
		}
		break;

	case SET_ANIM_BOTH:
	{
		int both = 0;
		if (Q3_SetAnimUpper(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_UPPER, taskID);
			both++;
		}
		else
		{
			G_DebugPrint(WL_ERROR, "Q3_SetAnimUpper: %s does not have anim %s!\n", ent->targetname, (char*)data);
		}
		if (Q3_SetAnimLower(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_LOWER, taskID);
			both++;
		}
		else
		{
			G_DebugPrint(WL_ERROR, "Q3_SetAnimLower: %s does not have anim %s!\n", ent->targetname, (char*)data);
		}
		if (both >= 2)
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_BOTH, taskID);
		}
		if (both)
		{
			return qfalse; //Don't call it back
		}
	}
	break;

	case SET_ANIM_HOLDTIME_LOWER:
		int_data = atoi((char*)data);
		Q3_SetAnimHoldTime(entID, int_data, qtrue);
		Q3_TaskIDClear(&ent->taskID[TID_ANIM_BOTH]); //We only want to wait for the bottom
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_LOWER, taskID);
		return qfalse; //Don't call it back

	case SET_ANIM_HOLDTIME_UPPER:
		int_data = atoi((char*)data);
		Q3_SetAnimHoldTime(entID, int_data, qfalse);
		Q3_TaskIDClear(&ent->taskID[TID_ANIM_BOTH]); //We only want to wait for the top
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_UPPER, taskID);
		return qfalse; //Don't call it back

	case SET_ANIM_HOLDTIME_BOTH:
		int_data = atoi((char*)data);
		Q3_SetAnimHoldTime(entID, int_data, qfalse);
		Q3_SetAnimHoldTime(entID, int_data, qtrue);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_BOTH, taskID);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_UPPER, taskID);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_LOWER, taskID);
		return qfalse; //Don't call it back

	case SET_PLAYER_TEAM:
		Q3_SetPlayerTeam(entID, (char*)data);
		return qfalse;

	case SET_ENEMY_TEAM:
		Q3_SetEnemyTeam(entID, (char*)data);
		return qfalse;

	case SET_HEALTH:
		int_data = atoi((char*)data);
		Q3_SetHealth(entID, int_data);
		break;

	case SET_ARMOR:
		int_data = atoi((char*)data);
		Q3_SetArmor(entID, int_data);
		break;

	case SET_BEHAVIOR_STATE:
		if (!Q3_SetBState(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_BSTATE, taskID);
			return qfalse; //don't complete
		}
		break;

	case SET_DEFAULT_BSTATE:
		Q3_SetDefaultBState(entID, (char*)data);
		break;

	case SET_TEMP_BSTATE:
		if (!Q3_SetTempBState(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_BSTATE, taskID);
			return qfalse; //don't complete
		}
		break;

	case SET_CAPTURE:
		Q3_SetCaptureGoal(entID, (char*)data);
		break;

	case SET_DPITCH:
		//FIXME: make these set tempBehavior to BS_FACE and await completion?  Or set lockedDesiredPitch/Yaw and aimTime?
		float_data = atof((char*)data);
		Q3_SetDPitch(entID, float_data);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANGLE_FACE, taskID);
		return qfalse;

	case SET_DYAW:
		float_data = atof((char*)data);
		Q3_SetDYaw(entID, float_data);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANGLE_FACE, taskID);
		return qfalse;

	case SET_EVENT:
		Q3_SetEvent(entID, (char*)data);
		break;

	case SET_VIEWTARGET:
		Q3_SetViewTarget(entID, (char*)data);
		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANGLE_FACE, taskID);
		return qfalse;

	case SET_WATCHTARGET:
		Q3_SetWatchTarget(entID, (char*)data);
		break;

	case SET_VIEWENTITY:
		Q3_SetViewEntity(entID, (char*)data);
		break;

	case SET_LOOPSOUND:
		Q3_SetLoopSound(entID, (char*)data);
		break;

	case SET_ICARUS_FREEZE:
	case SET_ICARUS_UNFREEZE:
		Q3_SetICARUSFreeze(entID, (char*)data, toSet == SET_ICARUS_FREEZE);
		break;

	case SET_WEAPON:
		Q3_SetWeapon(entID, (char*)data);
		break;

	case SET_ITEM:
		Q3_SetItem(entID, (char*)data);
		break;

	case SET_WALKSPEED:
		int_data = atoi((char*)data);
		Q3_SetWalkSpeed(entID, int_data);
		break;

	case SET_RUNSPEED:
		int_data = atoi((char*)data);
		Q3_SetRunSpeed(entID, int_data);
		break;

	case SET_WIDTH:
		int_data = atoi((char*)data);
		Q3_SetWidth(entID, int_data);
		return qfalse;

	case SET_YAWSPEED:
		float_data = atof((char*)data);
		Q3_SetYawSpeed(entID, float_data);
		break;

	case SET_AGGRESSION:
		int_data = atoi((char*)data);
		Q3_SetAggression(entID, int_data);
		break;

	case SET_AIM:
		int_data = atoi((char*)data);
		Q3_SetAim(entID, int_data);
		break;

	case SET_FRICTION:
		int_data = atoi((char*)data);
		Q3_SetFriction(entID, int_data);
		break;

	case SET_GRAVITY:
		float_data = atof((char*)data);
		Q3_SetGravity(entID, float_data);
		break;

	case SET_WAIT:
		float_data = atof((char*)data);
		Q3_SetWait(entID, float_data);
		break;

	case SET_FOLLOWDIST:
		float_data = atof((char*)data);
		Q3_SetFollowDist(entID, float_data);
		break;

	case SET_SCALE:
		float_data = atof((char*)data);
		Q3_SetScale(entID, float_data);
		break;

	case SET_RENDER_CULL_RADIUS:
		float_data = atof((char*)data);
		Q3_SetRenderCullRadius(entID, float_data);
		break;

	case SET_COUNT:
		Q3_SetCount(entID, (char*)data);
		break;

	case SET_SHOT_SPACING:
		int_data = atoi((char*)data);
		Q3_SetShotSpacing(entID, int_data);
		break;

	case SET_IGNOREPAIN:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetIgnorePain(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetIgnorePain(entID, qfalse);
		break;

	case SET_IGNOREENEMIES:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetIgnoreEnemies(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetIgnoreEnemies(entID, qfalse);
		break;

	case SET_IGNOREALERTS:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetIgnoreAlerts(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetIgnoreAlerts(entID, qfalse);
		break;

	case SET_DONTSHOOT:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetDontShoot(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetDontShoot(entID, qfalse);
		break;

	case SET_DONTFIRE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetDontFire(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetDontFire(entID, qfalse);
		break;

	case SET_LOCKED_ENEMY:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetLockedEnemy(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetLockedEnemy(entID, qfalse);
		break;

	case SET_NOTARGET:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoTarget(entID, qtrue);
		else if (!Q_stricmp("false", (char*)data))
			Q3_SetNoTarget(entID, qfalse);
		break;

	case SET_LEAN:
		if (!Q_stricmp("right", (char*)data))
			Q3_SetLean(entID, LEAN_RIGHT);
		else if (!Q_stricmp("left", (char*)data))
			Q3_SetLean(entID, LEAN_LEFT);
		else
			Q3_SetLean(entID, LEAN_NONE);
		break;

	case SET_SHOOTDIST:
		float_data = atof((char*)data);
		Q3_SetShootDist(entID, float_data);
		break;

	case SET_TIMESCALE:
		Q3_SetTimeScale(entID, (char*)data);
		break;

	case SET_VISRANGE:
		float_data = atof((char*)data);
		Q3_SetVisrange(entID, float_data);
		break;

	case SET_EARSHOT:
		float_data = atof((char*)data);
		Q3_SetEarshot(entID, float_data);
		break;

	case SET_VIGILANCE:
		float_data = atof((char*)data);
		Q3_SetVigilance(entID, float_data);
		break;

	case SET_VFOV:
		int_data = atoi((char*)data);
		Q3_SetVFOV(entID, int_data);
		break;

	case SET_HFOV:
		int_data = atoi((char*)data);
		Q3_SetHFOV(entID, int_data);
		break;

	case SET_TARGETNAME:
		Q3_SetTargetName(entID, (char*)data);
		break;

	case SET_TARGET:
		Q3_SetTarget(entID, (char*)data);
		break;

	case SET_TARGET2:
		Q3_SetTarget2(entID, (char*)data);
		break;

	case SET_LOCATION:
		if (!Q3_SetLocation(entID, (char*)data))
		{
			trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_LOCATION, taskID);
			return qfalse;
		}
		break;

	case SET_PAINTARGET:
		Q3_SetPainTarget(entID, (char*)data);
		break;

	case SET_DEFEND_TARGET:
		G_DebugPrint(WL_WARNING, "Q3_SetDefendTarget unimplemented\n", entID);
		break;

	case SET_PARM1:
	case SET_PARM2:
	case SET_PARM3:
	case SET_PARM4:
	case SET_PARM5:
	case SET_PARM6:
	case SET_PARM7:
	case SET_PARM8:
	case SET_PARM9:
	case SET_PARM10:
	case SET_PARM11:
	case SET_PARM12:
	case SET_PARM13:
	case SET_PARM14:
	case SET_PARM15:
	case SET_PARM16:
		Q3_SetParm(entID, toSet - SET_PARM1, (char*)data);
		break;

	case SET_SPAWNSCRIPT:
	case SET_USESCRIPT:
	case SET_AWAKESCRIPT:
	case SET_ANGERSCRIPT:
	case SET_ATTACKSCRIPT:
	case SET_VICTORYSCRIPT:
	case SET_PAINSCRIPT:
	case SET_FLEESCRIPT:
	case SET_DEATHSCRIPT:
	case SET_DELAYEDSCRIPT:
	case SET_BLOCKEDSCRIPT:
	case SET_FFIRESCRIPT:
	case SET_FFDEATHSCRIPT:
	case SET_MINDTRICKSCRIPT:
		if (!Q3_SetBehaviorSet(entID, toSet, (char*)data))
			G_DebugPrint(WL_ERROR, "Q3_SetBehaviorSet: Invalid bSet %s\n", type_name);
		break;

	case SET_NO_MINDTRICK:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoMindTrick(entID, qtrue);
		else
			Q3_SetNoMindTrick(entID, qfalse);
		break;

	case SET_CINEMATIC_SKIPSCRIPT:
		Q3_SetCinematicSkipScript((char*)data);
		break;

	case SET_DELAYSCRIPTTIME:
		int_data = atoi((char*)data);
		Q3_SetDelayScriptTime(entID, int_data);
		break;

	case SET_CROUCHED:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetCrouched(entID, qtrue);
		else
			Q3_SetCrouched(entID, qfalse);
		break;

	case SET_WALKING:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetWalking(entID, qtrue);
		else
			Q3_SetWalking(entID, qfalse);
		break;

	case SET_RUNNING:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetRunning(entID, qtrue);
		else
			Q3_SetRunning(entID, qfalse);
		break;

	case SET_CHASE_ENEMIES:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetChaseEnemies(entID, qtrue);
		else
			Q3_SetChaseEnemies(entID, qfalse);
		break;

	case SET_LOOK_FOR_ENEMIES:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetLookForEnemies(entID, qtrue);
		else
			Q3_SetLookForEnemies(entID, qfalse);
		break;

	case SET_FACE_MOVE_DIR:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetFaceMoveDir(entID, qtrue);
		else
			Q3_SetFaceMoveDir(entID, qfalse);
		break;

	case SET_altFire:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetAltFire(entID, qtrue);
		else
			Q3_SetAltFire(entID, qfalse);
		break;

	case SET_DONT_FLEE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetDontFlee(entID, qtrue);
		else
			Q3_SetDontFlee(entID, qfalse);
		break;

	case SET_FORCED_MARCH:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetForcedMarch(entID, qtrue);
		else
			Q3_SetForcedMarch(entID, qfalse);
		break;

	case SET_NO_RESPONSE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoResponse(entID, qtrue);
		else
			Q3_SetNoResponse(entID, qfalse);
		break;

	case SET_NO_COMBAT_TALK:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetCombatTalk(entID, qtrue);
		else
			Q3_SetCombatTalk(entID, qfalse);
		break;

	case SET_NO_ALERT_TALK:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetAlertTalk(entID, qtrue);
		else
			Q3_SetAlertTalk(entID, qfalse);
		break;

	case SET_USE_CP_NEAREST:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetUseCpNearest(entID, qtrue);
		else
			Q3_SetUseCpNearest(entID, qfalse);
		break;

	case SET_NO_FORCE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoForce(entID, qtrue);
		else
			Q3_SetNoForce(entID, qfalse);
		break;

	case SET_NO_ACROBATICS:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoAcrobatics(entID, qtrue);
		else
			Q3_SetNoAcrobatics(entID, qfalse);
		break;

	case SET_USE_SUBTITLES:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetUseSubtitles(entID, qtrue);
		else
			Q3_SetUseSubtitles(entID, qfalse);
		break;

	case SET_NO_FALLTODEATH:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoFallToDeath(entID, qtrue);
		else
			Q3_SetNoFallToDeath(entID, qfalse);
		break;

	case SET_DISMEMBERABLE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetDismemberable(entID, qtrue);
		else
			Q3_SetDismemberable(entID, qfalse);
		break;

	case SET_MORELIGHT:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetMoreLight(entID, qtrue);
		else
			Q3_SetMoreLight(entID, qfalse);
		break;

	case SET_TREASONED:
		G_DebugPrint(WL_VERBOSE, "SET_TREASONED is disabled, do not use\n");
		break;

	case SET_UNDYING:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetUndying(entID, qtrue);
		else
			Q3_SetUndying(entID, qfalse);
		break;

	case SET_INVINCIBLE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetInvincible(entID, qtrue);
		else
			Q3_SetInvincible(entID, qfalse);
		break;

	case SET_NOAVOID:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoAvoid(entID, qtrue);
		else
			Q3_SetNoAvoid(entID, qfalse);
		break;

	case SET_SOLID:
		if (!Q_stricmp("true", (char*)data))
		{
			if (!Q3_SetSolid(entID, qtrue))
			{
				trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_RESIZE, taskID);
				return qfalse;
			}
		}
		else
		{
			Q3_SetSolid(entID, qfalse);
		}
		break;

	case SET_INVISIBLE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetInvisible(entID, qtrue);
		else
			Q3_SetInvisible(entID, qfalse);
		break;

	case SET_VAMPIRE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetVampire(entID, qtrue);
		else
			Q3_SetVampire(entID, qfalse);
		break;

	case SET_FORCE_INVINCIBLE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetForceInvincible(entID, qtrue);
		else
			Q3_SetForceInvincible(entID, qfalse);
		break;

	case SET_GREET_ALLIES:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetGreetAllies(entID, qtrue);
		else
			Q3_SetGreetAllies(entID, qfalse);
		break;

	case SET_PLAYER_LOCKED:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetPlayerLocked(entID, qtrue);
		else
			Q3_SetPlayerLocked(entID, qfalse);
		break;

	case SET_LOCK_PLAYER_WEAPONS:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetLockPlayerWeapons(entID, qtrue);
		else
			Q3_SetLockPlayerWeapons(entID, qfalse);
		break;

	case SET_NO_IMPACT_DAMAGE:
		if (!Q_stricmp("true", (char*)data))
			Q3_SetNoImpactDamage(entID, qtrue);
		else
			Q3_SetNoImpactDamage(entID, qfalse);
		break;

	case SET_FORWARDMOVE:
		int_data = atoi((char*)data);
		Q3_SetForwardMove(entID, int_data);
		break;

	case SET_RIGHTMOVE:
		int_data = atoi((char*)data);
		Q3_SetRightMove(entID, int_data);
		break;

	case SET_LOCKYAW:
		Q3_SetLockAngle(entID, data);
		break;

	case SET_CAMERA_GROUP:
		Q3_CameraGroup(entID, (char*)data);
		break;
	case SET_CAMERA_GROUP_Z_OFS:
		float_data = atof((char*)data);
		Q3_CameraGroupZOfs(float_data);
		break;
	case SET_CAMERA_GROUP_TAG:
		Q3_CameraGroupTag((char*)data);
		break;

		//FIXME: put these into camera commands
	case SET_LOOK_TARGET:
		Q3_LookTarget(entID, (char*)data);
		break;

	case SET_ADDRHANDBOLT_MODEL:
		Q3_AddRHandModel(entID, (char*)data);
		break;

	case SET_REMOVERHANDBOLT_MODEL:
		Q3_RemoveRHandModel(entID, (char*)data);
		break;

	case SET_ADDLHANDBOLT_MODEL:
		Q3_AddLHandModel(entID, (char*)data);
		break;

	case SET_REMOVELHANDBOLT_MODEL:
		Q3_RemoveLHandModel(entID, (char*)data);
		break;

	case SET_FACEEYESCLOSED:
	case SET_FACEEYESOPENED:
	case SET_FACEAUX:
	case SET_FACEBLINK:
	case SET_FACEBLINKFROWN:
	case SET_FACEFROWN:
	case SET_FACESMILE:
	case SET_FACEGLAD:
	case SET_FACEHAPPY:
	case SET_FACESHOCKED:
	case SET_FACENORMAL:
		float_data = atof((char*)data);
		Q3_Face(entID, toSet, float_data);
		break;

	case SET_SCROLLTEXT:
		Q3_ScrollText((char*)data);
		break;

	case SET_LCARSTEXT:
		Q3_LCARSText((char*)data);
		break;

	case SET_CAPTIONTEXTCOLOR:
		Q3_SetCaptionTextColor((char*)data);
		break;
	case SET_CENTERTEXTCOLOR:
		Q3_SetCenterTextColor((char*)data);
		break;
	case SET_SCROLLTEXTCOLOR:
		Q3_SetScrollTextColor((char*)data);
		break;

	case SET_PLAYER_USABLE:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetPlayerUsable(entID, qtrue);
		}
		else
		{
			Q3_SetPlayerUsable(entID, qfalse);
		}
		break;

	case SET_STARTFRAME:
		int_data = atoi((char*)data);
		Q3_SetStartFrame(entID, int_data);
		break;

	case SET_ENDFRAME:
		int_data = atoi((char*)data);
		Q3_SetEndFrame(entID, int_data);

		trap->ICARUS_TaskIDSet((sharedEntity_t*)ent, TID_ANIM_BOTH, taskID);
		return qfalse;

	case SET_ANIMFRAME:
		int_data = atoi((char*)data);
		Q3_SetAnimFrame(entID, int_data);
		return qfalse;

	case SET_LOOP_ANIM:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetLoopAnim(entID, qtrue);
		}
		else
		{
			Q3_SetLoopAnim(entID, qfalse);
		}
		break;

	case SET_INTERFACE:

		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetInterface(entID, "1");
		}
		else
		{
			Q3_SetInterface(entID, "0");
		}

		break;

	case SET_SHIELDS:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetShields(entID, qtrue);
		}
		else
		{
			Q3_SetShields(entID, qfalse);
		}
		break;

	case SET_SABERACTIVE:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetSaberActive(entID, qtrue);
		}
		else
		{
			Q3_SetSaberActive(entID, qfalse);
		}
		break;

	case SET_ADJUST_AREA_PORTALS:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetAdjustAreaPortals(entID, qtrue);
		}
		else
		{
			Q3_SetAdjustAreaPortals(entID, qfalse);
		}
		break;

	case SET_DMG_BY_HEAVY_WEAP_ONLY:
		if (stricmp("true", (char*)data) == 0)
		{
			Q3_SetDmgByHeavyWeapOnly(entID, qtrue);
		}
		else
		{
			Q3_SetDmgByHeavyWeapOnly(entID, qfalse);
		}
		break;

	case SET_SHIELDED:
		if (stricmp("true", (char*)data) == 0)
		{
			Q3_SetShielded(entID, qtrue);
		}
		else
		{
			Q3_SetShielded(entID, qfalse);
		}
		break;

	case SET_NO_GROUPS:
		if (stricmp("true", (char*)data) == 0)
		{
			Q3_SetNoGroups(entID, qtrue);
		}
		else
		{
			Q3_SetNoGroups(entID, qfalse);
		}
		break;

	case SET_FIRE_WEAPON:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetFireWeapon(entID, qtrue);
		}
		else if (!Q_stricmp("false", (char*)data))
		{
			Q3_SetFireWeapon(entID, qfalse);
		}
		break;
	case SET_SAFE_REMOVE:
		if (stricmp("true", (char*)data) == 0)
		{
			Q3_SetSafeRemove(entID, qtrue);
		}
		else if (stricmp("false", (char*)data) == 0)
		{
			Q3_SetSafeRemove(entID, qfalse);
		}
		break;

	case SET_INACTIVE:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetInactive(entID, qtrue);
		}
		else if (!Q_stricmp("false", (char*)data))
		{
			Q3_SetInactive(entID, qfalse);
		}
		else if (!Q_stricmp("unlocked", (char*)data))
		{
			un_lock_doors(&g_entities[entID]);
		}
		else if (!Q_stricmp("locked", (char*)data))
		{
			lock_doors(&g_entities[entID]);
		}
		break;
	case SET_END_SCREENDISSOLVE:
		//G_DebugPrint( WL_WARNING, "SET_END_SCREENDISSOLVE: NOT SUPPORTED IN MP\n");
		break;

	case SET_MISSION_STATUS_SCREEN:
		//Cvar_Set("cg_missionstatusscreen", "1");
		//G_DebugPrint( WL_WARNING, "SET_MISSION_STATUS_SCREEN: NOT SUPPORTED IN MP\n");
		break;

	case SET_FUNC_USABLE_VISIBLE:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetFuncUsableVisible(entID, qtrue);
		}
		else if (!Q_stricmp("false", (char*)data))
		{
			Q3_SetFuncUsableVisible(entID, qfalse);
		}
		break;

	case SET_NO_KNOCKBACK:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetNoKnockback(entID, qtrue);
		}
		else
		{
			Q3_SetNoKnockback(entID, qfalse);
		}
		break;

	case SET_VIDEO_PLAY:
		if (g_allowROQ.integer)
		{
			trap->SendServerCommand(-1, va("inGameCinematic %s", (char*)data));
			inGameCinematic = qtrue;
		}
		break;

	case SET_VIDEO_FADE_IN:
		ICam_Fade(colorClear, colorBlack, 2000);
		break;

	case SET_VIDEO_FADE_OUT:
		//uh for now we're just going to use the camera fade code.
		ICam_Fade(colorBlack, colorClear, 2000);
		break;
	case SET_REMOVE_TARGET:
		Q3_SetRemoveTarget(entID, data);
		break;

	case SET_LOADGAME:
		//trap->SendConsoleCommand( va("load %s\n", (const char *) data ) );
		//G_DebugPrint( WL_WARNING, "SET_LOADGAME: NOT SUPPORTED IN MP\n");
		break;

	case SET_MENU_SCREEN:
		//UI_SetActiveMenu( (const char *) data );
		break;

	case SET_OBJECTIVE_SHOW:
		//trap->SendServerCommand(-1, "cp \"^1May the Force be with you.\n\"");
		//trap->SE_GetStringTextString(va("OBJECTIVES_%s", data), char_data, sizeof(char_data));
		ObjectivePrint_Line();
		break;
	case SET_OBJECTIVE_HIDE:
		//G_DebugPrint(WL_WARNING, "SET_OBJECTIVE_HIDE: NOT SUPPORTED IN MP\n");
		break;
	case SET_OBJECTIVE_SUCCEEDED:
		trap->SendServerCommand(-1, "cp \"^1You have sucsessfully compleated your objective.\n\"");
		break;
	case SET_OBJECTIVE_FAILED:
		trap->SendServerCommand(-1, "cp \"^1You have failed your objective.\n\"");
		break;

	case SET_OBJECTIVE_CLEARALL:
		//G_DebugPrint(WL_WARNING, "SET_OBJECTIVE_CLEARALL: NOT SUPPORTED IN MP\n");
		break;

	case SET_MISSIONFAILED:
		trap->SendServerCommand(-1, "cp \"^1You have failed your mission.\n\"");
		LogExit("Co-Op Mission Failed.");
		//we want the intermission to activate a little slower than normal.
		level.intermissionQueued = level.time + 5000;
		break;

	case SET_MISSIONSTATUSTEXT:
		//G_DebugPrint( WL_WARNING, "SET_MISSIONSTATUSTEXT: NOT SUPPORTED IN MP\n");
		break;

	case SET_MISSIONSTATUSTIME:
		//G_DebugPrint( WL_WARNING, "SET_MISSIONSTATUSTIME: NOT SUPPORTED IN MP\n");
		break;

	case SET_CLOSINGCREDITS:
		//G_DebugPrint( WL_WARNING, "SET_CLOSINGCREDITS: NOT SUPPORTED IN MP\n");
		break;

	case SET_SKILL:
		//can never be set
		break;

	case SET_FULLNAME:
		Q3_SetFullName(entID, (char*)data);
		break;

	case SET_DISABLE_SHADER_ANIM:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetDisableShaderAnims(entID, qtrue);
		}
		else
		{
			Q3_SetDisableShaderAnims(entID, qfalse);
		}
		break;

	case SET_SHADER_ANIM:
		if (!Q_stricmp("true", (char*)data))
		{
			Q3_SetShaderAnim(entID, qtrue);
		}
		else
		{
			Q3_SetShaderAnim(entID, qfalse);
		}
		break;

	case SET_MUSIC_STATE:
		Q3_SetMusicState((char*)data);
		break;

	case SET_CLEAN_DAMAGING_ENTS:
		Q3_SetCleanDamagingEnts();
		break;

	case SET_HUD:
		if (!Q_stricmp("true", (char*)data))
		{
			trap->Cvar_Set("cg_drawHUD", "1");
		}
		else
		{
			trap->Cvar_Set("cg_drawHUD", "0");
		}
		break;

	case SET_NO_PVS_CULL:
		Q3_SetBroadcast(entID, Q_stricmp("true", (char*)data) == 0);
		break;

	case SET_FORCE_PULL:
		Q3_SetForcePower(entID, FP_PULL, Q_stricmp("true", (char*)data) == 0);
		break;

	case SET_FORCE_PROTECT:
		Q3_SetForcePower(entID, FP_PROTECT, Q_stricmp("true", (char*)data) == 0);
		break;

	case SET_WINTER_GEAR:
		int_data = (qboolean)(Q_stricmp("true", (char*)data) == 0);
		if (WinterGear != int_data)
		{
			////toggle the winter gear varible.
			WinterGear = int_data;

			//update the models for all the players
			for (int_data = 0; int_data < level.maxclients; int_data++)
			{
				client_userinfo_changed(int_data);
			}

			//make sure the given ent changes gear if they are an NPC
			if (ent->NPC && ent->NPC_type && stricmp(ent->NPC_type, "player") == 0)
			{
				ToggleNPCWinterGear(ent);
			}
		}
		break;

	case SET_FORCE_HEAL_LEVEL:
	case SET_FORCE_JUMP_LEVEL:
	case SET_FORCE_SPEED_LEVEL:
	case SET_FORCE_PUSH_LEVEL:
	case SET_FORCE_PULL_LEVEL:
	case SET_FORCE_MINDTRICK_LEVEL:
	case SET_FORCE_GRIP_LEVEL:
	case SET_FORCE_LIGHTNING_LEVEL:
	case SET_SABER_THROW:
	case SET_SABER_DEFENSE:
	case SET_SABER_OFFENSE:
	case SET_FORCE_RAGE_LEVEL:
	case SET_FORCE_PROTECT_LEVEL:
	case SET_FORCE_ABSORB_LEVEL:
	case SET_FORCE_DRAIN_LEVEL:
	case SET_FORCE_SIGHT_LEVEL:
		int_data = atoi((char*)data);
		Q3_SetForcePowerLevel(entID, toSet - SET_FORCE_HEAL_LEVEL, int_data);
		break;

	case ENABLE: //camera enable
		ICam_Enable();
		break;

	case PAN:
		ParseTags(entID, data);
		//0.000 0.000 0.000, < 0.000 0.000 0.000 >, 0
		if (sscanf(data, "%*s %f %f %f %*s %*s %f %f %f %*s %f", &vector_data[0], &vector_data[1],
			&vector_data[2], &vector2_data[0], &vector2_data[1], &vector2_data[2], &float_data) != 7)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on PAN (%s)\n", type_name);
			VectorClear(vector_data);
			VectorClear(vector2_data);
		}

		ICam_Pan(vector_data, vector2_data, float_data);
		break;

	case FADE:
		//< 0.000 0.000 0.000 >, 1.000, < 0.000 0.000 0.000 >, 1.000, 0
		if (sscanf(data, "%*s %f %f %f %*s %f %*s %*s %f %f %f %*s %f %*s %f", &color[0],
			&color[1], &color[2], &color[3], &color2[0], &color2[1], &color2[2], &color2[3],
			&float_data) != 9)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on FADE (%s)\n", type_name);
			VectorClear(color);
			VectorClear(color2);
		}
		ICam_Fade(color, color2, float_data);
		break;
	case ZOOM:
		//65.000, 5500
		if (sscanf(data, "%f %*s %f", &float_data, &float2_data) != 2)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on ZOOM (%s)\n", type_name);
		}
		ICam_Zoom(float_data, float2_data);
		break;

	case DISABLE:
		ICam_Disable();
		break;

	case SHAKE:
		if (sscanf(data, "%f %*s %i", &float_data, &int_data) != 2)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on SHAKE (%s)\n", type_name);
		}
		ICam_Shake(float_data, int_data);
		break;

	case FOLLOW:
		if (sscanf(data, "%s %f %*s %f", &char_data[0], &float_data, &float2_data) != 3)
		{
			G_DebugPrint(WL_WARNING, "Q3_Set: failed sscanf on FOLLOW (%s)\n", type_name);
		}
		RemoveComma(char_data);
		ICam_Follow(char_data, float_data, float2_data);
		break;

	default:
		//trap->ICARUS_SetVar( taskID, entID, type_name, data );
		SetVar(type_name, data);
		break;
	}

	return qtrue;
}

//server side camera enable
void ICam_Enable(void)
{
	trap->SetConfigstring(CS_CAMERA, "enable");

	in_camera = qtrue;

	GCam_Enable();
}

//camera disable
void ICam_Disable(void)
{
	trap->SetConfigstring(CS_CAMERA, "disable");

	in_camera = qfalse;

	if (skippingCutscene)
	{
		trap->Cvar_Set("timescale", "1");
		skippingCutscene = qfalse;
	}

	GCam_Disable();
}

//move camera
void ICam_Move(vec3_t dest, const float duration)
{
	trap->SetConfigstring(CS_CAMERA, va("move %f %f %f %f", dest[0], dest[1], dest[2], duration));

	GCam_Move(dest, duration);
}

void ICam_Pan(vec3_t dest, vec3_t panDirection, const float duration)
{
	trap->SetConfigstring(CS_CAMERA, va("pan %f %f %f %f %f %f %f", dest[0], dest[1],
		dest[2], panDirection[0], panDirection[1], panDirection[2], duration));

	GCam_Pan(dest, panDirection, duration);
}

void ICam_Zoom(const float FOV, const float duration)
{
	trap->SetConfigstring(CS_CAMERA, va("zoom %f %f", FOV, duration));
}

void ICam_Fade(vec4_t source, vec4_t dest, const float duration)
{
	trap->SetConfigstring(CS_CAMERA, va("fade %f %f %f %f %f %f %f %f %f", source[0],
		source[1], source[2], source[3], dest[0], dest[1], dest[2], dest[3], duration));
}

void ICam_Follow(const char* cameraGroup, const float speed, const float initLerp)
{
	int CGroup[16] = { -1 }; //MAX_CAMERA_GROUP_SUBJECTS
	int num_subjects = 0;
	gentity_t* from = NULL;

	if (!cameraGroup || !cameraGroup[0])
	{
		return;
	}

	if (Q_stricmp("none", (char*)cameraGroup) == 0
		|| Q_stricmp("NULL", (char*)cameraGroup) == 0)
	{
		//Turn off all aiming
		trap->SetConfigstring(CS_CAMERA, "follow -2");
		//te->s.legsAnim = -1;
		return;
	}

	//figure out the entity_nums of the entities in this cameraGroup
	while (NULL != (from = G_Find(from, FOFS(cameraGroup), cameraGroup)))
	{
		if (num_subjects >= 16) //MAX_CAMERA_GROUP_SUBJECTS
		{
			G_DebugPrint(WL_WARNING, "ERROR: Too many subjects in shot composition %s", cameraGroup);
			break;
		}

		if (from)
		{
			//add to the CGroup
			CGroup[num_subjects] = from->s.number;
			num_subjects++;
		}
	}

	trap->SetConfigstring(CS_CAMERA, va("follow %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %f %f",
		CGroup[0], CGroup[1], CGroup[2], CGroup[3], CGroup[4], CGroup[5], CGroup[6],
		CGroup[7], CGroup[8], CGroup[9], CGroup[10], CGroup[11], CGroup[12], CGroup[13],
		CGroup[14], CGroup[15], speed, initLerp));

	GCam_Follow(CGroup, speed, initLerp);
}

//input is assumed to be placed at the very beginning of the $tag(
static void ProcessTag(const int entID, char* startpoint)
{
	vec3_t data;
	char* s = startpoint;
	char endtext[MAX_QPATH];
	int type = TYPE_ORIGIN;

	//find the end of the tag thingy
	s++;
	char* endpoint = strchr(s, '$');
	endpoint++;

	strcpy(endtext, endpoint);

	//bump the string to where the entity name starts
	s += 4;

	while (*s == ' ')
	{
		s++;
	}

	const char* classname = s;

	while (*classname != ' ' && *s != ',')
	{
		s++;
	}

	endpoint = s;

	while (*s == ',' || *s == ' ')
	{
		s++;
	}

	if (*s == 'A')
	{
		type = TYPE_ANGLES; //angle
	}

	*endpoint = '\0';

	Q3_GetTag(entID, classname, type, data);
	*startpoint = '\0';
	strcat(startpoint, va("< %f %f %f >", data[0], data[1], data[2]));

	strcat(startpoint, endtext);
}

//replaces any tags with their related data
void ParseTags(const int entID, const char* data)
{
	char* tagstart;
	while ((tagstart = strchr(data, '$')) != NULL)
	{
		ProcessTag(entID, tagstart);
	}
}

void ICam_Shake(const float intensity, const int duration)
{
	trap->SetConfigstring(CS_CAMERA, va("shake %f %i", intensity, duration));
}

//move the "player" script_targetname to whoever is in the lead
void UpdatePlayerScriptTarget(void)
{
	int clientNum = -1;

	if (level.gametype != GT_SINGLE_PLAYER)
	{
		//only used for CoOp
		return;
	}

	//find the clientNum for the top ranker
	for (int i = 0; i < MAX_CLIENTS; i++)
	{
		if (!g_entities[i].inuse)
		{
			continue;
		}

		if (g_entities[i].client
			&& (g_entities[i].client->ps.persistant[PERS_RANK] == 0
				|| g_entities[i].client->ps.persistant[PERS_RANK] == RANK_TIED_FLAG))
		{
			//found them
			clientNum = g_entities[i].client->ps.clientNum;
			break;
		}
	}

	if (clientNum == -1)
	{
		//no clients ingame yet!
		return;
	}

	gentity_t* test = G_Find(NULL, FOFS(script_targetname), "player");
	if (test)
	{
		if (test->client->ps.clientNum != clientNum)
		{
			//remove the "player" tag
			test->script_targetname = NULL;
			test->targetname = NULL;
		}
		else
		{
			//already set
			return;
		}
	}

	g_entities[clientNum].script_targetname = "player";
	g_entities[clientNum].targetname = "player";
	g_entities[clientNum].NPC_targetname = "player";
}

//remove the comma from a char string
void RemoveComma(char* comma)
{
	char* s = comma;

	while (*s && *s != ',')
	{
		s++;
	}

	if (*s && *s == ',')
	{
		*s = '\0';
	}
}

/*
============
Q3_SetRenderCullRadius
Description	: allows NPCs to be drawn even when their origin is very far away from their model
Return type	: static void
Argument		: int entID
Argument		: float float_data (the new radius for render culling)
============
*/
static void Q3_SetRenderCullRadius(const int entID, const float float_data)
{
	gentity_t* self = &g_entities[entID];

	if (!self)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetRenderCullRadius: invalid entID %d\n", entID);
		return;
	}

	self->radius = float_data;
}

//find the current name of whatever trigger_location the entity is inside of.  if it's
//inside none of them, return NULL
char* G_GetLocationForEnt(const gentity_t* self)
{
	int touch[MAX_GENTITIES];
	vec3_t mins, maxs;

	VectorAdd(self->r.currentOrigin, self->r.mins, mins);
	VectorAdd(self->r.currentOrigin, self->r.maxs, maxs);
	const int num = trap->EntitiesInBox(mins, maxs, touch, MAX_GENTITIES);

	for (int i = 0; i < num; i++)
	{
		const gentity_t* hit = &g_entities[touch[i]];
		if (strcmp(hit->classname, "trigger_location") == 0)
		{
			return hit->message;
		}
	}

	return NULL;
}

//toggle the forcepower for this entity
//ported from SP.
void Q3_SetForcePower(const int entID, const int forcePower, const qboolean powerOn)
{
	const gentity_t* ent = &g_entities[entID];
	if (!ent)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetForcePower: invalid entID %d\n", entID);
		return;
	}
	if (!ent->client)
	{
		G_DebugPrint(WL_WARNING, "Q3_SetForcePower: ent # %d not a client!\n", entID);
		return;
	}
	if (powerOn)
	{
		ent->client->ps.fd.forcePowersActive |= 1 << forcePower;
	}
	else
	{
		ent->client->ps.fd.forcePowersActive &= ~(1 << forcePower);
	}
}

void ToggleNPCWinterGear(gentity_t* ent)
{
	//toggles the winter gear for an NPC
	char model[MAX_QPATH];

	if (!ent->s.modelIndex)
	{
		//no model?!
		return;
	}

	//get the model name for this NPC
	trap->GetConfigstring(CS_MODELS + ent->s.modelIndex, model, MAX_QPATH);

	if (WinterGear)
	{
		//use winter gear
		char* skinname = strstr(model, "|");
		if (skinname)
		{
			//we're using a species player model, try to use their hoth clothes.
			skinname++;
			strstr(skinname, "|");
			if (skinname)
			{
				//this should always be true for good specie skins I think
				strcpy(skinname, "torso_g1|lower_e1\0");
			}

			ent->s.modelIndex = G_model_index(model);
		}
	}
}

/*
-------------------------------------------------------------------------------------------
ICARUS Declared Variable Code
-------------------------------------------------------------------------------------------
*/

/*
-------------------------
GetDeclaredVariableFromName
-------------------------
*/
static DeclaredVariable_t* GetDeclaredVariableFromName(const char* name)
{
	for (int i = 0; i < MAX_DECLAREDVARIABLES; i++)
	{
		if (strcmp(DeclaredVariables[i].name, name) == 0)
		{
			return &DeclaredVariables[i];
		}
	}
	return NULL;
}

/*
-------------------------
GetStringDeclaredVariable
-------------------------
*/
int GetStringDeclaredVariable(const char* name, char** value)
{
	//returns 1 for success; 0 for fail
	DeclaredVariable_t* strVar = GetDeclaredVariableFromName(name);

	if (strVar != NULL)
	{
		*value = strVar->Data;
		return 1;
	}

	G_DebugPrint(WL_ERROR, "ICARUS Declared Variable %s not found!\n", name);
	return 0;
}

/*
-------------------------
GetFloatDeclaredVariable
-------------------------
*/
int GetFloatDeclaredVariable(const char* name, float* value)
{
	//returns 1 for success; 0 for fail
	const DeclaredVariable_t* floatVar = GetDeclaredVariableFromName(name);

	if (floatVar != NULL)
	{
		*value = atof(floatVar->Data);
		return 1;
	}

	G_DebugPrint(WL_ERROR, "ICARUS Declared Variable %s not found!\n", name);
	return 0;
}

/*
-------------------------
GetVectorDeclaredVariable
-------------------------
*/
int GetVectorDeclaredVariable(const char* name, vec3_t value)
{
	//returns 1 for success; 0 for fail
	const DeclaredVariable_t* vectorVar = GetDeclaredVariableFromName(name);

	if (vectorVar != NULL)
	{
		const char* str = vectorVar->Data;

		if (sscanf(str, "%f %f %f", &value[0], &value[1], &value[2]) == 3)
		{
			return 1;
		}
		G_DebugPrint(WL_ERROR, "ICARUS Declared Variable %s failed parse vector!\n", name);
		return 0;
	}

	G_DebugPrint(WL_ERROR, "ICARUS Declared Variable %s not found!\n", name);
	return 0;
}

/*
-------------------------
SetVar
-------------------------
*/
void SetVar(const char* type_name, const char* data)
{
	DeclaredVariable_t* var = GetDeclaredVariableFromName(type_name);
	if (var != NULL)
	{
		Q_strncpyz(var->Data, data, sizeof var->Data);
		return;
	}
	if (numDeclaredVariables >= MAX_DECLAREDVARIABLES)
	{
		G_DebugPrint(WL_ERROR, "Too many variables already declared, maximum is %d!\n", MAX_DECLAREDVARIABLES);
		return;
	}
	if (!DeclaredVariables[numDeclaredVariables].inuse)
	{
		DeclaredVariable_t* declared_variable_s = &DeclaredVariables[numDeclaredVariables];
		Q_strncpyz(declared_variable_s->name, type_name, sizeof declared_variable_s->name);
		Q_strncpyz(declared_variable_s->Data, data, sizeof declared_variable_s->Data);
		declared_variable_s->inuse = qtrue;
		numDeclaredVariables++;
		return;
	}
	G_DebugPrint(WL_ERROR, "ICARUS Declared Variable %s could not be created!\n", type_name);
}

/*
-------------------------------------------------------------------------------------------
End of ICARUS Declared Variable Code
-------------------------------------------------------------------------------------------
*/